From a7d18b9d02c4d59eaad51cbb245c06f7107a00ef Mon Sep 17 00:00:00 2001
From: Bruce Schmid <duck@freescale.com>
Date: Fri, 8 Aug 2008 10:03:58 -0600
Subject: [PATCH] USB gadget

LTIBName: m5445x-usb-gadget
Signed-off-by: Bruce Schmid <duck@freescale.com>
---
 drivers/usb/gadget/Kconfig        |   28 +-
 drivers/usb/gadget/fsl_usb2_udc.c |  432 +++++++++++---
 drivers/usb/gadget/fsl_usb2_udc.h |  216 +++++++-
 drivers/usb/gadget/gadget_chips.h |    4 +
 drivers/usb/gadget/mcf5445x_udc.c | 1192 ++++++++++++++++++-------------------
 5 files changed, 1140 insertions(+), 732 deletions(-)

diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index ac03777..a20f4fd 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -131,10 +131,10 @@ config USB_ATMEL_USBA
 
 config USB_GADGET_FSL_USB2
 	boolean "Freescale Highspeed USB DR Peripheral Controller"
-	depends on FSL_SOC
+	depends on FSL_SOC || (HAVE_FSL_USB_DR && USB_M5445X_ULPI)
 	select USB_GADGET_DUALSPEED
 	help
-	   Some of Freescale PowerPC processors have a High Speed
+	   Some of Freescale processors have a High Speed
 	   Dual-Role(DR) USB controller, which supports device mode.
 
 	   The number of programmable endpoints is different through
@@ -231,26 +231,6 @@ config SUPERH_BUILT_IN_M66592
 	   However, this problem is improved if change a value of
 	   NET_IP_ALIGN to 4.
 
-config USB_GADGET_MCF5445X
-	boolean "MCF5445X USB Device Controller"
-	depends on M54455 && USB_M5445X_ULPI
-	select USB_GADGET_DUALSPEED
-	help
-	   Freescale's MCF5445X processors include
-	   an integrated device controller (as part of the OTG module).
-	   It has four programmable, bidirectional endpoints,
-	   including endpoint 0.
-
-	   Say "y" to link the driver statically, or "m" to build a
-	   dynamically linked module called "mcf5445_udc" and force all
-	   gadget drivers to also be dynamically linked.
-
-config USB_MCF5445X
-	tristate
-	depends on USB_GADGET_MCF5445X
-	default USB_GADGET
-	select USB_GADGET_SELECTED
-
 config USB_GADGET_GOKU
 	boolean "Toshiba TC86C001 'Goku-S'"
 	depends on PCI
@@ -381,14 +361,14 @@ endchoice
 config USB_OTG
 	boolean "OTG Support"
 	depends on (USB_GADGET_OMAP && ARCH_OMAP_OTG && USB_OHCI_HCD) || \
-		   (USB_GADGET_MCF5445X && USB_M5445X_ULPI)
+		   USB_GADGET_FSL_USB2
 	help
 	   The most notable feature of USB OTG is support for a
 	   "Dual-Role" device, which can act as either a device
 	   or a host.  The initial role choice can be changed
 	   later, when two dual-role devices talk to each other.
 
-	   Select this only if your OMAP board has a Mini-AB connector.
+	   Select this only if your board has a Mini-AB connector.
 
 config USB_GADGET_DUALSPEED
 	bool
diff --git a/drivers/usb/gadget/fsl_usb2_udc.c b/drivers/usb/gadget/fsl_usb2_udc.c
index 254012a..7df56ef 100644
--- a/drivers/usb/gadget/fsl_usb2_udc.c
+++ b/drivers/usb/gadget/fsl_usb2_udc.c
@@ -1,5 +1,11 @@
 /*
- * Copyright (C) 2004-2007 Freescale Semicondutor, Inc. All rights reserved.
+ * Copyright (C) 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
  *
  * Author: Li Yang <leoli@freescale.com>
  *         Jiang Bo <tanya.jiang@freescale.com>
@@ -61,11 +67,11 @@
 static const char driver_name[] = "fsl-usb2-udc";
 static const char driver_desc[] = DRIVER_DESC;
 
-volatile static struct usb_dr_device *dr_regs = NULL;
-volatile static struct usb_sys_interface *usb_sys_regs = NULL;
+volatile static struct usb_dr_device *dr_regs;
+volatile static struct usb_sys_interface *usb_sys_regs;
 
 /* it is initialized in probe()  */
-static struct fsl_udc *udc_controller = NULL;
+static struct fsl_udc *udc_controller;
 
 static const struct usb_endpoint_descriptor
 fsl_ep0_desc = {
@@ -76,21 +82,57 @@ fsl_ep0_desc = {
 	.wMaxPacketSize =	USB_MAX_CTRL_PAYLOAD,
 };
 
-static int fsl_udc_suspend(struct platform_device *pdev, pm_message_t state);
-static int fsl_udc_resume(struct platform_device *pdev);
+static int udc_suspend(struct fsl_udc *udc);
+static int fsl_udc_suspend(struct device *dev, pm_message_t state);
+static int fsl_udc_resume(struct device *dev);
 static void fsl_ep_fifo_flush(struct usb_ep *_ep);
 
-#ifdef CONFIG_PPC32
-#define fsl_readl(addr)		in_le32(addr)
-#define fsl_writel(addr, val32) out_le32(val32, addr)
-#else
-#define fsl_readl(addr)		readl(addr)
-#define fsl_writel(addr, val32) writel(addr, val32)
+#ifdef CONFIG_USB_OTG
+/* Get platform resource from OTG driver */
+extern struct resource *otg_get_resources(void);
 #endif
 
+
 /********************************************************************
  *	Internal Used Function
 ********************************************************************/
+
+#ifdef DUMP_QUEUES
+static void dump_ep_queue(struct fsl_ep *ep)
+{
+	int ep_index;
+	struct fsl_req *req;
+	struct ep_td_struct *dtd;
+
+	if (list_empty(&ep->queue)) {
+		pr_debug("udc: empty\n");
+		return;
+	}
+
+	ep_index = ep_index(ep) * 2 + ep_is_in(ep);
+	pr_debug("udc: ep=0x%p  index=%d\n", ep, ep_index);
+
+	list_for_each_entry(req, &ep->queue, queue) {
+		pr_debug("udc: req=0x%p  dTD count=%d\n", req, req->dtd_count);
+		pr_debug("udc: dTD head=0x%p  tail=0x%p\n", req->head,
+			 req->tail);
+
+		dtd = req->head;
+
+		while (dtd) {
+			if (le32_to_cpu(dtd->next_td_ptr) & DTD_NEXT_TERMINATE)
+				break;	/* end of dTD list */
+
+			dtd = dtd->next_td_virt;
+		}
+	}
+}
+#else
+static inline void dump_ep_queue(struct fsl_ep *ep)
+{
+}
+#endif
+
 /*-----------------------------------------------------------------
  * done() - retire a request; caller blocked irqs
  * @status : request status to be set, only works when
@@ -173,6 +215,7 @@ static void nuke(struct fsl_ep *ep, int status)
 		req = list_entry(ep->queue.next, struct fsl_req, queue);
 		done(ep, req, status);
 	}
+	dump_ep_queue(ep);
 }
 
 /*------------------------------------------------------------------
@@ -181,13 +224,17 @@ static void nuke(struct fsl_ep *ep, int status)
 
 static int dr_controller_setup(struct fsl_udc *udc)
 {
-	unsigned int tmp = 0, portctrl = 0, ctrl = 0;
+	unsigned int tmp = 0, portctrl = 0;
+	unsigned int __attribute((unused)) ctrl = 0;
 	unsigned long timeout;
+	struct fsl_usb2_platform_data *pdata;
+
 #define FSL_UDC_RESET_TIMEOUT 1000
 
 	/* before here, make sure dr_regs has been initialized */
 	if (!udc)
 		return -EINVAL;
+	pdata = udc->pdata;
 
 	/* Stop and reset the usb controller */
 	tmp = fsl_readl(&dr_regs->usbcmd);
@@ -210,11 +257,16 @@ static int dr_controller_setup(struct fsl_udc *udc)
 
 	/* Set the controller as device mode */
 	tmp = fsl_readl(&dr_regs->usbmode);
+	tmp &= ~USB_MODE_CTRL_MODE_MASK;	/* clear mode bits */
 	tmp |= USB_MODE_CTRL_MODE_DEVICE;
 	/* Disable Setup Lockout */
 	tmp |= USB_MODE_SETUP_LOCK_OFF;
+	if (pdata->es)
+		tmp |= USB_MODE_ES;
 	fsl_writel(tmp, &dr_regs->usbmode);
 
+	fsl_platform_set_device_mode(pdata);
+
 	/* Clear the setup status */
 	fsl_writel(0, &dr_regs->usbsts);
 
@@ -247,20 +299,17 @@ static int dr_controller_setup(struct fsl_udc *udc)
 	}
 	fsl_writel(portctrl, &dr_regs->portsc1);
 
-	/* Config control enable i/o output, cpu endian register */
-	ctrl = __raw_readl(&usb_sys_regs->control);
-	ctrl |= USB_CTRL_IOENB;
-	__raw_writel(ctrl, &usb_sys_regs->control);
-
 #if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
 	/* Turn on cache snooping hardware, since some PowerPC platforms
 	 * wholly rely on hardware to deal with cache coherent. */
 
-	/* Setup Snooping for all the 4GB space */
-	tmp = SNOOP_SIZE_2GB;	/* starts from 0x0, size 2G */
-	__raw_writel(tmp, &usb_sys_regs->snoop1);
-	tmp |= 0x80000000;	/* starts from 0x8000000, size 2G */
-	__raw_writel(tmp, &usb_sys_regs->snoop2);
+	if (pdata->have_sysif_regs) {
+		/* Setup Snooping for all the 4GB space */
+		tmp = SNOOP_SIZE_2GB;	/* starts from 0x0, size 2G */
+		__raw_writel(tmp, &usb_sys_regs->snoop1);
+		tmp |= 0x80000000;	/* starts from 0x8000000, size 2G */
+		__raw_writel(tmp, &usb_sys_regs->snoop2);
+	}
 #endif
 
 	return 0;
@@ -271,6 +320,8 @@ static void dr_controller_run(struct fsl_udc *udc)
 {
 	u32 temp;
 
+	fsl_platform_pullup_enable(udc->pdata);
+
 	/* Enable DR irq reg */
 	temp = USB_INTR_INT_EN | USB_INTR_ERR_INT_EN
 		| USB_INTR_PTC_DETECT_EN | USB_INTR_RESET_EN
@@ -281,11 +332,6 @@ static void dr_controller_run(struct fsl_udc *udc)
 	/* Clear stopped bit */
 	udc->stopped = 0;
 
-	/* Set the controller as device mode */
-	temp = fsl_readl(&dr_regs->usbmode);
-	temp |= USB_MODE_CTRL_MODE_DEVICE;
-	fsl_writel(temp, &dr_regs->usbmode);
-
 	/* Set controller to Run */
 	temp = fsl_readl(&dr_regs->usbcmd);
 	temp |= USB_CMD_RUN_STOP;
@@ -298,6 +344,19 @@ static void dr_controller_stop(struct fsl_udc *udc)
 {
 	unsigned int tmp;
 
+	pr_debug("%s\n", __FUNCTION__);
+
+	/* if we're in OTG mode, and the Host is currently using the port,
+	 * stop now and don't rip the controller out from under the
+	 * ehci driver
+	 */
+	if (udc->gadget.is_otg) {
+		if (!(fsl_readl(&dr_regs->otgsc) & OTGSC_STS_USB_ID)) {
+			pr_debug("udc: Leaving early\n");
+			return;
+		}
+	}
+
 	/* disable all INTR */
 	fsl_writel(0, &dr_regs->usbintr);
 
@@ -307,6 +366,8 @@ static void dr_controller_stop(struct fsl_udc *udc)
 	/* disable IO output */
 /*	usb_sys_regs->control = 0; */
 
+	fsl_platform_pullup_disable(udc->pdata);
+
 	/* set controller to Stop */
 	tmp = fsl_readl(&dr_regs->usbcmd);
 	tmp &= ~USB_CMD_RUN_STOP;
@@ -414,7 +475,7 @@ static void struct_ep_qh_setup(struct fsl_udc *udc, unsigned char ep_num,
 	}
 	if (zlt)
 		tmp |= EP_QUEUE_HEAD_ZLT_SEL;
-	p_QH->max_pkt_length = cpu_to_le32(tmp);
+	p_QH->max_pkt_length = cpu_to_hc32(tmp);
 
 	return;
 }
@@ -522,7 +583,7 @@ static int fsl_ep_enable(struct usb_ep *_ep,
 	spin_unlock_irqrestore(&udc->lock, flags);
 	retval = 0;
 
-	VDBG("enabled %s (ep%d%s) maxpacket %d",ep->ep.name,
+	VDBG("enabled %s (ep%d%s) maxpacket %d", ep->ep.name,
 			ep->desc->bEndpointAddress & 0x0f,
 			(desc->bEndpointAddress & USB_DIR_IN)
 				? "in" : "out", max);
@@ -621,7 +682,7 @@ static int fsl_queue_td(struct fsl_ep *ep, struct fsl_req *req)
 		struct fsl_req *lastreq;
 		lastreq = list_entry(ep->queue.prev, struct fsl_req, queue);
 		lastreq->tail->next_td_ptr =
-			cpu_to_le32(req->head->td_dma & DTD_ADDR_MASK);
+			cpu_to_hc32(req->head->td_dma & DTD_ADDR_MASK);
 		/* Read prime bit, if 1 goto done */
 		if (fsl_readl(&dr_regs->endpointprime) & bitmask)
 			goto out;
@@ -646,10 +707,10 @@ static int fsl_queue_td(struct fsl_ep *ep, struct fsl_req *req)
 
 	/* Write dQH next pointer and terminate bit to 0 */
 	temp = req->head->td_dma & EP_QUEUE_HEAD_NEXT_POINTER_MASK;
-	dQH->next_dtd_ptr = cpu_to_le32(temp);
+	dQH->next_dtd_ptr = cpu_to_hc32(temp);
 
 	/* Clear active and halt bit */
-	temp = cpu_to_le32(~(EP_QUEUE_HEAD_STATUS_ACTIVE
+	temp = cpu_to_hc32(~(EP_QUEUE_HEAD_STATUS_ACTIVE
 			| EP_QUEUE_HEAD_STATUS_HALT));
 	dQH->size_ioc_int_sts &= temp;
 
@@ -684,17 +745,17 @@ static struct ep_td_struct *fsl_build_dtd(struct fsl_req *req, unsigned *length,
 
 	dtd->td_dma = *dma;
 	/* Clear reserved field */
-	swap_temp = cpu_to_le32(dtd->size_ioc_sts);
+	swap_temp = hc32_to_cpu(dtd->size_ioc_sts);
 	swap_temp &= ~DTD_RESERVED_FIELDS;
-	dtd->size_ioc_sts = cpu_to_le32(swap_temp);
+	dtd->size_ioc_sts = cpu_to_hc32(swap_temp);
 
 	/* Init all of buffer page pointers */
 	swap_temp = (u32) (req->req.dma + req->req.actual);
-	dtd->buff_ptr0 = cpu_to_le32(swap_temp);
-	dtd->buff_ptr1 = cpu_to_le32(swap_temp + 0x1000);
-	dtd->buff_ptr2 = cpu_to_le32(swap_temp + 0x2000);
-	dtd->buff_ptr3 = cpu_to_le32(swap_temp + 0x3000);
-	dtd->buff_ptr4 = cpu_to_le32(swap_temp + 0x4000);
+	dtd->buff_ptr0 = cpu_to_hc32(swap_temp);
+	dtd->buff_ptr1 = cpu_to_hc32(swap_temp + 0x1000);
+	dtd->buff_ptr2 = cpu_to_hc32(swap_temp + 0x2000);
+	dtd->buff_ptr3 = cpu_to_hc32(swap_temp + 0x3000);
+	dtd->buff_ptr4 = cpu_to_hc32(swap_temp + 0x4000);
 
 	req->req.actual += *length;
 
@@ -718,7 +779,7 @@ static struct ep_td_struct *fsl_build_dtd(struct fsl_req *req, unsigned *length,
 	if (*is_last && !req->req.no_interrupt)
 		swap_temp |= DTD_IOC;
 
-	dtd->size_ioc_sts = cpu_to_le32(swap_temp);
+	dtd->size_ioc_sts = cpu_to_hc32(swap_temp);
 
 	mb();
 
@@ -732,7 +793,7 @@ static int fsl_req_to_dtd(struct fsl_req *req)
 {
 	unsigned	count;
 	int		is_last;
-	int		is_first =1;
+	int		is_first = 1;
 	struct ep_td_struct	*last_dtd = NULL, *dtd;
 	dma_addr_t dma;
 
@@ -745,7 +806,7 @@ static int fsl_req_to_dtd(struct fsl_req *req)
 			is_first = 0;
 			req->head = dtd;
 		} else {
-			last_dtd->next_td_ptr = cpu_to_le32(dma);
+			last_dtd->next_td_ptr = cpu_to_hc32(dma);
 			last_dtd->next_td_virt = dtd;
 		}
 		last_dtd = dtd;
@@ -753,7 +814,7 @@ static int fsl_req_to_dtd(struct fsl_req *req)
 		req->dtd_count++;
 	} while (!is_last);
 
-	dtd->next_td_ptr = cpu_to_le32(DTD_NEXT_TERMINATE);
+	dtd->next_td_ptr = cpu_to_hc32(DTD_NEXT_TERMINATE);
 
 	req->tail = dtd;
 
@@ -800,6 +861,18 @@ fsl_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 						? DMA_TO_DEVICE
 						: DMA_FROM_DEVICE);
 		req->mapped = 1;
+		if (0) {	// DDD RS debug
+			u32 *buf = req->req.buf;
+			u32 *dma = (u32 *)req->req.dma;
+			int len = (int)req->req.length;
+
+			printk("did map_single.  buf %p  dma %p  len %d\n",
+				buf, dma, len);
+			if (len) {
+				//printk("*buf %08x   *dma %08x\n", *buf, *dma);
+				printk("*buf %08x %08x \n", *buf, *(buf+1));
+			}
+		}
 	} else {
 		dma_sync_single_for_device(ep->udc->gadget.dev.parent,
 					req->req.dma, req->req.length,
@@ -966,6 +1039,36 @@ out:
 	return status;
 }
 
+static int arcotg_fifo_status(struct usb_ep *_ep)
+{
+	struct fsl_ep *ep;
+	struct fsl_udc *udc;
+	int size = 0;
+	u32 bitmask;
+	struct ep_queue_head *d_qh;
+
+	ep = container_of(_ep, struct fsl_ep, ep);
+	if (!_ep || (!ep->desc && ep_index(ep) != 0))
+		return -ENODEV;
+
+	udc = (struct fsl_udc *)ep->udc;
+
+	if (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)
+		return -ESHUTDOWN;
+
+	d_qh = &ep->udc->ep_qh[ep_index(ep) * 2 + ep_is_in(ep)];
+
+	bitmask = (ep_is_in(ep)) ? (1 << (ep_index(ep) + 16)) :
+	    (1 << (ep_index(ep)));
+
+	if (fsl_readl(&dr_regs->endptstatus) & bitmask)
+		size = (d_qh->size_ioc_int_sts & DTD_PACKET_SIZE)
+		    >> DTD_LENGTH_BIT_POS;
+
+	pr_debug("%s %u\n", __FUNCTION__, size);
+	return size;
+}
+
 static void fsl_ep_fifo_flush(struct usb_ep *_ep)
 {
 	struct fsl_ep *ep;
@@ -1018,6 +1121,7 @@ static struct usb_ep_ops fsl_ep_ops = {
 	.dequeue = fsl_ep_dequeue,
 
 	.set_halt = fsl_ep_set_halt,
+	.fifo_status = arcotg_fifo_status,
 	.fifo_flush = fsl_ep_fifo_flush,	/* flush fifo */
 };
 
@@ -1121,7 +1225,6 @@ static int fsl_pullup(struct usb_gadget *gadget, int is_on)
 static struct usb_gadget_ops fsl_gadget_ops = {
 	.get_frame = fsl_get_frame,
 	.wakeup = fsl_wakeup,
-/*	.set_selfpowered = fsl_set_selfpowered,	*/ /* Always selfpowered */
 	.vbus_session = fsl_vbus_session,
 	.vbus_draw = fsl_vbus_draw,
 	.pullup = fsl_pullup,
@@ -1411,6 +1514,7 @@ static void tripwire_handler(struct fsl_udc *udc, u8 ep_num, u8 *buffer_ptr)
 {
 	u32 temp;
 	struct ep_queue_head *qh;
+	struct fsl_usb2_platform_data *pdata = udc->pdata;
 
 	qh = &udc->ep_qh[ep_num * 2 + EP_DIR_OUT];
 
@@ -1425,7 +1529,16 @@ static void tripwire_handler(struct fsl_udc *udc, u8 ep_num, u8 *buffer_ptr)
 		fsl_writel(temp | USB_CMD_SUTW, &dr_regs->usbcmd);
 
 		/* Copy the setup packet to local buffer */
-		memcpy(buffer_ptr, (u8 *) qh->setup_buffer, 8);
+		if (pdata->le_setup_buf) {
+			u32 *p = (u32 *)buffer_ptr;
+			u32 *s = (u32 *)qh->setup_buffer;
+
+			/* Convert little endian setup buffer to CPU endian */
+			*p++ = le32_to_cpu(*s++);
+			*p = le32_to_cpu(*s);
+		} else {
+			memcpy(buffer_ptr, (u8 *) qh->setup_buffer, 8);
+		}
 	} while (!(fsl_readl(&dr_regs->usbcmd) & USB_CMD_SUTW));
 
 	/* Clear Setup Tripwire */
@@ -1449,19 +1562,19 @@ static int process_ep_req(struct fsl_udc *udc, int pipe,
 	actual = curr_req->req.length;
 
 	for (j = 0; j < curr_req->dtd_count; j++) {
-		remaining_length = (le32_to_cpu(curr_td->size_ioc_sts)
+		remaining_length = (hc32_to_cpu(curr_td->size_ioc_sts)
 					& DTD_PACKET_SIZE)
 				>> DTD_LENGTH_BIT_POS;
 		actual -= remaining_length;
 
-		if ((errors = le32_to_cpu(curr_td->size_ioc_sts) &
-						DTD_ERROR_MASK)) {
+		errors = hc32_to_cpu(curr_td->size_ioc_sts) & DTD_ERROR_MASK;
+		if (errors) {
 			if (errors & DTD_STATUS_HALTED) {
 				ERR("dTD error %08x QH=%d\n", errors, pipe);
 				/* Clear the errors and Halt condition */
-				tmp = le32_to_cpu(curr_qh->size_ioc_int_sts);
+				tmp = hc32_to_cpu(curr_qh->size_ioc_int_sts);
 				tmp &= ~errors;
-				curr_qh->size_ioc_int_sts = cpu_to_le32(tmp);
+				curr_qh->size_ioc_int_sts = cpu_to_hc32(tmp);
 				status = -EPIPE;
 				/* FIXME: continue with next queued TD? */
 
@@ -1479,7 +1592,7 @@ static int process_ep_req(struct fsl_udc *udc, int pipe,
 				ERR("Unknown error has occured (0x%x)!\r\n",
 					errors);
 
-		} else if (le32_to_cpu(curr_td->size_ioc_sts)
+		} else if (hc32_to_cpu(curr_td->size_ioc_sts)
 				& DTD_STATUS_ACTIVE) {
 			VDBG("Request not complete");
 			status = REQ_UNCOMPLETE;
@@ -1560,6 +1673,8 @@ static void dtd_complete_irq(struct fsl_udc *udc)
 			} else
 				done(curr_ep, curr_req, status);
 		}
+
+		dump_ep_queue(curr_ep);
 	}
 }
 
@@ -1755,6 +1870,7 @@ static irqreturn_t fsl_udc_irq(int irq, void *_udc)
 
 	/* Reset Received */
 	if (irq_src & USB_STS_RESET) {
+		VDBG("reset int");
 		reset_irq(udc);
 		status = IRQ_HANDLED;
 	}
@@ -1812,17 +1928,40 @@ int usb_gadget_register_driver(struct usb_gadget_driver *driver)
 		goto out;
 	}
 
-	/* Enable DR IRQ reg and Set usbcmd reg  Run bit */
-	dr_controller_run(udc_controller);
-	udc_controller->usb_state = USB_STATE_ATTACHED;
-	udc_controller->ep0_state = WAIT_FOR_SETUP;
-	udc_controller->ep0_dir = 0;
+	if (udc_controller->transceiver) {
+		/* Suspend the controller until OTG enable it */
+		udc_controller->stopped = 1;
+		printk(KERN_INFO "Suspend udc for OTG auto detect\n");
+
+		/* export udc suspend/resume call to OTG */
+		udc_controller->gadget.dev.driver->suspend = fsl_udc_suspend;
+		udc_controller->gadget.dev.driver->resume = fsl_udc_resume;
+
+		/* connect to bus through transceiver */
+		if (udc_controller->transceiver) {
+			retval = otg_set_peripheral(udc_controller->transceiver,
+						    &udc_controller->gadget);
+			if (retval < 0) {
+				ERR("can't bind to transceiver\n");
+				driver->unbind(&udc_controller->gadget);
+				udc_controller->gadget.dev.driver = 0;
+				udc_controller->driver = 0;
+				return retval;
+			}
+		}
+	} else {
+		/* Enable DR IRQ reg and Set usbcmd reg  Run bit */
+		dr_controller_run(udc_controller);
+		udc_controller->usb_state = USB_STATE_ATTACHED;
+		udc_controller->ep0_state = WAIT_FOR_SETUP;
+		udc_controller->ep0_dir = 0;
+	}
 	printk(KERN_INFO "%s: bind to driver %s \n",
 			udc_controller->gadget.name, driver->driver.name);
 
 out:
 	if (retval)
-		printk("retval %d \n", retval);
+		printk(KERN_DEBUG "retval %d \n", retval);
 	return retval;
 }
 EXPORT_SYMBOL(usb_gadget_register_driver);
@@ -1864,7 +2003,8 @@ int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
 	udc_controller->gadget.dev.driver = 0;
 	udc_controller->driver = 0;
 
-	printk("unregistered gadget driver '%s'\r\n", driver->driver.name);
+	printk(KERN_INFO "unregistered gadget driver '%s'\r\n",
+	       driver->driver.name);
 	return 0;
 }
 EXPORT_SYMBOL(usb_gadget_unregister_driver);
@@ -1889,8 +2029,10 @@ static int fsl_proc_read(char *page, char **start, off_t off, int count,
 	u32 tmp_reg;
 	struct fsl_ep *ep = NULL;
 	struct fsl_req *req;
+	struct fsl_usb2_platform_data *pdata;
 
 	struct fsl_udc *udc = udc_controller;
+	pdata = udc->pdata;
 	if (off != 0)
 		return 0;
 
@@ -2057,16 +2199,18 @@ static int fsl_proc_read(char *page, char **start, off_t off, int count,
 	size -= t;
 	next += t;
 
-	tmp_reg = usb_sys_regs->snoop1;
-	t = scnprintf(next, size, "\nSnoop1 Reg : = [0x%x]\n\n", tmp_reg);
-	size -= t;
-	next += t;
+	if (pdata->have_sysif_regs) {
+		tmp_reg = usb_sys_regs->snoop1;
+		t = scnprintf(next, size, "\nSnoop1 Reg = [0x%x]\n\n", tmp_reg);
+		size -= t;
+		next += t;
 
-	tmp_reg = usb_sys_regs->control;
-	t = scnprintf(next, size, "General Control Reg : = [0x%x]\n\n",
-			tmp_reg);
-	size -= t;
-	next += t;
+		tmp_reg = usb_sys_regs->control;
+		t = scnprintf(next, size, "General Control Reg = [0x%x]\n\n",
+				tmp_reg);
+		size -= t;
+		next += t;
+	}
 
 	/* ------fsl_udc, fsl_ep, fsl_request structure information ----- */
 	ep = &udc->eps[0];
@@ -2114,7 +2258,7 @@ static int fsl_proc_read(char *page, char **start, off_t off, int count,
 						req->req.length, req->req.buf);
 					size -= t;
 					next += t;
-					}	/* end for each_entry of ep req */
+					} /* end for each_entry of ep req */
 				}	/* end for else */
 			}	/* end for if(ep->queue) */
 		}		/* end (ep->desc) */
@@ -2247,6 +2391,7 @@ static int __init struct_ep_setup(struct fsl_udc *udc, unsigned char index,
 static int __init fsl_udc_probe(struct platform_device *pdev)
 {
 	struct resource *res;
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
 	int ret = -ENODEV;
 	unsigned int i;
 	u32 dccparams;
@@ -2261,28 +2406,56 @@ static int __init fsl_udc_probe(struct platform_device *pdev)
 		ERR("malloc udc failed\n");
 		return -ENOMEM;
 	}
+	udc_controller->pdata = pdata;
+
+#ifdef CONFIG_USB_OTG
+	/* Memory and interrupt resources will be passed from OTG */
+	udc_controller->transceiver = otg_get_transceiver();
+	if (!udc_controller->transceiver) {
+		printk(KERN_ERR "Can't find OTG driver!\n");
+		ret = -ENODEV;
+		goto err1a;
+	}
 
+	res = otg_get_resources();
+	if (!res) {
+		DBG("resource not registered!\n");
+		return -ENODEV;
+	}
+#else
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
-		kfree(udc_controller);
-		return -ENXIO;
+		ret = -ENXIO;
+		goto err1a;
 	}
 
 	if (!request_mem_region(res->start, res->end - res->start + 1,
 				driver_name)) {
 		ERR("request mem region for %s failed \n", pdev->name);
-		kfree(udc_controller);
-		return -EBUSY;
+		ret = -EBUSY;
+		goto err1a;
 	}
-
+#endif
 	dr_regs = ioremap(res->start, res->end - res->start + 1);
 	if (!dr_regs) {
 		ret = -ENOMEM;
 		goto err1;
 	}
+	pdata->regs = (void *)dr_regs;
 
-	usb_sys_regs = (struct usb_sys_interface *)
-			((u32)dr_regs + USB_DR_SYS_OFFSET);
+	fsl_set_usb_accessors(pdata);
+
+	/*
+	 * do platform specific init: check the clock, grab/config pins, etc.
+	 */
+	if (pdata->platform_init && pdata->platform_init(pdev)) {
+		ret = -ENODEV;
+		goto err2a;
+	}
+
+	if (pdata->have_sysif_regs)
+		usb_sys_regs = (struct usb_sys_interface *)
+				((u32)dr_regs + USB_DR_SYS_OFFSET);
 
 	/* Read Device Controller Capability Parameters register */
 	dccparams = fsl_readl(&dr_regs->dccparams);
@@ -2295,7 +2468,12 @@ static int __init fsl_udc_probe(struct platform_device *pdev)
 	/* DEN is bidirectional ep number, max_ep doubles the number */
 	udc_controller->max_ep = (dccparams & DCCPARAMS_DEN_MASK) * 2;
 
+#ifdef CONFIG_USB_OTG
+	res++;
+	udc_controller->irq = res->start;
+#else
 	udc_controller->irq = platform_get_irq(pdev, 0);
+#endif
 	if (!udc_controller->irq) {
 		ret = -ENODEV;
 		goto err2;
@@ -2316,9 +2494,11 @@ static int __init fsl_udc_probe(struct platform_device *pdev)
 		goto err3;
 	}
 
-	/* initialize usb hw reg except for regs for EP,
-	 * leave usbintr reg untouched */
-	dr_controller_setup(udc_controller);
+	if (!udc_controller->transceiver) {
+		/* initialize usb hw reg except for regs for EP,
+		 * leave usbintr reg untouched */
+		dr_controller_setup(udc_controller);
+	}
 
 	/* Setup gadget structure */
 	udc_controller->gadget.ops = &fsl_gadget_ops;
@@ -2336,6 +2516,9 @@ static int __init fsl_udc_probe(struct platform_device *pdev)
 	if (ret < 0)
 		goto err3;
 
+	if (udc_controller->transceiver)
+		udc_controller->gadget.is_otg = 1;
+
 	/* setup QH and epctrl for ep0 */
 	ep0_setup(udc_controller);
 
@@ -2374,10 +2557,16 @@ err4:
 err3:
 	free_irq(udc_controller->irq, udc_controller);
 err2:
-	iounmap(dr_regs);
+	if (pdata->platform_uninit)
+		pdata->platform_uninit(pdata);
+err2a:
+	iounmap((void *)dr_regs);
 err1:
-	release_mem_region(res->start, res->end - res->start + 1);
+	if (!udc_controller->transceiver)
+		release_mem_region(res->start, res->end - res->start + 1);
+err1a:
 	kfree(udc_controller);
+	udc_controller = NULL;
 	return ret;
 }
 
@@ -2386,7 +2575,8 @@ err1:
  */
 static int __exit fsl_udc_remove(struct platform_device *pdev)
 {
-	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	struct resource __attribute((unused)) *res;
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
 
 	DECLARE_COMPLETION(done);
 
@@ -2404,13 +2594,59 @@ static int __exit fsl_udc_remove(struct platform_device *pdev)
 
 	dma_pool_destroy(udc_controller->td_pool);
 	free_irq(udc_controller->irq, udc_controller);
-	iounmap(dr_regs);
+	iounmap((void *)dr_regs);
+
+#ifndef CONFIG_USB_OTG
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	release_mem_region(res->start, res->end - res->start + 1);
+#endif
 
 	device_unregister(&udc_controller->gadget.dev);
 	/* free udc --wait for the release() finished */
 	wait_for_completion(&done);
 
+	/*
+	 * do platform specific un-initialization:
+	 * release iomux pins, etc.
+	 */
+	if (pdata->platform_uninit)
+		pdata->platform_uninit(pdata);
+
+	return 0;
+}
+
+static int udc_suspend(struct fsl_udc *udc)
+{
+	u32 mode, usbcmd;
+
+	mode = fsl_readl(&dr_regs->usbmode) & USB_MODE_CTRL_MODE_MASK;
+	usbcmd = fsl_readl(&dr_regs->usbcmd);
+
+	pr_debug("%s(): mode 0x%x stopped %d\n", __func__, mode, udc->stopped);
+
+	/*
+	 * If the controller is already stopped, then this must be a
+	 * PM suspend.  Remember this fact, so that we will leave the
+	 * controller stopped at PM resume time.
+	 */
+	if (udc->stopped) {
+		pr_debug("gadget already stopped, leaving early\n");
+		udc->already_stopped = 1;
+		return 0;
+	}
+
+	if (mode != USB_MODE_CTRL_MODE_DEVICE) {
+		pr_debug("gadget not in device mode, leaving early\n");
+		return 0;
+	}
+
+	printk(KERN_INFO "USB Gadget suspended\n");
+
+	/* stop the controller */
+	usbcmd = fsl_readl(&dr_regs->usbcmd) & ~USB_CMD_RUN_STOP;
+	fsl_writel(usbcmd, &dr_regs->usbcmd);
+
+	udc->stopped = 1;
 	return 0;
 }
 
@@ -2418,18 +2654,30 @@ static int __exit fsl_udc_remove(struct platform_device *pdev)
  * Modify Power management attributes
  * Used by OTG statemachine to disable gadget temporarily
  -----------------------------------------------------------------*/
-static int fsl_udc_suspend(struct platform_device *pdev, pm_message_t state)
+static int fsl_udc_suspend(struct device *dev, pm_message_t state)
 {
-	dr_controller_stop(udc_controller);
-	return 0;
+	return udc_suspend(udc_controller);
 }
 
 /*-----------------------------------------------------------------
  * Invoked on USB resume. May be called in_interrupt.
  * Here we start the DR controller and enable the irq
  *-----------------------------------------------------------------*/
-static int fsl_udc_resume(struct platform_device *pdev)
+static int fsl_udc_resume(struct device *dev)
 {
+	pr_debug("%s(): stopped %d  already_stopped %d\n", __func__,
+		 udc_controller->stopped, udc_controller->already_stopped);
+
+	/*
+	 * If the controller was stopped at suspend time, then
+	 * don't resume it now.
+	 */
+	if (udc_controller->already_stopped) {
+		udc_controller->already_stopped = 0;
+		pr_debug("gadget was already stopped, leaving early\n");
+		return 0;
+	}
+
 	/* Enable DR irq reg and set controller Run */
 	if (udc_controller->stopped) {
 		dr_controller_setup(udc_controller);
@@ -2438,6 +2686,8 @@ static int fsl_udc_resume(struct platform_device *pdev)
 	udc_controller->usb_state = USB_STATE_ATTACHED;
 	udc_controller->ep0_state = WAIT_FOR_SETUP;
 	udc_controller->ep0_dir = 0;
+
+	printk(KERN_INFO "USB Gadget resumed\n");
 	return 0;
 }
 
@@ -2450,8 +2700,9 @@ static struct platform_driver udc_driver = {
 	/* these suspend and resume are not usb suspend and resume */
 	.suspend = fsl_udc_suspend,
 	.resume  = fsl_udc_resume,
+	.probe = fsl_udc_probe,
 	.driver  = {
-		.name = (char *)driver_name,
+		.name = driver_name,
 		.owner = THIS_MODULE,
 	},
 };
@@ -2459,7 +2710,7 @@ static struct platform_driver udc_driver = {
 static int __init udc_init(void)
 {
 	printk(KERN_INFO "%s (%s)\n", driver_desc, DRIVER_VERSION);
-	return platform_driver_probe(&udc_driver, fsl_udc_probe);
+	return platform_driver_register(&udc_driver);
 }
 
 module_init(udc_init);
@@ -2467,7 +2718,7 @@ module_init(udc_init);
 static void __exit udc_exit(void)
 {
 	platform_driver_unregister(&udc_driver);
-	printk("%s unregistered \n", driver_desc);
+	printk(KERN_INFO "%s unregistered \n", driver_desc);
 }
 
 module_exit(udc_exit);
@@ -2475,4 +2726,3 @@ module_exit(udc_exit);
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:fsl-usb2-udc");
diff --git a/drivers/usb/gadget/fsl_usb2_udc.h b/drivers/usb/gadget/fsl_usb2_udc.h
index ceddbbc..0357b3a 100644
--- a/drivers/usb/gadget/fsl_usb2_udc.h
+++ b/drivers/usb/gadget/fsl_usb2_udc.h
@@ -8,6 +8,8 @@
  */
 #define USB_MAX_CTRL_PAYLOAD		64
 #define USB_DR_SYS_OFFSET		0x400
+#define USBGENCTRL_OFFSET		0x200
+#define ISIPHYCTRL_OFFSET		0x204
 
  /* USB DR device mode registers (Little Endian) */
 struct usb_dr_device {
@@ -83,6 +85,16 @@ struct usb_dr_host {
 	u32 endptctrl[6];	/* Endpoint Control Registers */
 };
 
+ /* non-EHCI USB system interface registers (Big Endian) */
+struct usb_sys_interface {
+	u32 snoop1;
+	u32 snoop2;
+	u32 age_cnt_thresh;	/* Age Count Threshold Register */
+	u32 pri_ctrl;		/* Priority Control Register */
+	u32 si_ctrl;		/* System Interface Control Register */
+	u8 res[236];
+	u32 control;		/* General Purpose Control Register */
+};
 
 /* ep0 transfer state */
 #define WAIT_FOR_SETUP          0
@@ -91,6 +103,10 @@ struct usb_dr_host {
 #define WAIT_FOR_OUT_STATUS     3
 #define DATA_STATE_RECV         4
 
+/* Device Controller Capability Parameter register */
+#define DCCPARAMS_DC				0x00000080
+#define DCCPARAMS_DEN_MASK			0x0000001f
+
 /* Frame Index Register Bit Masks */
 #define	USB_FRINDEX_MASKS			0x3fff
 /* USB CMD  Register Bit Masks */
@@ -166,6 +182,174 @@ struct usb_dr_host {
 /* endpoint list address bit masks */
 #define USB_EP_LIST_ADDRESS_MASK              0xfffff800
 
+/* PORTSCX  Register Bit Masks */
+#define  PORTSCX_CURRENT_CONNECT_STATUS       0x00000001
+#define  PORTSCX_CONNECT_STATUS_CHANGE        0x00000002
+#define  PORTSCX_PORT_ENABLE                  0x00000004
+#define  PORTSCX_PORT_EN_DIS_CHANGE           0x00000008
+#define  PORTSCX_OVER_CURRENT_ACT             0x00000010
+#define  PORTSCX_OVER_CURRENT_CHG             0x00000020
+#define  PORTSCX_PORT_FORCE_RESUME            0x00000040
+#define  PORTSCX_PORT_SUSPEND                 0x00000080
+#define  PORTSCX_PORT_RESET                   0x00000100
+#define  PORTSCX_LINE_STATUS_BITS             0x00000C00
+#define  PORTSCX_PORT_POWER                   0x00001000
+#define  PORTSCX_PORT_INDICTOR_CTRL           0x0000C000
+#define  PORTSCX_PORT_TEST_CTRL               0x000F0000
+#define  PORTSCX_WAKE_ON_CONNECT_EN           0x00100000
+#define  PORTSCX_WAKE_ON_CONNECT_DIS          0x00200000
+#define  PORTSCX_WAKE_ON_OVER_CURRENT         0x00400000
+#define  PORTSCX_PHY_LOW_POWER_SPD            0x00800000
+#define  PORTSCX_PORT_FORCE_FULL_SPEED        0x01000000
+#define  PORTSCX_PORT_SPEED_MASK              0x0C000000
+#define  PORTSCX_PORT_WIDTH                   0x10000000
+#define  PORTSCX_PHY_TYPE_SEL                 0xC0000000
+
+/* bit 11-10 are line status */
+#define  PORTSCX_LINE_STATUS_SE0              0x00000000
+#define  PORTSCX_LINE_STATUS_JSTATE           0x00000400
+#define  PORTSCX_LINE_STATUS_KSTATE           0x00000800
+#define  PORTSCX_LINE_STATUS_UNDEF            0x00000C00
+#define  PORTSCX_LINE_STATUS_BIT_POS          10
+
+/* bit 15-14 are port indicator control */
+#define  PORTSCX_PIC_OFF                      0x00000000
+#define  PORTSCX_PIC_AMBER                    0x00004000
+#define  PORTSCX_PIC_GREEN                    0x00008000
+#define  PORTSCX_PIC_UNDEF                    0x0000C000
+#define  PORTSCX_PIC_BIT_POS                  14
+
+/* bit 19-16 are port test control */
+#define  PORTSCX_PTC_DISABLE                  0x00000000
+#define  PORTSCX_PTC_JSTATE                   0x00010000
+#define  PORTSCX_PTC_KSTATE                   0x00020000
+#define  PORTSCX_PTC_SEQNAK                   0x00030000
+#define  PORTSCX_PTC_PACKET                   0x00040000
+#define  PORTSCX_PTC_FORCE_EN                 0x00050000
+#define  PORTSCX_PTC_BIT_POS                  16
+
+/* bit 27-26 are port speed */
+#define  PORTSCX_PORT_SPEED_FULL              0x00000000
+#define  PORTSCX_PORT_SPEED_LOW               0x04000000
+#define  PORTSCX_PORT_SPEED_HIGH              0x08000000
+#define  PORTSCX_PORT_SPEED_UNDEF             0x0C000000
+#define  PORTSCX_SPEED_BIT_POS                26
+
+/* bit 28 is parallel transceiver width for UTMI interface */
+#define  PORTSCX_PTW                          0x10000000
+#define  PORTSCX_PTW_8BIT                     0x00000000
+#define  PORTSCX_PTW_16BIT                    0x10000000
+
+/* bit 31-30 are port transceiver select */
+#define  PORTSCX_PTS_UTMI                     0x00000000
+#define  PORTSCX_PTS_ULPI                     0x80000000
+#define  PORTSCX_PTS_FSLS                     0xC0000000
+#define  PORTSCX_PTS_BIT_POS                  30
+
+/* otgsc Register Bit Masks */
+#define  OTGSC_CTRL_VUSB_DISCHARGE            0x00000001
+#define  OTGSC_CTRL_VUSB_CHARGE               0x00000002
+#define  OTGSC_CTRL_OTG_TERM                  0x00000008
+#define  OTGSC_CTRL_DATA_PULSING              0x00000010
+#define  OTGSC_STS_USB_ID                     0x00000100
+#define  OTGSC_STS_A_VBUS_VALID               0x00000200
+#define  OTGSC_STS_A_SESSION_VALID            0x00000400
+#define  OTGSC_STS_B_SESSION_VALID            0x00000800
+#define  OTGSC_STS_B_SESSION_END              0x00001000
+#define  OTGSC_STS_1MS_TOGGLE                 0x00002000
+#define  OTGSC_STS_DATA_PULSING               0x00004000
+#define  OTGSC_INTSTS_USB_ID                  0x00010000
+#define  OTGSC_INTSTS_A_VBUS_VALID            0x00020000
+#define  OTGSC_INTSTS_A_SESSION_VALID         0x00040000
+#define  OTGSC_INTSTS_B_SESSION_VALID         0x00080000
+#define  OTGSC_INTSTS_B_SESSION_END           0x00100000
+#define  OTGSC_INTSTS_1MS                     0x00200000
+#define  OTGSC_INTSTS_DATA_PULSING            0x00400000
+#define  OTGSC_INTR_USB_ID                    0x01000000
+#define  OTGSC_INTR_A_VBUS_VALID              0x02000000
+#define  OTGSC_INTR_A_SESSION_VALID           0x04000000
+#define  OTGSC_INTR_B_SESSION_VALID           0x08000000
+#define  OTGSC_INTR_B_SESSION_END             0x10000000
+#define  OTGSC_INTR_1MS_TIMER                 0x20000000
+#define  OTGSC_INTR_DATA_PULSING              0x40000000
+
+/* USB MODE Register Bit Masks */
+#define  USB_MODE_CTRL_MODE_IDLE              0x00000000
+#define  USB_MODE_CTRL_MODE_DEVICE            0x00000002
+#define  USB_MODE_CTRL_MODE_HOST              0x00000003
+#define  USB_MODE_CTRL_MODE_MASK              0x00000003
+#define  USB_MODE_CTRL_MODE_RSV               0x00000001
+#define  USB_MODE_ES                          0x00000004 /* (big) Endian Select */
+#define  USB_MODE_SETUP_LOCK_OFF              0x00000008
+#define  USB_MODE_STREAM_DISABLE              0x00000010
+/* Endpoint Flush Register */
+#define EPFLUSH_TX_OFFSET		      0x00010000
+#define EPFLUSH_RX_OFFSET		      0x00000000
+
+/* Endpoint Setup Status bit masks */
+#define  EP_SETUP_STATUS_MASK                 0x0000003F
+#define  EP_SETUP_STATUS_EP0		      0x00000001
+
+/* ENDPOINTCTRLx  Register Bit Masks */
+#define  EPCTRL_TX_ENABLE                     0x00800000
+#define  EPCTRL_TX_DATA_TOGGLE_RST            0x00400000	/* Not EP0 */
+#define  EPCTRL_TX_DATA_TOGGLE_INH            0x00200000	/* Not EP0 */
+#define  EPCTRL_TX_TYPE                       0x000C0000
+#define  EPCTRL_TX_DATA_SOURCE                0x00020000	/* Not EP0 */
+#define  EPCTRL_TX_EP_STALL                   0x00010000
+#define  EPCTRL_RX_ENABLE                     0x00000080
+#define  EPCTRL_RX_DATA_TOGGLE_RST            0x00000040	/* Not EP0 */
+#define  EPCTRL_RX_DATA_TOGGLE_INH            0x00000020	/* Not EP0 */
+#define  EPCTRL_RX_TYPE                       0x0000000C
+#define  EPCTRL_RX_DATA_SINK                  0x00000002	/* Not EP0 */
+#define  EPCTRL_RX_EP_STALL                   0x00000001
+
+/* bit 19-18 and 3-2 are endpoint type */
+#define  EPCTRL_EP_TYPE_CONTROL               0
+#define  EPCTRL_EP_TYPE_ISO                   1
+#define  EPCTRL_EP_TYPE_BULK                  2
+#define  EPCTRL_EP_TYPE_INTERRUPT             3
+#define  EPCTRL_TX_EP_TYPE_SHIFT              18
+#define  EPCTRL_RX_EP_TYPE_SHIFT              2
+
+/* SNOOPn Register Bit Masks */
+#define  SNOOP_ADDRESS_MASK                   0xFFFFF000
+#define  SNOOP_SIZE_ZERO                      0x00	/* snooping disable */
+#define  SNOOP_SIZE_4KB                       0x0B	/* 4KB snoop size */
+#define  SNOOP_SIZE_8KB                       0x0C
+#define  SNOOP_SIZE_16KB                      0x0D
+#define  SNOOP_SIZE_32KB                      0x0E
+#define  SNOOP_SIZE_64KB                      0x0F
+#define  SNOOP_SIZE_128KB                     0x10
+#define  SNOOP_SIZE_256KB                     0x11
+#define  SNOOP_SIZE_512KB                     0x12
+#define  SNOOP_SIZE_1MB                       0x13
+#define  SNOOP_SIZE_2MB                       0x14
+#define  SNOOP_SIZE_4MB                       0x15
+#define  SNOOP_SIZE_8MB                       0x16
+#define  SNOOP_SIZE_16MB                      0x17
+#define  SNOOP_SIZE_32MB                      0x18
+#define  SNOOP_SIZE_64MB                      0x19
+#define  SNOOP_SIZE_128MB                     0x1A
+#define  SNOOP_SIZE_256MB                     0x1B
+#define  SNOOP_SIZE_512MB                     0x1C
+#define  SNOOP_SIZE_1GB                       0x1D
+#define  SNOOP_SIZE_2GB                       0x1E	/* 2GB snoop size */
+
+/* pri_ctrl Register Bit Masks */
+#define  PRI_CTRL_PRI_LVL1                    0x0000000C
+#define  PRI_CTRL_PRI_LVL0                    0x00000003
+
+/* si_ctrl Register Bit Masks */
+#define  SI_CTRL_ERR_DISABLE                  0x00000010
+#define  SI_CTRL_IDRC_DISABLE                 0x00000008
+#define  SI_CTRL_RD_SAFE_EN                   0x00000004
+#define  SI_CTRL_RD_PREFETCH_DISABLE          0x00000002
+#define  SI_CTRL_RD_PREFEFETCH_VAL            0x00000001
+
+/* control Register Bit Masks */
+#define  USB_CTRL_IOENB                       0x00000004
+#define  USB_CTRL_ULPI_INT0EN                 0x00000001
 
 /* Endpoint Queue Head data struct
  * Rem: all the variables of qh are LittleEndian Mode
@@ -289,23 +473,21 @@ struct fsl_ep {
 #define EP_DIR_OUT	0
 
 struct fsl_udc {
-
 	struct usb_gadget gadget;
 	struct usb_gadget_driver *driver;
+	struct fsl_usb2_platform_data *pdata;
 	struct fsl_ep *eps;
 	unsigned int max_ep;
 	unsigned int irq;
 
 	struct usb_ctrlrequest local_setup_buff;
-	spinlock_t lock;		/* udc lock */
-	struct fsl_usb2_platform_data *pdata;
-	u32 xcvr_type;
-
+	spinlock_t lock;
 	struct otg_transceiver *transceiver;
 	unsigned softconnect:1;
 	unsigned vbus_active:1;
 	unsigned stopped:1;
 	unsigned remote_wakeup:1;
+	unsigned already_stopped:1;
 
 	struct ep_queue_head *ep_qh;	/* Endpoints Queue-Head */
 	struct fsl_req *status_req;	/* ep0 status request */
@@ -374,9 +556,9 @@ static void dump_msg(const char *label, const u8 * buf, unsigned int length)
 #define VDBG(stuff...)	do {} while (0)
 #endif
 
-#define ERR(stuff...)		pr_err("udc: " stuff)
-#define WARN(stuff...)		pr_warning("udc: " stuff)
-#define INFO(stuff...)		pr_info("udc: " stuff)
+#define ERR(stuff...)		printk(KERN_ERR "udc: " stuff)
+#define WARN(stuff...)		printk(KERN_WARNING "udc: " stuff)
+#define INFO(stuff...)		printk(KERN_INFO "udc: " stuff)
 
 /*-------------------------------------------------------------------------*/
 
@@ -386,8 +568,8 @@ static void dump_msg(const char *label, const u8 * buf, unsigned int length)
 /*
  * ### pipe direction macro from device view
  */
-#define USB_RECV	0	/* OUT EP */
-#define USB_SEND	1	/* IN EP */
+#define USB_RECV	(0)	/* OUT EP */
+#define USB_SEND	(1)	/* IN EP */
 
 /*
  * ### internal used help routines.
@@ -396,14 +578,22 @@ static void dump_msg(const char *label, const u8 * buf, unsigned int length)
 #define ep_maxpacket(EP)	((EP)->ep.maxpacket)
 #define ep_is_in(EP)	( (ep_index(EP) == 0) ? (EP->udc->ep0_dir == \
 			USB_DIR_IN ):((EP)->desc->bEndpointAddress \
-			& USB_DIR_IN) == USB_DIR_IN)
+			& USB_DIR_IN)==USB_DIR_IN)
 #define get_ep_by_pipe(udc, pipe)	((pipe == 1)? &udc->eps[0]: \
 					&udc->eps[pipe])
 #define get_pipe_by_windex(windex)	((windex & USB_ENDPOINT_NUMBER_MASK) \
 					* 2 + ((windex & USB_DIR_IN) ? 1 : 0))
 #define get_pipe_by_ep(EP)	(ep_index(EP) * 2 + ep_is_in(EP))
 
-/* Bulk only class request */
-#define USB_BULK_RESET_REQUEST          0xff
+#ifdef CONFIG_ARCH_MXC
+#include <asm/arch/fsl_usb_gadget.h>
+#elif CONFIG_PPC32
+#include <asm/fsl_usb_io.h>
+#include <asm/fsl_usb_gadget.h>
+#elif CONFIG_COLDFIRE
+#include <asm/mcfsim.h>
+#include <asm/fsl_usb_io.h>
+#include <asm/fsl_usb_gadget.h>
+#endif
 
 #endif
diff --git a/drivers/usb/gadget/gadget_chips.h b/drivers/usb/gadget/gadget_chips.h
index 1682705..a5df86c 100644
--- a/drivers/usb/gadget/gadget_chips.h
+++ b/drivers/usb/gadget/gadget_chips.h
@@ -147,11 +147,13 @@
 #define	gadget_is_m66592(g)	0
 #endif
 
+#if 0 // DDD
 #ifdef CONFIG_USB_GADGET_MCF5445X
 #define gadget_is_mcf5445x(g)	!strcmp("fsl-usb2-udc", (g)->name)
 #else
 #define gadget_is_mcf5445x(g)	0
 #endif
+#endif
 
 // CONFIG_USB_GADGET_SX2
 // CONFIG_USB_GADGET_AU1X00
@@ -217,7 +219,9 @@ static inline int usb_gadget_controller_number(struct usb_gadget *gadget)
 		return 0x20;
 	else if (gadget_is_m66592(gadget))
 		return 0x21;
+#if 0 // DDD
 	else if (gadget_is_mcf5445x(gadget))
 		return 0x22;
+#endif
 	return -ENOENT;
 }
diff --git a/drivers/usb/gadget/mcf5445x_udc.c b/drivers/usb/gadget/mcf5445x_udc.c
index 7c7b100..5b55380 100644
--- a/drivers/usb/gadget/mcf5445x_udc.c
+++ b/drivers/usb/gadget/mcf5445x_udc.c
@@ -1,37 +1,25 @@
 /*
- * Copyright Freescale Semiconductor, Inc. 2006-2007
+ * Copyright (C) 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
  *
- *      Based on mpc_udc.c code
- *      of Li Yang and Jiang Bo (Freescale Semiconductor, Inc.)
+ * Author: Li Yang <leoli@freescale.com>
+ *         Jiang Bo <tanya.jiang@freescale.com>
  *
+ * Description:
+ * Freescale high-speed USB SOC DR module device controller driver.
+ * This can be found on MPC8349E/MPC8313E cpus.
+ * The driver is previously named as mpc_udc.  Based on bare board
+ * code from Dave Liu and Shlomi Gridish.
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- ***************************************************************************
- * Changes:
- *   v0.004	30 July 2007		Duck
- *   		mcf5445x port
- *   v0.003	27 October 2006		Andrey Butok
- *		Added M5329EVB support (without external transceiver).
- *   v0.002	29 September 2006	Andrey Butok
- *		Some little changes. Added OTG support.
- *   v0.001	12 July 2006		Andrey Butok
- *   		Initial Release - developed on uClinux with 2.6.17.1 kernel.
- *   		Based on mpc_udc.c code
- *   		of Li Yang and Jiang Bo (Freescale Semiconductor, Inc.)
- *
  */
 
 #undef DEBUG
@@ -46,51 +34,41 @@
 #include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/init.h>
-#include <linux/io.h>
-#include <linux/irq.h>
 #include <linux/timer.h>
 #include <linux/list.h>
 #include <linux/interrupt.h>
 #include <linux/proc_fs.h>
 #include <linux/mm.h>
-#include <linux/platform_device.h>
 #include <linux/moduleparam.h>
 #include <linux/device.h>
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
 #include <linux/usb/otg.h>
 #include <linux/dma-mapping.h>
-#include <linux/dmapool.h>
+#include <linux/platform_device.h>
 #include <linux/fsl_devices.h>
-#include <linux/usb/fsl_xcvr.h>
-#include <linux/usb/fsl_usb2.h>
-#include <linux/pm.h>
+#include <linux/dmapool.h>
 
 #include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/irq.h>
 #include <asm/system.h>
 #include <asm/unaligned.h>
 #include <asm/dma.h>
-
-#include <asm/mcfsim.h>
 #include <asm/cacheflush.h>
 
 #include "fsl_usb2_udc.h"
 
-#define	DRIVER_DESC	"Freescale High-Speed USB SoC Device Controller driver"
-#define	DRIVER_AUTHOR	"Freescale Semiconductor Inc."
-#define	DRIVER_VERSION	"30 July 2007"
-
-#define cpu_to_hc32(x)	(x)
-#define hc32_to_cpu(x)	(x)
-
-static int udc_suspend(struct fsl_udc *udc);
+#define	DRIVER_DESC	"Freescale High-Speed USB SOC Device Controller driver"
+#define	DRIVER_AUTHOR	"Li Yang/Jiang Bo"
+#define	DRIVER_VERSION	"Apr 20, 2007"
 
 #define	DMA_ADDR_INVALID	(~(dma_addr_t)0)
 
 static const char driver_name[] = "fsl-usb2-udc";
 static const char driver_desc[] = DRIVER_DESC;
 
-volatile static struct fsl_usb_device_regs *dr_regs;
+volatile static struct usb_dr_device *dr_regs;
 volatile static struct usb_sys_interface *usb_sys_regs;
 
 /* it is initialized in probe()  */
@@ -105,13 +83,57 @@ fsl_ep0_desc = {
 	.wMaxPacketSize =	USB_MAX_CTRL_PAYLOAD,
 };
 
+static int udc_suspend(struct fsl_udc *udc);
 static int fsl_udc_suspend(struct device *dev, pm_message_t state);
 static int fsl_udc_resume(struct device *dev);
 static void fsl_ep_fifo_flush(struct usb_ep *_ep);
 
+#ifdef CONFIG_USB_OTG
+/* Get platform resource from OTG driver */
+extern struct resource *otg_get_resources(void);
+#endif
+
+
 /********************************************************************
  *	Internal Used Function
 ********************************************************************/
+
+#ifdef DUMP_QUEUES
+static void dump_ep_queue(struct fsl_ep *ep)
+{
+	int ep_index;
+	struct fsl_req *req;
+	struct ep_td_struct *dtd;
+
+	if (list_empty(&ep->queue)) {
+		pr_debug("udc: empty\n");
+		return;
+	}
+
+	ep_index = ep_index(ep) * 2 + ep_is_in(ep);
+	pr_debug("udc: ep=0x%p  index=%d\n", ep, ep_index);
+
+	list_for_each_entry(req, &ep->queue, queue) {
+		pr_debug("udc: req=0x%p  dTD count=%d\n", req, req->dtd_count);
+		pr_debug("udc: dTD head=0x%p  tail=0x%p\n", req->head,
+			 req->tail);
+
+		dtd = req->head;
+
+		while (dtd) {
+			if (le32_to_cpu(dtd->next_td_ptr) & DTD_NEXT_TERMINATE)
+				break;	/* end of dTD list */
+
+			dtd = dtd->next_td_virt;
+		}
+	}
+}
+#else
+static inline void dump_ep_queue(struct fsl_ep *ep)
+{
+}
+#endif
+
 /*-----------------------------------------------------------------
  * done() - retire a request; caller blocked irqs
  * @status : request status to be set, only works when
@@ -121,19 +143,11 @@ static void done(struct fsl_ep *ep, struct fsl_req *req, int status)
 {
 	struct fsl_udc *udc = NULL;
 	unsigned char stopped = ep->stopped;
+	struct ep_td_struct *curr_td, *next_td;
+	int j;
 
 	udc = (struct fsl_udc *)ep->udc;
-
-	pr_debug("udc: req=0x%p\n", req);
-	if (req->head) {
-		pr_debug("udc: freeing head=0x%p\n", req->head);
-		dma_pool_free(udc->td_pool, req->head, req->head->td_dma);
-	}
-
-	/* the req->queue pointer is used by ep_queue() func, in which
-	 * the request will be added into a udc_ep->queue 'd tail
-	 * so here the req will be dropped from the ep->queue
-	 */
+	/* Removed the req from fsl_ep->queue */
 	list_del_init(&req->queue);
 
 	/* req.status should be set as -EINPROGRESS in ep_queue() */
@@ -142,60 +156,49 @@ static void done(struct fsl_ep *ep, struct fsl_req *req, int status)
 	else
 		status = req->req.status;
 
-	pr_debug("udc: req=0x%p  mapped=%x\n", req, req->mapped);
+	/* Free dtd for the request */
+	next_td = req->head;
+	for (j = 0; j < req->dtd_count; j++) {
+		curr_td = next_td;
+		if (j != req->dtd_count - 1) {
+			next_td = curr_td->next_td_virt;
+		}
+		dma_pool_free(udc->td_pool, curr_td, curr_td->td_dma);
+	}
 
 	if (req->mapped) {
-		pr_debug("udc: calling dma_unmap_single(buf,%s)  req=0x%p  "
-			 "a=0x%x  len=%d\n",
-			 ep_is_in(ep) ? "to_dvc" : "from_dvc",
-			 req, req->req.dma, req->req.length);
-
 		dma_unmap_single(ep->udc->gadget.dev.parent,
-				 req->req.dma, req->req.length, ep_is_in(ep) ?
-				 DMA_TO_DEVICE : DMA_FROM_DEVICE);
-
+			req->req.dma, req->req.length,
+			ep_is_in(ep)
+				? DMA_TO_DEVICE
+				: DMA_FROM_DEVICE);
 		req->req.dma = DMA_ADDR_INVALID;
 		req->mapped = 0;
-		pr_debug("udc: req=0x%p set req.dma=0x%x\n", req, req->req.dma);
-	} else {
-		if ((req->req.length != 0)
-		    && (req->req.dma != DMA_ADDR_INVALID)) {
-			pr_debug("udc: calling dma_sync_single_for_cpu(buf,%s) "
-				 "req=0x%p  dma=0x%x  len=%d\n",
-				 ep_is_in(ep) ? "to_dvc" : "from_dvc", req,
-				 req->req.dma, req->req.length);
-
-			dma_sync_single_for_cpu(ep->udc->gadget.dev.parent,
-						req->req.dma, req->req.length,
-						ep_is_in(ep) ? DMA_TO_DEVICE :
-						DMA_FROM_DEVICE);
-		}
-	}
+	} else
+		dma_sync_single_for_cpu(ep->udc->gadget.dev.parent,
+			req->req.dma, req->req.length,
+			ep_is_in(ep)
+				? DMA_TO_DEVICE
+				: DMA_FROM_DEVICE);
+
+	if (status && (status != -ESHUTDOWN))
+		VDBG("complete %s req %p stat %d len %u/%u",
+			ep->ep.name, &req->req, status,
+			req->req.actual, req->req.length);
 
-	if (status && (status != -ESHUTDOWN)) {
-		pr_debug("udc: complete %s req 0c%p stat %d len %u/%u\n",
-			 ep->ep.name, &req->req, status,
-			 req->req.actual, req->req.length);
-	}
-
-	/* don't modify queue heads during completion callback */
 	ep->stopped = 1;
 
 	spin_unlock(&ep->udc->lock);
-
-	/* this complete() should a func implemented by gadget layer,
+	/* complete() is from gadget layer,
 	 * eg fsg->bulk_in_complete() */
-	if (req->req.complete) {
-		pr_debug("udc: calling gadget's complete()  req=0x%p\n", req);
+	if (req->req.complete)
 		req->req.complete(&ep->ep, &req->req);
-		pr_debug("udc: back from gadget's complete()\n");
-	}
 
 	spin_lock(&ep->udc->lock);
 	ep->stopped = stopped;
 }
 
-/*
+/*-----------------------------------------------------------------
  * nuke(): delete all requests related to this ep
  * called with spinlock held
  *--------------------------------------------------------------*/
@@ -213,6 +216,7 @@ static void nuke(struct fsl_ep *ep, int status)
 		req = list_entry(ep->queue.next, struct fsl_req, queue);
 		done(ep, req, status);
 	}
+	dump_ep_queue(ep);
 }
 
 /*------------------------------------------------------------------
@@ -221,7 +225,7 @@ static void nuke(struct fsl_ep *ep, int status)
 
 static int dr_controller_setup(struct fsl_udc *udc)
 {
-	unsigned int tmp;
+	unsigned int tmp = 0, portctrl = 0;
 	unsigned int __attribute((unused)) ctrl = 0;
 	unsigned long timeout;
 	struct fsl_usb2_platform_data *pdata;
@@ -252,17 +256,17 @@ static int dr_controller_setup(struct fsl_udc *udc)
 		cpu_relax();
 	}
 
+	/* Set the controller as device mode */
 	tmp = fsl_readl(&dr_regs->usbmode);
-	tmp &= ~0x3;	/* clear mode bits */
+	tmp &= ~USB_MODE_CTRL_MODE_MASK;	/* clear mode bits */
 	tmp |= USB_MODE_CTRL_MODE_DEVICE;
 	/* Disable Setup Lockout */
 	tmp |= USB_MODE_SETUP_LOCK_OFF;
 	if (pdata->es)
-		tmp |= USBMODE_ES;
+		tmp |= USB_MODE_ES;
 	fsl_writel(tmp, &dr_regs->usbmode);
 
-	if (pdata->xcvr_ops && pdata->xcvr_ops->set_device)
-		pdata->xcvr_ops->set_device();
+	fsl_platform_set_device_mode(pdata);
 
 	/* Clear the setup status */
 	fsl_writel(0, &dr_regs->usbsts);
@@ -271,19 +275,30 @@ static int dr_controller_setup(struct fsl_udc *udc)
 	tmp &= USB_EP_LIST_ADDRESS_MASK;
 	fsl_writel(tmp, &dr_regs->endpointlistaddr);
 
-	/*
 	VDBG("vir[qh_base] is %p phy[qh_base] is 0x%8x reg is 0x%8x",
 		(int)udc->ep_qh, (int)tmp,
 		fsl_readl(&dr_regs->endpointlistaddr));
-	*/
-
 
-	if (pdata->have_sysif_regs) {
-		/* Config control enable i/o output, cpu endian register */
-		ctrl = __raw_readl(&usb_sys_regs->control);
-		ctrl |= USB_CTRL_IOENB;
-		__raw_writel(ctrl, &usb_sys_regs->control);
+	/* Config PHY interface */
+	portctrl = fsl_readl(&dr_regs->portsc1);
+	portctrl &= ~(PORTSCX_PHY_TYPE_SEL | PORTSCX_PORT_WIDTH);
+	switch (udc->phy_mode) {
+	case FSL_USB2_PHY_ULPI:
+		portctrl |= PORTSCX_PTS_ULPI;
+		break;
+	case FSL_USB2_PHY_UTMI_WIDE:
+		portctrl |= PORTSCX_PTW_16BIT;
+		/* fall through */
+	case FSL_USB2_PHY_UTMI:
+		portctrl |= PORTSCX_PTS_UTMI;
+		break;
+	case FSL_USB2_PHY_SERIAL:
+		portctrl |= PORTSCX_PTS_FSLS;
+		break;
+	default:
+		return -EINVAL;
 	}
+	fsl_writel(portctrl, &dr_regs->portsc1);
 
 #if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
 	/* Turn on cache snooping hardware, since some PowerPC platforms
@@ -301,14 +316,12 @@ static int dr_controller_setup(struct fsl_udc *udc)
 	return 0;
 }
 
-static void pullup_enable(struct fsl_udc *udc)
+/* Enable DR irq and set controller to run state */
+static void dr_controller_run(struct fsl_udc *udc)
 {
 	u32 temp;
 
-	unsigned short ccm = fsl_readw(&MCF_CCM_UOCSR);
-	ccm |= MCF_CCM_UOCSR_BVLD;
-	ccm &= ~MCF_CCM_UOCSR_SEND;
-	fsl_writew(ccm, &MCF_CCM_UOCSR);
+	fsl_platform_pullup_enable(udc->pdata);
 
 	/* Enable DR irq reg */
 	temp = USB_INTR_INT_EN | USB_INTR_ERR_INT_EN
@@ -317,45 +330,51 @@ static void pullup_enable(struct fsl_udc *udc)
 
 	fsl_writel(temp, &dr_regs->usbintr);
 
+	/* Clear stopped bit */
+	udc->stopped = 0;
+
 	/* Set controller to Run */
 	temp = fsl_readl(&dr_regs->usbcmd);
 	temp |= USB_CMD_RUN_STOP;
 	fsl_writel(temp, &dr_regs->usbcmd);
+
+	return;
 }
 
-static void pullup_disable(struct fsl_udc *udc)
+static void dr_controller_stop(struct fsl_udc *udc)
 {
 	unsigned int tmp;
-	unsigned short ccm;
 
-	VDBG();
-	/* disable all INTRs */
+	pr_debug("%s\n", __FUNCTION__);
+
+	/* if we're in OTG mode, and the Host is currently using the port,
+	 * stop now and don't rip the controller out from under the
+	 * ehci driver
+	 */
+	if (udc->gadget.is_otg) {
+		if (!(fsl_readl(&dr_regs->otgsc) & OTGSC_STS_USB_ID)) {
+			pr_debug("udc: Leaving early\n");
+			return;
+		}
+	}
+
+	/* disable all INTR */
 	fsl_writel(0, &dr_regs->usbintr);
 
-	ccm = fsl_readw(&MCF_CCM_UOCSR);
-	ccm &= ~MCF_CCM_UOCSR_BVLD;
-	fsl_writew(ccm, &MCF_CCM_UOCSR);
+	/* Set stopped bit for isr */
+	udc->stopped = 1;
+
+	/* disable IO output */
+/*	usb_sys_regs->control = 0; */
+
+	fsl_platform_pullup_disable(udc->pdata);
 
 	/* set controller to Stop */
 	tmp = fsl_readl(&dr_regs->usbcmd);
 	tmp &= ~USB_CMD_RUN_STOP;
 	fsl_writel(tmp, &dr_regs->usbcmd);
-}
-
-static void dr_controller_run(struct fsl_udc *udc)
-{
-	VDBG();
-	pullup_enable(udc);
-	udc->stopped = 0;
-}
 
-static void dr_controller_stop(struct fsl_udc *udc)
-{
-	pullup_disable(udc);
-	udc->stopped = 1;
-	udc->gadget.b_hnp_enable = 0;
-	udc->gadget.a_hnp_support = 0;
-	udc->gadget.a_alt_hnp_support = 0;
+	return;
 }
 
 void dr_ep_setup(unsigned char ep_num, unsigned char dir, unsigned char ep_type)
@@ -380,8 +399,8 @@ void dr_ep_setup(unsigned char ep_num, unsigned char dir, unsigned char ep_type)
 	fsl_writel(tmp_epctrl, &dr_regs->endptctrl[ep_num]);
 }
 
-static void dr_ep_change_stall(unsigned char ep_num, unsigned char dir,
-			       int value)
+static void
+dr_ep_change_stall(unsigned char ep_num, unsigned char dir, int value)
 {
 	u32 tmp_epctrl = 0;
 
@@ -587,7 +606,7 @@ static int fsl_ep_disable(struct usb_ep *_ep)
 
 	ep = container_of(_ep, struct fsl_ep, ep);
 	if (!_ep || !ep->desc) {
-		pr_debug("udc: %s not enabled\n", _ep ? ep->ep.name : NULL);
+		VDBG("%s not enabled", _ep ? ep->ep.name : NULL);
 		return -EINVAL;
 	}
 
@@ -610,7 +629,7 @@ static int fsl_ep_disable(struct usb_ep *_ep)
 	ep->stopped = 1;
 	spin_unlock_irqrestore(&udc->lock, flags);
 
-	pr_debug("udc: disabled %s OK\n", _ep->name);
+	VDBG("disabled %s OK", _ep->name);
 	return 0;
 }
 
@@ -629,7 +648,6 @@ fsl_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)
 		return NULL;
 
 	req->req.dma = DMA_ADDR_INVALID;
-	pr_debug("udc: req=0x%p   set req.dma=0x%x\n", req, req->req.dma);
 	INIT_LIST_HEAD(&req->queue);
 
 	return &req->req;
@@ -637,10 +655,9 @@ fsl_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)
 
 static void fsl_free_request(struct usb_ep *_ep, struct usb_request *_req)
 {
-	struct fsl_req *req;
+	struct fsl_req *req = NULL;
 
 	req = container_of(_req, struct fsl_req, req);
-	pr_debug("udc: req=0x%p\n", req);
 
 	if (_req)
 		kfree(req);
@@ -653,7 +670,8 @@ static int fsl_queue_td(struct fsl_ep *ep, struct fsl_req *req)
 	u32 temp, bitmask, tmp_stat;
 	struct ep_queue_head *dQH = &ep->udc->ep_qh[i];
 
-	pr_debug("udc: queue req=0x%p to ep index %d\n", req, i);
+	/* VDBG("QH addr Register 0x%8x", dr_regs->endpointlistaddr);
+	VDBG("ep_qh[%d] addr is 0x%8x", i, (u32)&(ep->udc->ep_qh[i])); */
 
 	bitmask = ep_is_in(ep)
 		? (1 << (ep_index(ep) + 16))
@@ -789,7 +807,7 @@ static int fsl_req_to_dtd(struct fsl_req *req)
 			is_first = 0;
 			req->head = dtd;
 		} else {
-			last_dtd->next_td_ptr = hc32_to_cpu(dma);
+			last_dtd->next_td_ptr = cpu_to_hc32(dma);
 			last_dtd->next_td_virt = dtd;
 		}
 		last_dtd = dtd;
@@ -820,7 +838,7 @@ fsl_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 		VDBG("%s, bad params\n", __FUNCTION__);
 		return -EINVAL;
 	}
-	if (!_ep || (!ep->desc && ep_index(ep))) {
+	if (unlikely(!_ep || !ep->desc)) {
 		VDBG("%s, bad ep\n", __FUNCTION__);
 		return -EINVAL;
 	}
@@ -844,6 +862,18 @@ fsl_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 						? DMA_TO_DEVICE
 						: DMA_FROM_DEVICE);
 		req->mapped = 1;
+		if (0) {	// DDD RS debug
+			u32 *buf = req->req.buf;
+			u32 *dma = (u32 *)req->req.dma;
+			int len = (int)req->req.length;
+
+			printk("did map_single.  buf %p  dma %p  len %d\n",
+				buf, dma, len);
+			if (len) {
+				//printk("*buf %08x   *dma %08x\n", *buf, *dma);
+				printk("*buf %08x %08x \n", *buf, *(buf+1));
+			}
+		}
 	} else {
 		dma_sync_single_for_device(ep->udc->gadget.dev.parent,
 					req->req.dma, req->req.length,
@@ -1010,6 +1040,36 @@ out:
 	return status;
 }
 
+static int arcotg_fifo_status(struct usb_ep *_ep)
+{
+	struct fsl_ep *ep;
+	struct fsl_udc *udc;
+	int size = 0;
+	u32 bitmask;
+	struct ep_queue_head *d_qh;
+
+	ep = container_of(_ep, struct fsl_ep, ep);
+	if (!_ep || (!ep->desc && ep_index(ep) != 0))
+		return -ENODEV;
+
+	udc = (struct fsl_udc *)ep->udc;
+
+	if (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)
+		return -ESHUTDOWN;
+
+	d_qh = &ep->udc->ep_qh[ep_index(ep) * 2 + ep_is_in(ep)];
+
+	bitmask = (ep_is_in(ep)) ? (1 << (ep_index(ep) + 16)) :
+	    (1 << (ep_index(ep)));
+
+	if (fsl_readl(&dr_regs->endptstatus) & bitmask)
+		size = (d_qh->size_ioc_int_sts & DTD_PACKET_SIZE)
+		    >> DTD_LENGTH_BIT_POS;
+
+	pr_debug("%s %u\n", __FUNCTION__, size);
+	return size;
+}
+
 static void fsl_ep_fifo_flush(struct usb_ep *_ep)
 {
 	struct fsl_ep *ep;
@@ -1062,6 +1122,7 @@ static struct usb_ep_ops fsl_ep_ops = {
 	.dequeue = fsl_ep_dequeue,
 
 	.set_halt = fsl_ep_set_halt,
+	.fifo_status = arcotg_fifo_status,
 	.fifo_flush = fsl_ep_fifo_flush,	/* flush fifo */
 };
 
@@ -1104,13 +1165,8 @@ static int can_pullup(struct fsl_udc *udc)
 	return udc->driver && udc->softconnect && udc->vbus_active;
 }
 
-/*
- * Notify controller that VBUS is powered, Called by whatever
- * detects VBUS sessions
- * @param gadger    gadger pointer
- * @param is_active is active?
- * @return Returns zero on success , or a negative error code
- */
+/* Notify controller that VBUS is powered, Called by whatever
+   detects VBUS sessions */
 static int fsl_vbus_session(struct usb_gadget *gadget, int is_active)
 {
 	struct fsl_udc	*udc;
@@ -1118,20 +1174,14 @@ static int fsl_vbus_session(struct usb_gadget *gadget, int is_active)
 
 	udc = container_of(gadget, struct fsl_udc, gadget);
 	spin_lock_irqsave(&udc->lock, flags);
-
-	pr_debug("udc: VBUS %s\n", is_active ? "on" : "off");
+	VDBG("VBUS %s\n", is_active ? "on" : "off");
 	udc->vbus_active = (is_active != 0);
-
-	if (can_pullup(udc)) {
-		pullup_enable(udc);
-		udc_controller->usb_state = USB_STATE_ATTACHED;
-	} else {
-		pullup_disable(udc);
-		udc_controller->usb_state = USB_STATE_NOTATTACHED;
-	}
-	udc_controller->ep0_state = WAIT_FOR_SETUP;
-	udc_controller->ep0_dir = 0;
-
+	if (can_pullup(udc))
+		fsl_writel((fsl_readl(&dr_regs->usbcmd) | USB_CMD_RUN_STOP),
+				&dr_regs->usbcmd);
+	else
+		fsl_writel((fsl_readl(&dr_regs->usbcmd) & ~USB_CMD_RUN_STOP),
+				&dr_regs->usbcmd);
 	spin_unlock_irqrestore(&udc->lock, flags);
 	return 0;
 }
@@ -1145,19 +1195,15 @@ static int fsl_vbus_session(struct usb_gadget *gadget, int is_active)
  */
 static int fsl_vbus_draw(struct usb_gadget *gadget, unsigned mA)
 {
-#ifdef CONFIG_USB_OTG
 	struct fsl_udc *udc;
 
 	udc = container_of(gadget, struct fsl_udc, gadget);
-
 	if (udc->transceiver)
 		return otg_set_power(udc->transceiver, mA);
-#endif
 	return -ENOTSUPP;
 }
 
-/*
- * Change Data+ pullup status
+/* Change Data+ pullup status
  * this func is used by usb_gadget_connect/disconnet
  */
 static int fsl_pullup(struct usb_gadget *gadget, int is_on)
@@ -1176,7 +1222,7 @@ static int fsl_pullup(struct usb_gadget *gadget, int is_on)
 	return 0;
 }
 
-/* defined in usb_gadget.h */
+/* defined in gadget.h */
 static struct usb_gadget_ops fsl_gadget_ops = {
 	.get_frame = fsl_get_frame,
 	.wakeup = fsl_wakeup,
@@ -1263,7 +1309,7 @@ static void ch9setaddress(struct fsl_udc *udc, u16 value, u16 index, u16 length)
  * ch9 Get status
  */
 static void ch9getstatus(struct fsl_udc *udc, u8 request_type, u16 value,
-			 u16 index, u16 length)
+		u16 index, u16 length)
 {
 	u16 tmp = 0;		/* Status, cpu endian */
 
@@ -1323,194 +1369,106 @@ stall:
 	ep0stall(udc);
 }
 
-static void ch9setconfig(struct fsl_udc *udc, u16 value, u16 index,
-			 u16 length)
-{
-	pr_debug("udc: 1 calling gadget driver->setup\n");
-	udc->ep0_dir = USB_DIR_IN;
-	if (udc->driver->setup(&udc->gadget, &udc->local_setup_buff) >= 0) {
-		/* gadget layer deal with the status phase */
-		udc->usb_state = USB_STATE_CONFIGURED;
-		udc->ep0_state = WAIT_FOR_OUT_STATUS;
-		pr_debug("udc: ep0_state now WAIT_FOR_OUT_STATUS\n");
-	}
-}
-
 static void setup_received_irq(struct fsl_udc *udc,
-			       struct usb_ctrlrequest *setup)
+		struct usb_ctrlrequest *setup)
 {
-	u32 tmp;
-	u16 ptc = 0;		/* port test control */
-	int handled = 1;	/* set to zero if we do not handle the message,
-				   and should pass it to the gadget driver */
-
-	/*
-	 * gadget drivers expect the setup pkt to be in wire format,
-	 * so leave it alone and make local copies of stuff we need.
-	 */
 	u16 wValue = le16_to_cpu(setup->wValue);
 	u16 wIndex = le16_to_cpu(setup->wIndex);
 	u16 wLength = le16_to_cpu(setup->wLength);
 
-
-	pr_debug("udc: request=0x%x\n", setup->bRequest);
-
 	udc_reset_ep_queue(udc, 0);
 
-	/* We asume setup only occurs on EP0 */
-	if (setup->bRequestType & USB_DIR_IN)
-		udc->ep0_dir = USB_DIR_IN;
-	else
-		udc->ep0_dir = USB_DIR_OUT;
-
-	if ((setup->bRequestType & USB_TYPE_MASK) == USB_TYPE_CLASS) {
-		/* handle class requests */
-		switch (setup->bRequest) {
-
-		case USB_BULK_RESET_REQUEST:
-			udc->ep0_dir = USB_DIR_IN;
-			if (udc->driver->setup(&udc->gadget,
-					       &udc->local_setup_buff) >= 0) {
-				udc->ep0_state = WAIT_FOR_SETUP;
-				pr_debug("udc: ep0_state now WAIT_FOR_SETUP\n");
-			}
+	/* We process some stardard setup requests here */
+	switch (setup->bRequest) {
+	case USB_REQ_GET_STATUS:
+		/* Data+Status phase from udc */
+		if ((setup->bRequestType & (USB_DIR_IN | USB_TYPE_MASK))
+					!= (USB_DIR_IN | USB_TYPE_STANDARD))
 			break;
+		ch9getstatus(udc, setup->bRequestType, wValue, wIndex, wLength);
+		return;
 
-		default:
-			handled = 0;
-			break;
-		}
-	} else if ((setup->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {
-		/* handle standard requests */
-		switch (setup->bRequest) {
-
-		case USB_REQ_GET_STATUS:
-			if ((setup->
-			     bRequestType & (USB_DIR_IN | USB_TYPE_STANDARD))
-			    != (USB_DIR_IN | USB_TYPE_STANDARD))
-				break;
-			ch9getstatus(udc, setup->bRequestType, wValue, wIndex,
-				     wLength);
+	case USB_REQ_SET_ADDRESS:
+		/* Status phase from udc */
+		if (setup->bRequestType != (USB_DIR_OUT | USB_TYPE_STANDARD
+						| USB_RECIP_DEVICE))
 			break;
+		ch9setaddress(udc, wValue, wIndex, wLength);
+		return;
 
-		case USB_REQ_SET_ADDRESS:
-			if (setup->bRequestType !=
-			    (USB_DIR_OUT | USB_TYPE_STANDARD |
-			     USB_RECIP_DEVICE))
-				break;
-			ch9setaddress(udc, wValue, wIndex, wLength);
-			break;
+	case USB_REQ_CLEAR_FEATURE:
+	case USB_REQ_SET_FEATURE:
+		/* Status phase from udc */
+	{
+		int rc = -EOPNOTSUPP;
 
-		case USB_REQ_SET_CONFIGURATION:
-			if (setup->bRequestType !=
-			    (USB_DIR_OUT | USB_TYPE_STANDARD |
-			     USB_RECIP_DEVICE))
-				break;
-			/* gadget layer take over the status phase */
-			ch9setconfig(udc, wValue, wIndex, wLength);
-			break;
-		case USB_REQ_SET_INTERFACE:
-			if (setup->bRequestType !=
-			    (USB_DIR_OUT | USB_TYPE_STANDARD |
-			     USB_RECIP_INTERFACE))
+		if ((setup->bRequestType & (USB_RECIP_MASK | USB_TYPE_MASK))
+				== (USB_RECIP_ENDPOINT | USB_TYPE_STANDARD)) {
+			int pipe = get_pipe_by_windex(wIndex);
+			struct fsl_ep *ep;
+
+			if (wValue != 0 || wLength != 0 || pipe > udc->max_ep)
 				break;
-			udc->ep0_dir = USB_DIR_IN;
-			if (udc->driver->setup(&udc->gadget,
-					       &udc->local_setup_buff) >= 0)
-				/* gadget layer take over the status phase */
+			ep = get_ep_by_pipe(udc, pipe);
+
+			spin_unlock(&udc->lock);
+			rc = fsl_ep_set_halt(&ep->ep,
+					(setup->bRequest == USB_REQ_SET_FEATURE)
+						? 1 : 0);
+			spin_lock(&udc->lock);
+
+		} else if ((setup->bRequestType & (USB_RECIP_MASK
+				| USB_TYPE_MASK)) == (USB_RECIP_DEVICE
+				| USB_TYPE_STANDARD)) {
+			/* Note: The driver has not include OTG support yet.
+			 * This will be set when OTG support is added */
+			if (!gadget_is_otg(&udc->gadget))
 				break;
-			/* Requests with no data phase */
-		case USB_REQ_CLEAR_FEATURE:
-		case USB_REQ_SET_FEATURE:
-			{	/* status transaction */
-				int rc = -EOPNOTSUPP;
-
-				if ((setup->bRequestType & USB_TYPE_MASK) !=
-				    USB_TYPE_STANDARD)
-					break;
-
-				/* we only support set/clear feature for
-				 * endpoint */
-				if (setup->bRequestType == USB_RECIP_ENDPOINT) {
-					int dir = (wIndex & 0x0080) ?
-					    EP_DIR_IN : EP_DIR_OUT;
-					int num = (wIndex & 0x000f);
-					struct fsl_ep *ep;
-
-					if (wValue != 0
-					    || wLength != 0
-					    || (num * 2 + dir) > udc->max_ep)
-						break;
-					ep = &udc->eps[num * 2 + dir];
-
-					if (setup->bRequest ==
-					    USB_REQ_SET_FEATURE) {
-						pr_debug("udc: udc: SET_FEATURE"
-							 " doing set_halt\n");
-						rc = fsl_ep_set_halt(&ep-> ep,
-								     1);
-					} else {
-						pr_debug("udc: CLEAR_FEATURE"
-							 " doing clear_halt\n");
-						rc = fsl_ep_set_halt(&ep-> ep,
-								     0);
-					}
-
-				} else if (setup->bRequestType ==
-					   USB_RECIP_DEVICE) {
-					if (setup->bRequest ==
-					    USB_REQ_SET_FEATURE) {
-						ptc = wIndex >> 8;
-						rc = 0;
-					}
-					if (!udc->gadget.is_otg)
-						break;
-					else if (setup->bRequest ==
-						 USB_DEVICE_B_HNP_ENABLE)
-						udc->gadget.b_hnp_enable = 1;
-					else if (setup->bRequest ==
-						 USB_DEVICE_A_HNP_SUPPORT)
-						udc->gadget.a_hnp_support = 1;
-					else if (setup->bRequest ==
-						 USB_DEVICE_A_ALT_HNP_SUPPORT)
-						udc->gadget.a_alt_hnp_support =
-						    1;
-					rc = 0;
-				}
-				if (rc == 0) {
-					/* send status only if
-					 * fsl_ep_set_halt success */
-					if (ep0_prime_status(udc, EP_DIR_IN))
-						ep0stall(udc);
-				}
+			else if (setup->bRequest == USB_DEVICE_B_HNP_ENABLE)
+				udc->gadget.b_hnp_enable = 1;
+			else if (setup->bRequest == USB_DEVICE_A_HNP_SUPPORT)
+				udc->gadget.a_hnp_support = 1;
+			else if (setup->bRequest ==
+					USB_DEVICE_A_ALT_HNP_SUPPORT)
+				udc->gadget.a_alt_hnp_support = 1;
+			else
 				break;
-			}
-		default:
-			handled = 0;
+			rc = 0;
+		} else
 			break;
+
+		if (rc == 0) {
+			if (ep0_prime_status(udc, EP_DIR_IN))
+				ep0stall(udc);
 		}
-	} else {
-		/* vendor requests */
-		handled = 0;
+		return;
 	}
 
-	if (!handled) {
-		if (udc->driver->setup(&udc->gadget, &udc->local_setup_buff)
-		    != 0) {
-			ep0stall(udc);
-		} else if (setup->bRequestType & USB_DIR_IN) {
-			udc->ep0_state = DATA_STATE_XMIT;
-			pr_debug("udc: ep0_state now DATA_STATE_XMIT\n");
-		} else {
-			udc->ep0_state = DATA_STATE_RECV;
-			pr_debug("udc: ep0_state now DATA_STATE_RECV\n");
-		}
+	default:
+		break;
 	}
 
-	if (ptc) {
-		tmp =fsl_readl(&dr_regs->portsc1) | ptc << 16;
-		fsl_writel(tmp, &dr_regs->portsc1);
-		pr_debug("udc: switch to test mode.\n");
+	/* Requests handled by gadget */
+	if (wLength) {
+		/* Data phase from gadget, status phase from udc */
+		udc->ep0_dir = (setup->bRequestType & USB_DIR_IN)
+				?  USB_DIR_IN : USB_DIR_OUT;
+		spin_unlock(&udc->lock);
+		if (udc->driver->setup(&udc->gadget,
+				&udc->local_setup_buff) < 0)
+			ep0stall(udc);
+		spin_lock(&udc->lock);
+		udc->ep0_state = (setup->bRequestType & USB_DIR_IN)
+				?  DATA_STATE_XMIT : DATA_STATE_RECV;
+	} else {
+		/* No data phase, IN status from gadget */
+		udc->ep0_dir = USB_DIR_IN;
+		spin_unlock(&udc->lock);
+		if (udc->driver->setup(&udc->gadget,
+				&udc->local_setup_buff) < 0)
+			ep0stall(udc);
+		spin_lock(&udc->lock);
+		udc->ep0_state = WAIT_FOR_OUT_STATUS;
 	}
 }
 
@@ -1575,7 +1533,7 @@ static void tripwire_handler(struct fsl_udc *udc, u8 ep_num, u8 *buffer_ptr)
 		if (pdata->le_setup_buf) {
 			u32 *p = (u32 *)buffer_ptr;
 			u32 *s = (u32 *)qh->setup_buffer;
-			
+
 			/* Convert little endian setup buffer to CPU endian */
 			*p++ = le32_to_cpu(*s++);
 			*p = le32_to_cpu(*s);
@@ -1610,7 +1568,7 @@ static int process_ep_req(struct fsl_udc *udc, int pipe,
 				>> DTD_LENGTH_BIT_POS;
 		actual -= remaining_length;
 
-		(errors = hc32_to_cpu(curr_td->size_ioc_sts) & DTD_ERROR_MASK);
+		errors = hc32_to_cpu(curr_td->size_ioc_sts) & DTD_ERROR_MASK;
 		if (errors) {
 			if (errors & DTD_STATUS_HALTED) {
 				ERR("dTD error %08x QH=%d\n", errors, pipe);
@@ -1635,8 +1593,8 @@ static int process_ep_req(struct fsl_udc *udc, int pipe,
 				ERR("Unknown error has occured (0x%x)!\r\n",
 					errors);
 
-		} else if (hc32_to_cpu(curr_td->size_ioc_sts) &
-					DTD_STATUS_ACTIVE) {
+		} else if (hc32_to_cpu(curr_td->size_ioc_sts)
+				& DTD_STATUS_ACTIVE) {
 			VDBG("Request not complete");
 			status = REQ_UNCOMPLETE;
 			return status;
@@ -1655,7 +1613,7 @@ static int process_ep_req(struct fsl_udc *udc, int pipe,
 		}
 
 		if (j != curr_req->dtd_count - 1)
-			curr_td = curr_td->next_td_virt;
+			curr_td = (struct ep_td_struct *)curr_td->next_td_virt;
 	}
 
 	if (status)
@@ -1713,10 +1671,11 @@ static void dtd_complete_irq(struct fsl_udc *udc)
 			if (ep_num == 0) {
 				ep0_req_complete(udc, curr_ep, curr_req);
 				break;
-			} else {
+			} else
 				done(curr_ep, curr_req, status);
-			}
 		}
+
+		dump_ep_queue(curr_ep);
 	}
 }
 
@@ -1725,14 +1684,14 @@ static void port_change_irq(struct fsl_udc *udc)
 {
 	u32 speed;
 
-	VDBG("portsc=0x%x", fsl_readl(&dr_regs->portsc1) );
 	if (udc->bus_reset)
 		udc->bus_reset = 0;
 
 	/* Bus resetting is finished */
 	if (!(fsl_readl(&dr_regs->portsc1) & PORTSCX_PORT_RESET)) {
 		/* Get the speed */
-		speed = fsl_readl(&dr_regs->portsc1) & PORTSCX_PORT_SPEED_MASK;
+		speed = (fsl_readl(&dr_regs->portsc1)
+				& PORTSCX_PORT_SPEED_MASK);
 		switch (speed) {
 		case PORTSCX_PORT_SPEED_HIGH:
 			udc->gadget.speed = USB_SPEED_HIGH;
@@ -1874,8 +1833,7 @@ static irqreturn_t fsl_udc_irq(int irq, void *_udc)
 	/* Clear notification bits */
 	fsl_writel(irq_src, &dr_regs->usbsts);
 
-	VDBG("irq_src [0x%8x]  portsc=0x%x", irq_src,
-	     fsl_readl(&dr_regs->portsc1));
+	/* VDBG("irq_src [0x%8x]", irq_src); */
 
 	/* Need to resume? */
 	if (udc->usb_state == USB_STATE_SUSPENDED)
@@ -1913,6 +1871,7 @@ static irqreturn_t fsl_udc_irq(int irq, void *_udc)
 
 	/* Reset Received */
 	if (irq_src & USB_STS_RESET) {
+		VDBG("reset int");
 		reset_irq(udc);
 		status = IRQ_HANDLED;
 	}
@@ -1939,72 +1898,71 @@ int usb_gadget_register_driver(struct usb_gadget_driver *driver)
 {
 	int retval = -ENODEV;
 	unsigned long flags = 0;
-	struct fsl_udc *udc = udc_controller;
 
-	pr_debug("udc: udc=0x%p\n", udc);
-
-	if (!udc)
+	if (!udc_controller)
 		return -ENODEV;
 
 	if (!driver || (driver->speed != USB_SPEED_FULL
-			&& driver->speed != USB_SPEED_HIGH)
+				&& driver->speed != USB_SPEED_HIGH)
 			|| !driver->bind || !driver->disconnect
 			|| !driver->setup)
 		return -EINVAL;
 
-	if (udc->driver)
+	if (udc_controller->driver)
 		return -EBUSY;
 
 	/* lock is needed but whether should use this lock or another */
-	spin_lock_irqsave(&udc->lock, flags);
+	spin_lock_irqsave(&udc_controller->lock, flags);
 
 	driver->driver.bus = 0;
-	udc->softconnect = 1;
 	/* hook up the driver */
-	udc->driver = driver;
-	udc->gadget.dev.driver = &driver->driver;
-	spin_unlock_irqrestore(&udc->lock, flags);
+	udc_controller->driver = driver;
+	udc_controller->gadget.dev.driver = &driver->driver;
+	spin_unlock_irqrestore(&udc_controller->lock, flags);
 
 	/* bind udc driver to gadget driver */
-	retval = driver->bind(&udc->gadget);
+	retval = driver->bind(&udc_controller->gadget);
 	if (retval) {
-		pr_debug("bind to %s --> %d\n", driver->driver.name, retval);
-		udc->gadget.dev.driver = 0;
-		udc->driver = 0;
+		VDBG("bind to %s --> %d", driver->driver.name, retval);
+		udc_controller->gadget.dev.driver = 0;
+		udc_controller->driver = 0;
 		goto out;
 	}
 
-	/* Enable DR IRQ reg and Set usbcmd reg  Run bit */
-	if (udc->transceiver) {
-		/* Suspend the controller until OTG enables it */
-		udc_suspend(udc);
-		pr_debug("udc: suspend udc for OTG auto detect \n");
-
-		/* Export udc suspend/resume call to OTG */
-		udc->gadget.dev.parent->driver->suspend = fsl_udc_suspend;
-		udc->gadget.dev.parent->driver->resume = fsl_udc_resume;
-
-		retval = otg_set_peripheral(udc->transceiver, &udc->gadget);
-		if (retval < 0) {
-			printk(KERN_ERR "can't bind to transceiver\n");
-			driver->unbind(&udc->gadget);
-			udc->gadget.dev.driver = 0;
-			udc->driver = 0;
-			return retval;
+	if (udc_controller->transceiver) {
+		/* Suspend the controller until OTG enable it */
+		udc_controller->stopped = 1;
+		printk(KERN_INFO "Suspend udc for OTG auto detect\n");
+
+		/* export udc suspend/resume call to OTG */
+		udc_controller->gadget.dev.driver->suspend = fsl_udc_suspend;
+		udc_controller->gadget.dev.driver->resume = fsl_udc_resume;
+
+		/* connect to bus through transceiver */
+		if (udc_controller->transceiver) {
+			retval = otg_set_peripheral(udc_controller->transceiver,
+						    &udc_controller->gadget);
+			if (retval < 0) {
+				ERR("can't bind to transceiver\n");
+				driver->unbind(&udc_controller->gadget);
+				udc_controller->gadget.dev.driver = 0;
+				udc_controller->driver = 0;
+				return retval;
+			}
 		}
 	} else {
 		/* Enable DR IRQ reg and Set usbcmd reg  Run bit */
-		dr_controller_run(udc);
-		udc->usb_state = USB_STATE_ATTACHED;
-		udc->ep0_state = WAIT_FOR_SETUP;
-		pr_debug("udc: ep0_state now WAIT_FOR_SETUP\n");
-		udc->ep0_dir = 0;
+		dr_controller_run(udc_controller);
+		udc_controller->usb_state = USB_STATE_ATTACHED;
+		udc_controller->ep0_state = WAIT_FOR_SETUP;
+		udc_controller->ep0_dir = 0;
 	}
-
-	printk(KERN_INFO "%s: bind to driver %s \n", udc->gadget.name,
-		driver->driver.name);
+	printk(KERN_INFO "%s: bind to driver %s \n",
+			udc_controller->gadget.name, driver->driver.name);
 
 out:
+	if (retval)
+		printk(KERN_DEBUG "retval %d \n", retval);
 	return retval;
 }
 EXPORT_SYMBOL(usb_gadget_register_driver);
@@ -2021,10 +1979,8 @@ int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
 	if (!driver || driver != udc_controller->driver || !driver->unbind)
 		return -EINVAL;
 
-#ifdef CONFIG_USB_OTG
 	if (udc_controller->transceiver)
 		(void)otg_set_peripheral(udc_controller->transceiver, 0);
-#endif
 
 	/* stop DR, disable intr */
 	dr_controller_stop(udc_controller);
@@ -2048,7 +2004,8 @@ int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
 	udc_controller->gadget.dev.driver = 0;
 	udc_controller->driver = 0;
 
-	printk(KERN_INFO "unregistered gadget '%s'\n", driver->driver.name);
+	printk(KERN_INFO "unregistered gadget driver '%s'\r\n",
+	       driver->driver.name);
 	return 0;
 }
 EXPORT_SYMBOL(usb_gadget_unregister_driver);
@@ -2073,8 +2030,10 @@ static int fsl_proc_read(char *page, char **start, off_t off, int count,
 	u32 tmp_reg;
 	struct fsl_ep *ep = NULL;
 	struct fsl_req *req;
+	struct fsl_usb2_platform_data *pdata;
 
 	struct fsl_udc *udc = udc_controller;
+	pdata = udc->pdata;
 	if (off != 0)
 		return 0;
 
@@ -2093,10 +2052,9 @@ static int fsl_proc_read(char *page, char **start, off_t off, int count,
 	/* ------ DR Registers ----- */
 	tmp_reg = fsl_readl(&dr_regs->usbcmd);
 	t = scnprintf(next, size,
-			"USBCMD reg: 0x%08x\n"
-			"\tSetupTW: %d\n"
-			"\tRun/Stop: %s\n\n",
-			tmp_reg,
+			"USBCMD reg:\n"
+			"SetupTW: %d\n"
+			"Run/Stop: %s\n\n",
 			(tmp_reg & USB_CMD_SUTW) ? 1 : 0,
 			(tmp_reg & USB_CMD_RUN_STOP) ? "Run" : "Stop");
 	size -= t;
@@ -2104,10 +2062,9 @@ static int fsl_proc_read(char *page, char **start, off_t off, int count,
 
 	tmp_reg = fsl_readl(&dr_regs->usbsts);
 	t = scnprintf(next, size,
-			"USB Status Reg: 0x%08x\n"
-			"\tDr Suspend: %d   Reset Received: %d   "
-			"System Error: %s  USB Error Interrupt: %s\n\n",
-			tmp_reg,
+			"USB Status Reg:\n"
+			"Dr Suspend: %d" "Reset Received: %d" "System Error: %s"
+			"USB Error Interrupt: %s\n\n",
 			(tmp_reg & USB_STS_SUSPEND) ? 1 : 0,
 			(tmp_reg & USB_STS_RESET) ? 1 : 0,
 			(tmp_reg & USB_STS_SYS_ERR) ? "Err" : "Normal",
@@ -2117,13 +2074,12 @@ static int fsl_proc_read(char *page, char **start, off_t off, int count,
 
 	tmp_reg = fsl_readl(&dr_regs->usbintr);
 	t = scnprintf(next, size,
-			"USB Interrupt Enable Reg: 0x%08x\n"
-			"\tSleep Enable: %d   SOF Received Enable: %d  "
+			"USB Intrrupt Enable Reg:\n"
+			"Sleep Enable: %d" "SOF Received Enable: %d"
 			"Reset Enable: %d\n"
-			"\tSystem Error Enable: %d  "
+			"System Error Enable: %d"
 			"Port Change Dectected Enable: %d\n"
-			"\tUSB Error Intr Enable: %d  USB Intr Enable: %d\n\n",
-			tmp_reg,
+			"USB Error Intr Enable: %d" "USB Intr Enable: %d\n\n",
 			(tmp_reg & USB_INTR_DEVICE_SUSPEND) ? 1 : 0,
 			(tmp_reg & USB_INTR_SOF_EN) ? 1 : 0,
 			(tmp_reg & USB_INTR_RESET_EN) ? 1 : 0,
@@ -2136,14 +2092,14 @@ static int fsl_proc_read(char *page, char **start, off_t off, int count,
 
 	tmp_reg = fsl_readl(&dr_regs->frindex);
 	t = scnprintf(next, size,
-			"USB Frame Index Reg:  Frame Number is 0x%x\n\n",
+			"USB Frame Index Reg:" "Frame Number is 0x%x\n\n",
 			(tmp_reg & USB_FRINDEX_MASKS));
 	size -= t;
 	next += t;
 
 	tmp_reg = fsl_readl(&dr_regs->deviceaddr);
 	t = scnprintf(next, size,
-			"USB Device Address Reg:  Device Addr is 0x%x\n\n",
+			"USB Device Address Reg:" "Device Addr is 0x%x\n\n",
 			(tmp_reg & USB_DEVICE_ADDRESS_MASK));
 	size -= t;
 	next += t;
@@ -2159,11 +2115,11 @@ static int fsl_proc_read(char *page, char **start, off_t off, int count,
 	tmp_reg = fsl_readl(&dr_regs->portsc1);
 	t = scnprintf(next, size,
 		"USB Port Status&Control Reg:\n"
-		"\tPort Transceiver Type : %s" "Port Speed: %s \n"
-		"\tPHY Low Power Suspend: %s" "Port Reset: %s  "
-		"Port Suspend Mode: %s \n" "\tOver-current Change: %s  "
+		"Port Transceiver Type : %s" "Port Speed: %s \n"
+		"PHY Low Power Suspend: %s" "Port Reset: %s"
+		"Port Suspend Mode: %s \n" "Over-current Change: %s"
 		"Port Enable/Disable Change: %s\n"
-		"\tPort Enabled/Disabled: %s"
+		"Port Enabled/Disabled: %s"
 		"Current Connect Status: %s\n\n", ( {
 			char *s;
 			switch (tmp_reg & PORTSCX_PTS_FSLS) {
@@ -2176,7 +2132,7 @@ static int fsl_proc_read(char *page, char **start, off_t off, int count,
 			default:
 				s = "None"; break;
 			}
-			s; } ), ( {
+			s;} ), ( {
 			char *s;
 			switch (tmp_reg & PORTSCX_PORT_SPEED_UNDEF) {
 			case PORTSCX_PORT_SPEED_FULL:
@@ -2244,18 +2200,18 @@ static int fsl_proc_read(char *page, char **start, off_t off, int count,
 	size -= t;
 	next += t;
 
-#ifdef HAVE_SYS_REGS
-	tmp_reg = usb_sys_regs->snoop1;
-	t = scnprintf(next, size, "\nSnoop1 Reg : = [0x%x]\n\n", tmp_reg);
-	size -= t;
-	next += t;
+	if (pdata->have_sysif_regs) {
+		tmp_reg = usb_sys_regs->snoop1;
+		t = scnprintf(next, size, "\nSnoop1 Reg = [0x%x]\n\n", tmp_reg);
+		size -= t;
+		next += t;
 
-	tmp_reg = usb_sys_regs->control;
-	t = scnprintf(next, size, "General Control Reg : = [0x%x]\n\n",
-			tmp_reg);
-	size -= t;
-	next += t;
-#endif
+		tmp_reg = usb_sys_regs->control;
+		t = scnprintf(next, size, "General Control Reg = [0x%x]\n\n",
+				tmp_reg);
+		size -= t;
+		next += t;
+	}
 
 	/* ------fsl_udc, fsl_ep, fsl_request structure information ----- */
 	ep = &udc->eps[0];
@@ -2344,28 +2300,19 @@ static void fsl_udc_release(struct device *dev)
  * init resource for globle controller
  * Return the udc handle on success or NULL on failure
  ------------------------------------------------------------------*/
-static struct fsl_udc *__init struct_udc_setup(struct platform_device *pdev)
+static int __init struct_udc_setup(struct fsl_udc *udc,
+		struct platform_device *pdev)
 {
-	struct fsl_udc *udc;
 	struct fsl_usb2_platform_data *pdata;
 	size_t size;
 
-	udc = kzalloc(sizeof(struct fsl_udc), GFP_KERNEL);
-	if (udc == NULL) {
-		ERR("malloc udc failed\n");
-		return NULL;
-	}
-
 	pdata = pdev->dev.platform_data;
-	udc->phy_mode = pdata->phy_mode;	/* DDD FIXME */
-
-	/* max_ep_nr is bidirectional ep number, max_ep doubles the number */
-	udc->max_ep = pdata->max_ep_nr * 2;
+	udc->phy_mode = pdata->phy_mode;
 
 	udc->eps = kzalloc(sizeof(struct fsl_ep) * udc->max_ep, GFP_KERNEL);
 	if (!udc->eps) {
 		ERR("malloc fsl_ep failed\n");
-		goto cleanup;
+		return -1;
 	}
 
 	/* initialized QHs, take care of alignment */
@@ -2381,12 +2328,13 @@ static struct fsl_udc *__init struct_udc_setup(struct platform_device *pdev)
 	if (!udc->ep_qh) {
 		ERR("malloc QHs for udc failed\n");
 		kfree(udc->eps);
-		goto cleanup;
+		return -1;
 	}
 
 	udc->ep_qh_size = size;
 
 	/* Initialize ep0 status request structure */
+	/* FIXME: fsl_alloc_request() ignores ep argument */
 	udc->status_req = container_of(fsl_alloc_request(NULL, GFP_KERNEL),
 			struct fsl_req, req);
 	/* allocate a small amount of memory to get valid address */
@@ -2399,11 +2347,7 @@ static struct fsl_udc *__init struct_udc_setup(struct platform_device *pdev)
 	udc->remote_wakeup = 0;	/* default to 0 on reset */
 	spin_lock_init(&udc->lock);
 
-	return udc;
-
-cleanup:
-	kfree(udc);
-	return NULL;
+	return 0;
 }
 
 /*----------------------------------------------------------------
@@ -2441,154 +2385,171 @@ static int __init struct_ep_setup(struct fsl_udc *udc, unsigned char index,
 	return 0;
 }
 
-static int board_init(struct platform_device *pdev)
-{
-	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
-
-	pr_debug("udc: pdev=0x%p  pdata=0x%p\n", pdev, pdata);
-
-	/*
-	 * do platform specific init: check the clock, grab/config pins, etc.
-	 */
-	if (pdata->platform_init && pdata->platform_init(pdev) != 0)
-		return -EINVAL;
-
-	return 0;
-}
-
-/* Driver probe functions */
-
+/* Driver probe function
+ * all intialization operations implemented here except enabling usb_intr reg
+ * board setup should have been done in the platform code
+ */
 static int __init fsl_udc_probe(struct platform_device *pdev)
 {
+	struct resource *res;
 	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
-	struct fsl_udc *udc;
-	unsigned int i;
-	struct otg_transceiver *transceiver = NULL;
-	int status = -ENODEV;
-	u32 id;
-	int irq_number;
-	u64 rsrc_start, rsrc_len;
 	int ret = -ENODEV;
+	unsigned int i;
+	u32 dccparams;
 
-	pr_debug("udc: pdev=0x%p  pdata=0x%p\n", pdev, pdata);
-
-	if (board_init(pdev) != 0)
-		return -EINVAL;
-
-	/* Initialize the udc structure including QH member and other member */
-	udc = (struct fsl_udc *) struct_udc_setup(pdev);
-	udc_controller = udc;
+	if (strcmp(pdev->name, driver_name)) {
+		VDBG("Wrong device\n");
+		return -ENODEV;
+	}
 
-	if (!udc) {
-		ERR("udc is NULL \n");
+	udc_controller = kzalloc(sizeof(struct fsl_udc), GFP_KERNEL);
+	if (udc_controller == NULL) {
+		ERR("malloc udc failed\n");
 		return -ENOMEM;
 	}
-	dev_set_drvdata(&pdev->dev, udc);
-	pr_debug("udc_controller=0x%p", udc_controller);
-
-	udc->pdata = pdata;
-	udc->xcvr_type = pdata->xcvr_type;
+	udc_controller->pdata = pdata;
 
 #ifdef CONFIG_USB_OTG
-	udc->transceiver = otg_get_transceiver();
-	pr_debug("udc: otg_get_transceiver returns 0x%p", udc->transceiver);
-#endif
+	/* Memory and interrupt resources will be passed from OTG */
+	udc_controller->transceiver = otg_get_transceiver();
+	if (!udc_controller->transceiver) {
+		printk(KERN_ERR "Can't find OTG driver!\n");
+		ret = -ENODEV;
+		goto err1a;
+	}
 
-	if (pdev->resource[1].flags != IORESOURCE_IRQ)
+	res = otg_get_resources();
+	if (!res) {
+		DBG("resource not registered!\n");
 		return -ENODEV;
+	}
+#else
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENXIO;
+		goto err1a;
+	}
+
+	if (!request_mem_region(res->start, res->end - res->start + 1,
+				driver_name)) {
+		ERR("request mem region for %s failed \n", pdev->name);
+		ret = -EBUSY;
+		goto err1a;
+	}
+#endif
+	dr_regs = ioremap(res->start, res->end - res->start + 1);
+	if (!dr_regs) {
+		ret = -ENOMEM;
+		goto err1;
+	}
+	pdata->regs = (void *)dr_regs;
 
-	rsrc_start = pdev->resource[0].start;
-	rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;
+	fsl_set_usb_accessors(pdata);
 
-	pr_debug("     start=0x%ux   end=0x%ux\n",
-		 pdev->resource[0].start, pdev->resource[0].end);
-	pr_debug("rsrc_start=0x%llx  rsrc_len=0x%llx\n", rsrc_start, rsrc_len);
+	/*
+	 * do platform specific init: check the clock, grab/config pins, etc.
+	 */
+	if (pdata->platform_init && pdata->platform_init(pdev)) {
+		ret = -ENODEV;
+		goto err2a;
+	}
 
-	dr_regs = (struct fsl_usb_device_regs *)pdata->regs;
+	if (pdata->have_sysif_regs)
+		usb_sys_regs = (struct usb_sys_interface *)
+				((u32)dr_regs + USB_DR_SYS_OFFSET);
 
-	pr_debug("udc: pdate=0x%p dr_regs=0x%p\n", pdata, dr_regs);
-	pr_debug("udc: hci_version=0x%x\n", dr_regs->hciversion);
-	pr_debug("udc: otgsc at 0x%p\n", &dr_regs->otgsc);
+	/* Read Device Controller Capability Parameters register */
+	dccparams = fsl_readl(&dr_regs->dccparams);
+	if (!(dccparams & DCCPARAMS_DC)) {
+		ERR("This SOC doesn't support device role\n");
+		ret = -ENODEV;
+		goto err2;
+	}
+	/* Get max device endpoints */
+	/* DEN is bidirectional ep number, max_ep doubles the number */
+	udc_controller->max_ep = (dccparams & DCCPARAMS_DEN_MASK) * 2;
 
-	id = fsl_readl(&dr_regs->id);
-	printk(KERN_INFO "FSL2 USBOTG h/w ID=0x%x  revision=0x%x\n",
-	       id & 0x3f, id >> 16);
+#ifdef CONFIG_USB_OTG
+	res++;
+	udc_controller->irq = res->start;
+#else
+	udc_controller->irq = platform_get_irq(pdev, 0);
+#endif
+	if (!udc_controller->irq) {
+		ret = -ENODEV;
+		goto err2;
+	}
 
-	/* USB OTG module IRQ */
-	irq_number = platform_get_irq(pdev, 0);
-	if (irq_number > 128) {
-		status = request_irq(irq_number, fsl_udc_irq, IRQF_SHARED,
-				     driver_name, udc);
-		if (status) {
-			ERR("can't get irq %d, err=%d\n", irq_number, status);
-			goto err2;
-		}
-	} else {
-		status = -ENODEV;
+	ret = request_irq(udc_controller->irq, fsl_udc_irq, IRQF_SHARED,
+			driver_name, udc_controller);
+	if (ret != 0) {
+		ERR("cannot request irq %d err %d \n",
+				udc_controller->irq, ret);
 		goto err2;
 	}
 
-	if (!udc->transceiver) {
-		/* initialize usb hw reg except for regs for EP,
-		 * leave usbintr reg untouched*/
-		dr_controller_setup(udc);
+	/* Initialize the udc structure including QH member and other member */
+	if (struct_udc_setup(udc_controller, pdev)) {
+		ERR("Can't initialize udc data structure\n");
+		ret = -ENOMEM;
+		goto err3;
 	}
 
-	/* here comes the stand operations for probe
-	 * set the fsl_udc->gadget.xxx
-	 */
-	udc->gadget.ops = &fsl_gadget_ops;
-	udc->gadget.is_dualspeed = 1;
+	if (!udc_controller->transceiver) {
+		/* initialize usb hw reg except for regs for EP,
+		 * leave usbintr reg untouched */
+		dr_controller_setup(udc_controller);
+	}
 
-	/* gadget.ep0 is a pointer */
-	udc->gadget.ep0 = &udc->eps[0].ep;
-	INIT_LIST_HEAD(&udc->gadget.ep_list);
-	udc->gadget.speed = USB_SPEED_UNKNOWN;
-	udc->gadget.name = driver_name;
+	/* Setup gadget structure */
+	udc_controller->gadget.ops = &fsl_gadget_ops;
+	udc_controller->gadget.is_dualspeed = 1;
+	udc_controller->gadget.ep0 = &udc_controller->eps[0].ep;
+	INIT_LIST_HEAD(&udc_controller->gadget.ep_list);
+	udc_controller->gadget.speed = USB_SPEED_UNKNOWN;
+	udc_controller->gadget.name = driver_name;
 
 	/* Setup gadget.dev and register with kernel */
-	strcpy(udc->gadget.dev.bus_id, "gadget");
-	udc->gadget.dev.release = fsl_udc_release;
-	udc->gadget.dev.parent = &pdev->dev;
-
-	ret = device_register(&udc->gadget.dev);
+	strcpy(udc_controller->gadget.dev.bus_id, "gadget");
+	udc_controller->gadget.dev.release = fsl_udc_release;
+	udc_controller->gadget.dev.parent = &pdev->dev;
+	ret = device_register(&udc_controller->gadget.dev);
 	if (ret < 0)
 		goto err3;
 
-	if (udc->transceiver)
-		udc->gadget.is_otg = 1;
+	if (udc_controller->transceiver)
+		udc_controller->gadget.is_otg = 1;
 
 	/* setup QH and epctrl for ep0 */
-	ep0_setup(udc);
+	ep0_setup(udc_controller);
 
 	/* setup udc->eps[] for ep0 */
 	struct_ep_setup(udc_controller, 0, "ep0", 0);
 	/* for ep0: the desc defined here;
 	 * for other eps, gadget layer called ep_enable with defined desc
 	 */
-	udc->eps[0].desc = &fsl_ep0_desc;
-	udc->eps[0].ep.maxpacket = USB_MAX_CTRL_PAYLOAD;
+	udc_controller->eps[0].desc = &fsl_ep0_desc;
+	udc_controller->eps[0].ep.maxpacket = USB_MAX_CTRL_PAYLOAD;
 
 	/* setup the udc->eps[] for non-control endpoints and link
 	 * to gadget.ep_list */
-	for (i = 1; i < (int)(udc->max_ep / 2); i++) {
+	for (i = 1; i < (int)(udc_controller->max_ep / 2); i++) {
 		char name[14];
 
 		sprintf(name, "ep%dout", i);
-		struct_ep_setup(udc, i * 2, name, 1);
+		struct_ep_setup(udc_controller, i * 2, name, 1);
 		sprintf(name, "ep%din", i);
-		struct_ep_setup(udc, i * 2 + 1, name, 1);
+		struct_ep_setup(udc_controller, i * 2 + 1, name, 1);
 	}
 
 	/* use dma_pool for TD management */
 	udc_controller->td_pool = dma_pool_create("udc_td", &pdev->dev,
 			sizeof(struct ep_td_struct),
 			DTD_ALIGNMENT, UDC_DMA_BOUNDARY);
-	if (udc->td_pool == NULL) {
+	if (udc_controller->td_pool == NULL) {
 		ret = -ENOMEM;
 		goto err4;
 	}
-
 	create_proc_file();
 	return 0;
 
@@ -2597,60 +2558,51 @@ err4:
 err3:
 	free_irq(udc_controller->irq, udc_controller);
 err2:
-	kfree(udc);
-	if (transceiver)
-		put_device(transceiver->dev);
-	release_mem_region(pdev->resource[0].start,
-			   pdev->resource[0].end - pdev->resource[0].start + 1);
-	return status;
-
+	if (pdata->platform_uninit)
+		pdata->platform_uninit(pdata);
+err2a:
+	iounmap((void *)dr_regs);
+err1:
+	if (!udc_controller->transceiver)
+		release_mem_region(res->start, res->end - res->start + 1);
+err1a:
+	kfree(udc_controller);
+	udc_controller = NULL;
+	return ret;
 }
 
-/* Driver removal functions
- * Free resources
- * Finish pending transaction
+/* Driver removal function
+ * Free resources and finish pending transactions
  */
 static int __exit fsl_udc_remove(struct platform_device *pdev)
 {
-	struct device *dev = &pdev->dev;
-	struct fsl_udc *udc = (struct fsl_udc *)dev_get_drvdata(dev);
-	struct fsl_usb2_platform_data *pdata;
-	int irq_number;
+	struct resource __attribute((unused)) *res;
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
 
 	DECLARE_COMPLETION(done);
 
-	pdata = pdev->dev.platform_data;
-
-	if (!udc)
+	if (!udc_controller)
 		return -ENODEV;
-
-	udc->done = &done;
+	udc_controller->done = &done;
 
 	/* DR has been stopped in usb_gadget_unregister_driver() */
-
-	if (udc->transceiver) {
-		put_device(udc->transceiver->dev);
-		udc->transceiver = NULL;
-	}
-
-	/* remove proc */
 	remove_proc_file();
 
-	/* free irq */
-	irq_number = udc->irq;
-	free_irq(pdev->resource[1].start, udc);
-	udc->irq = 0;
-
 	/* Free allocated memory */
-	kfree(udc->status_req->req.buf);
-	kfree(udc->status_req);
+	kfree(udc_controller->status_req->req.buf);
+	kfree(udc_controller->status_req);
 	kfree(udc_controller->eps);
 
 	dma_pool_destroy(udc_controller->td_pool);
-	/* deinitlaize all ep: strcut */
-	/* deinitialize ep0: reg and QH */
+	free_irq(udc_controller->irq, udc_controller);
+	iounmap((void *)dr_regs);
+
+#ifndef CONFIG_USB_OTG
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, res->end - res->start + 1);
+#endif
 
-	device_unregister(&udc->gadget.dev);
+	device_unregister(&udc_controller->gadget.dev);
 	/* free udc --wait for the release() finished */
 	wait_for_completion(&done);
 
@@ -2659,74 +2611,106 @@ static int __exit fsl_udc_remove(struct platform_device *pdev)
 	 * release iomux pins, etc.
 	 */
 	if (pdata->platform_uninit)
-		pdata->platform_uninit(pdev);
+		pdata->platform_uninit(pdata);
 
 	return 0;
 }
 
 static int udc_suspend(struct fsl_udc *udc)
 {
+	u32 mode, usbcmd;
+
+	mode = fsl_readl(&dr_regs->usbmode) & USB_MODE_CTRL_MODE_MASK;
+	usbcmd = fsl_readl(&dr_regs->usbcmd);
+
+	pr_debug("%s(): mode 0x%x stopped %d\n", __func__, mode, udc->stopped);
+
+	/*
+	 * If the controller is already stopped, then this must be a
+	 * PM suspend.  Remember this fact, so that we will leave the
+	 * controller stopped at PM resume time.
+	 */
+	if (udc->stopped) {
+		pr_debug("gadget already stopped, leaving early\n");
+		udc->already_stopped = 1;
+		return 0;
+	}
+
+	if (mode != USB_MODE_CTRL_MODE_DEVICE) {
+		pr_debug("gadget not in device mode, leaving early\n");
+		return 0;
+	}
+
+	printk(KERN_INFO "USB Gadget suspended\n");
+
+	/* stop the controller */
+	usbcmd = fsl_readl(&dr_regs->usbcmd) & ~USB_CMD_RUN_STOP;
+	fsl_writel(usbcmd, &dr_regs->usbcmd);
+
 	udc->stopped = 1;
 	return 0;
 }
 
-/*
+/*-----------------------------------------------------------------
  * Modify Power management attributes
  * Used by OTG statemachine to disable gadget temporarily
- * Here we stop the DR controller and disable the irq
- * @param dev device controller pointer
- * @param state current state
- * @return The function returns 0 on success or -1 if failed
- */
+ -----------------------------------------------------------------*/
 static int fsl_udc_suspend(struct device *dev, pm_message_t state)
 {
-	struct fsl_udc *udc = (struct fsl_udc *)dev_get_drvdata(dev);
-	pr_debug("udc: Suspend. state=%d\n", state.event);
-	return udc_suspend(udc);
+	return udc_suspend(udc_controller);
 }
 
-static int udc_resume(struct fsl_udc *udc)
-{
-	/*Enable DR irq reg and set controller Run */
-	if (udc->stopped) {
-		dr_controller_setup(udc);
-		dr_controller_run(udc);
-	}
-	udc->usb_state = USB_STATE_ATTACHED;
-	udc->ep0_state = WAIT_FOR_SETUP;
-	udc->ep0_dir = 0;
-	return 0;
-}
-
-/*
+/*-----------------------------------------------------------------
  * Invoked on USB resume. May be called in_interrupt.
  * Here we start the DR controller and enable the irq
- * @param dev device controller pointer
- * @return The function returns 0 on success or -1 if failed
- */
+ *-----------------------------------------------------------------*/
 static int fsl_udc_resume(struct device *dev)
 {
-	struct fsl_udc *udc = (struct fsl_udc *)dev_get_drvdata(dev);
-	pr_debug("udc: Resume dev=0x%p udc=0x%p\n", dev, udc);
+	pr_debug("%s(): stopped %d  already_stopped %d\n", __func__,
+		 udc_controller->stopped, udc_controller->already_stopped);
 
-	return udc_resume(udc);
+	/*
+	 * If the controller was stopped at suspend time, then
+	 * don't resume it now.
+	 */
+	if (udc_controller->already_stopped) {
+		udc_controller->already_stopped = 0;
+		pr_debug("gadget was already stopped, leaving early\n");
+		return 0;
+	}
+
+	/* Enable DR irq reg and set controller Run */
+	if (udc_controller->stopped) {
+		dr_controller_setup(udc_controller);
+		dr_controller_run(udc_controller);
+	}
+	udc_controller->usb_state = USB_STATE_ATTACHED;
+	udc_controller->ep0_state = WAIT_FOR_SETUP;
+	udc_controller->ep0_dir = 0;
+
+	printk(KERN_INFO "USB Gadget resumed\n");
+	return 0;
 }
 
 /*-------------------------------------------------------------------------
 	Register entry point for the peripheral controller driver
 --------------------------------------------------------------------------*/
+
 static struct platform_driver udc_driver = {
-	.probe   = fsl_udc_probe,
 	.remove  = __exit_p(fsl_udc_remove),
+	/* these suspend and resume are not usb suspend and resume */
+	.suspend = fsl_udc_suspend,
+	.resume  = fsl_udc_resume,
+	.probe = fsl_udc_probe,
 	.driver  = {
-		.name = (char *)driver_name,
+		.name = driver_name,
 		.owner = THIS_MODULE,
 	},
 };
 
 static int __init udc_init(void)
 {
-	printk(KERN_INFO "%s version %s init \n", driver_desc, DRIVER_VERSION);
+	printk(KERN_INFO "%s (%s)\n", driver_desc, DRIVER_VERSION);
 	return platform_driver_register(&udc_driver);
 }
 
-- 
1.6.0.1

