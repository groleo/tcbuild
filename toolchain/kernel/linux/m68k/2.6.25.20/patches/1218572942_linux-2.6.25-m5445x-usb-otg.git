From 40d8401ea8247113b1cd4772a2bd3dd9f8c1284b Mon Sep 17 00:00:00 2001
From: Bruce Schmid <duck@freescale.com>
Date: Tue, 12 Aug 2008 14:29:02 -0600
Subject: [PATCH] USB OTG

LTIBName: m5445x-usb-otg
Signed-off-by: Bruce Schmid <duck@freescale.com>
---
 drivers/usb/otg/Makefile  |    7 +-
 drivers/usb/otg/fsl_otg.c |  577 +++++++++++++++++++--------------------------
 drivers/usb/otg/fsl_otg.h |  344 ++++++++++++++++++++++++---
 drivers/usb/otg/otg_fsm.c |   74 +++----
 drivers/usb/otg/otg_fsm.h |   45 +---
 drivers/usb/otg/usb.c     |   76 ++++++
 6 files changed, 676 insertions(+), 447 deletions(-)
 create mode 100644 drivers/usb/otg/usb.c

diff --git a/drivers/usb/otg/Makefile b/drivers/usb/otg/Makefile
index ac1e220..039b060 100644
--- a/drivers/usb/otg/Makefile
+++ b/drivers/usb/otg/Makefile
@@ -1,5 +1,10 @@
 #
 # Makefile for USB OTG controller  driver
 #
+obj-$(CONFIG_USB_OTG)		+= usb.o
+
 fsl_usb2_otg-objs		:= fsl_otg.o otg_fsm.o
-obj-y				+= fsl_usb2_otg.o
+ifneq ($(CONFIG_USB),)
+obj-m				+= fsl_usb2_otg.o
+endif
+
diff --git a/drivers/usb/otg/fsl_otg.c b/drivers/usb/otg/fsl_otg.c
index 6208229..4d939e8 100644
--- a/drivers/usb/otg/fsl_otg.c
+++ b/drivers/usb/otg/fsl_otg.c
@@ -1,22 +1,15 @@
 /*
- * Copyright (c) Freescale Semiconductor, Inc. 2006-2007
+ * Copyright (C) 2007,2008 Freescale semiconductor, Inc.
  *
- * USB OTG ULPI driver
+ * Author: Li Yang <LeoLi@freescale.com>
+ *         Jerry Huang <Chang-Ming.Huang@freescale.com>
  *
- * Based on code for MPC from:
- *  Leo Li<LeoLi@freescale.com>
- *  Jerry Huang<Chang-Ming.Huang@freescale.com>
+ * Initialization based on code from Shlomi Gridish.
  *
- * and M5329 code from
- *  Yaroslav Vinogradov yaroslav.vinogradov@freescale.com
- *  Andrey Butok
- *
- *  Initialization based on code from Shlomi Gridish.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
  *
  * This program is distributed in the hope that it will be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -26,14 +19,6 @@
  * You should have received a copy of the  GNU General Public License along
  * with this program; if not, write  to the Free Software Foundation, Inc.,
  * 675 Mass Ave, Cambridge, MA 02139, USA.
- ***************************************************************************
- * Changes:
- *   v0.3	08 August 2007		Duck
- *   v0.2	20 October 2006		Andrey Butok
- *		Issues fixing and some changes.
- *   v0.1	September 2006		Yaroslav Vinogradov
- *		Initial version.
- *
  */
 
 #include <linux/module.h>
@@ -50,44 +35,48 @@
 #include <linux/reboot.h>
 #include <linux/timer.h>
 #include <linux/list.h>
-#include <linux/interrupt.h>
 #include <linux/usb.h>
 #include <linux/device.h>
-#include <linux/platform_device.h>
 #include <linux/usb/ch9.h>
-#include <linux/usb_gadget.h>
+#include <linux/usb/gadget.h>
 #include <linux/workqueue.h>
 #include <linux/time.h>
 #include <linux/fsl_devices.h>
-#include <linux/usb/fsl_usb2.h>
-
-#include <linux/io.h>
+#include <linux/platform_device.h>
 
-#if defined CONFIG_M54455
-#include <asm/mcfsim.h>
-#endif
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/byteorder.h>
+#include <asm/uaccess.h>
+#include <asm/unaligned.h>
 
-#define USE_WORK_QUEUES
 #include "fsl_otg.h"
 
 #define CONFIG_USB_OTG_DEBUG_FILES
-#define DRIVER_VERSION "Revision: 1.56"
-#define DRIVER_AUTHOR "Freescale Semiconductor Inc."
-#define DRIVER_DESC "Freescale USB OTG ULPI Driver"
+#define DRIVER_VERSION "$Revision: 1.1 $"
+#define DRIVER_AUTHOR "Jerry Huang/Li Yang"
+#define DRIVER_DESC "Freescale USB OTG Driver"
 #define DRIVER_INFO DRIVER_VERSION " " DRIVER_DESC
 
-MODULE_DESCRIPTION("Freescale USB OTG Controller Driver");
+MODULE_DESCRIPTION("Freescale USB OTG Transceiver Driver");
 
 static const char driver_name[] = "fsl-usb2-otg";
 
-static spinlock_t usb_dr_regs_lock;
+const pm_message_t otg_suspend_state = {
+	.event = 1,
+};
 
-/*#define HA_DATA_PULSE 1*/
+#define HA_DATA_PULSE 1
 
-volatile static struct fsl_usb_device_regs *usb_dr_regs;
+volatile static struct usb_dr_mmap *usb_dr_regs;
 static struct fsl_otg *fsl_otg_dev;
 static int srp_wait_done;
 
+/* FSM timers */
+struct fsl_otg_timer *a_wait_vrise_tmr, *a_wait_bcon_tmr, *a_aidl_bdis_tmr,
+	*b_ase0_brst_tmr, *b_se0_srp_tmr;
+
 /* Driver specific timers */
 struct fsl_otg_timer *b_data_pulse_tmr, *b_vbus_pulse_tmr, *b_srp_fail_tmr,
 	*b_srp_wait_tmr, *a_wait_enum_tmr;
@@ -98,63 +87,18 @@ static struct fsl_otg_config fsl_otg_initdata = {
 	.otg_port = 1,
 };
 
-#if 0
-static void dump_state(const char *string, struct otg_fsm *fsm)
-{
-	printk(KERN_DEBUG "%s\n\tOTG state: %s\n", string,
-	       state_string(fsl_otg_dev->otg.state));
-	printk(KERN_DEBUG "\tFSM protocol=%s\n", fsm->protocol ?
-	       (fsm->protocol == PROTO_HOST ? "Host" : "Gadget")
-	       : "None");
-
-	/* regs */
-	printk(KERN_DEBUG "\t  OTGSC 0x%08x\n",
-	       fsl_readl(&usb_dr_regs->otgsc));
-	printk(KERN_DEBUG "\tPORTSC1 0x%08x\n",
-	       fsl_readl(&usb_dr_regs->portsc1));
-	printk(KERN_DEBUG "\tUSBMODE 0x%08x\n",
-	       fsl_readl(&usb_dr_regs->usbmode));
-	printk(KERN_DEBUG "\t USBCMD 0x%08x\n",
-	       fsl_readl(&usb_dr_regs->usbcmd));
-	printk(KERN_DEBUG "\t USBSTS 0x%08x\n",
-	       fsl_readl(&usb_dr_regs->usbsts));
-
-	/* ------ State Machine Variables ----- */
-	printk(KERN_DEBUG "\ta_bus_req: %d\n", fsm->a_bus_req);
-	printk(KERN_DEBUG "\tb_bus_req: %d\n", fsm->b_bus_req);
-	printk(KERN_DEBUG "\ta_bus_resume: %d\n", fsm->a_bus_resume);
-	printk(KERN_DEBUG "\ta_bus_suspend: %d\n", fsm->a_bus_suspend);
-	printk(KERN_DEBUG "\ta_conn: %d\n", fsm->a_conn);
-	printk(KERN_DEBUG "\ta_sess_vld: %d\n", fsm->a_sess_vld);
-	printk(KERN_DEBUG "\ta_srp_det: %d\n", fsm->a_srp_det);
-	printk(KERN_DEBUG "\ta_vbus_vld: %d\n", fsm->a_vbus_vld);
-	printk(KERN_DEBUG "\tb_bus_resume: %d\n", fsm->b_bus_resume);
-	printk(KERN_DEBUG "\tb_bus_suspend: %d\n", fsm->b_bus_suspend);
-	printk(KERN_DEBUG "\tb_conn: %d\n", fsm->b_conn);
-	printk(KERN_DEBUG "\tb_se0_srp: %d\n", fsm->b_se0_srp);
-	printk(KERN_DEBUG "\tb_sess_end: %d\n", fsm->b_sess_end);
-	printk(KERN_DEBUG "\tb_sess_vld: %d\n", fsm->b_sess_vld);
-	printk(KERN_DEBUG "\tid: %d\n", fsm->id);
-}
-#endif
-
-
 /* Routines to access transceiver ULPI registers */
 u8 view_ulpi(u8 addr)
 {
 	u32 temp;
 
 	temp = 0x40000000 | (addr << 16);
+	temp = cpu_to_le32(temp);
 	fsl_writel(temp, &usb_dr_regs->ulpiview);
-
 	udelay(1000);
-
-	/* DDD timeout this loop: */
-	do {
+	while (temp & 0x40)
 		temp = fsl_readl(&usb_dr_regs->ulpiview);
-	} while (temp & 0x40000000);
-
-	return (temp & 0x0000ff00) >> 8;
+	return (le32_to_cpu(temp) & 0x0000ff00) >> 8;
 }
 
 int write_ulpi(u8 addr, u8 data)
@@ -162,6 +106,7 @@ int write_ulpi(u8 addr, u8 data)
 	u32 temp;
 
 	temp = 0x60000000 | (addr << 16) | data;
+	temp = cpu_to_hc32(temp);
 	fsl_writel(temp, &usb_dr_regs->ulpiview);
 	return 0;
 }
@@ -178,16 +123,16 @@ void fsl_otg_chrg_vbus(int on)
 {
 	u32 tmp;
 
-	VDBG(" %d\n", on);
-
 	tmp = fsl_readl(&usb_dr_regs->otgsc) & ~OTGSC_INTSTS_MASK;
 
-	if (on) {
-		tmp &= ~OTGSC_CTRL_VBUS_DISCHARGE;
-		tmp |= OTGSC_CTRL_VBUS_CHARGE;
-	} else {
+	if (on)
+		/* stop discharging, start charging */
+		tmp = (tmp & ~OTGSC_CTRL_VBUS_DISCHARGE) |
+			OTGSC_CTRL_VBUS_CHARGE;
+	else
+		/* stop charging */
 		tmp &= ~OTGSC_CTRL_VBUS_CHARGE;
-	}
+
 	fsl_writel(tmp, &usb_dr_regs->otgsc);
 }
 
@@ -196,13 +141,14 @@ void fsl_otg_dischrg_vbus(int on)
 {
 	u32 tmp;
 
-	VDBG(" %d\n", on);
-
 	tmp = fsl_readl(&usb_dr_regs->otgsc) & ~OTGSC_INTSTS_MASK;
 
 	if (on)
-		tmp |= OTGSC_CTRL_VBUS_DISCHARGE;
+		/* stop charging, start discharging */
+		tmp = (tmp & ~OTGSC_CTRL_VBUS_CHARGE) |
+			OTGSC_CTRL_VBUS_DISCHARGE;
 	else
+		/* stop discharging */
 		tmp &= ~OTGSC_CTRL_VBUS_DISCHARGE;
 
 	fsl_writel(tmp, &usb_dr_regs->otgsc);
@@ -211,28 +157,25 @@ void fsl_otg_dischrg_vbus(int on)
 /* A-device driver vbus, controlled through PP bit in PORTSC */
 void fsl_otg_drv_vbus(int on)
 {
-	u32 tmp;
-
-	VDBG(" %d\n", on);
-
-	tmp = fsl_readl(&usb_dr_regs->portsc1) & ~PORTSCX_W1C_BITS;
-
-	if (on)
-		tmp |= PORTSCX_PORT_POWER;
+/*	if (on)
+		usb_dr_regs->portsc =
+		    cpu_to_le32((le32_to_cpu(usb_dr_regs->portsc) &
+				 ~PORTSC_W1C_BITS) | PORTSC_PORT_POWER);
 	else
-		tmp &= ~PORTSCX_PORT_POWER;
-
-	fsl_writel(tmp, &usb_dr_regs->portsc1);
+		usb_dr_regs->portsc =
+		    cpu_to_le32(le32_to_cpu(usb_dr_regs->portsc) &
+				~PORTSC_W1C_BITS & ~PORTSC_PORT_POWER);
+*/
 }
 
-/* Pull-up D+, signalling connect by periperal. Also used in
- * data-line pulsing in SRP */
+/*
+ * Pull-up D+, signalling connect by periperal. Also used in
+ * data-line pulsing in SRP
+ */
 void fsl_otg_loc_conn(int on)
 {
 	u32 tmp;
 
-	VDBG(" %d\n", on);
-
 	tmp = fsl_readl(&usb_dr_regs->otgsc) & ~OTGSC_INTSTS_MASK;
 
 	if (on)
@@ -251,28 +194,24 @@ void fsl_otg_loc_sof(int on)
 {
 	u32 tmp;
 
-	VDBG(" %d\n", on);
-
-	tmp = fsl_readl(&usb_dr_regs->portsc1) & ~PORTSCX_W1C_BITS;
-
+	tmp = fsl_readl(&fsl_otg_dev->dr_mem_map->portsc) & ~PORTSC_W1C_BITS;
 	if (on)
-		tmp |= PORTSCX_PORT_FORCE_RESUME;
+		tmp |= PORTSC_PORT_FORCE_RESUME;
 	else
-		tmp |= PORTSCX_PORT_SUSPEND;
+		tmp |= PORTSC_PORT_SUSPEND;
+
+	fsl_writel(tmp, &fsl_otg_dev->dr_mem_map->portsc);
 
-	fsl_writel(tmp, &usb_dr_regs->portsc1);
 }
 
 /* Start SRP pulsing by data-line pulsing, followed with v-bus pulsing. */
 void fsl_otg_start_pulse(void)
 {
-	u32 __attribute__ ((unused)) tmp;
+	u32 tmp;
 
-	VDBG("\n");
 	srp_wait_done = 0;
-
 #ifdef HA_DATA_PULSE
-	tmp = fsl_readl(&usb_dr_regs->otgsc) &= ~OTGSC_INTSTS_MASK;
+	tmp = fsl_readl(&usb_dr_regs->otgsc) & ~OTGSC_INTSTS_MASK;
 	tmp |= OTGSC_HA_DATA_PULSE;
 	fsl_writel(tmp, &usb_dr_regs->otgsc);
 #else
@@ -346,31 +285,88 @@ void set_tmout(unsigned long indicator)
 }
 
 /* Initialize timers */
-void fsl_otg_init_timers(struct otg_fsm *fsm)
+int fsl_otg_init_timers(struct otg_fsm *fsm)
 {
 	/* FSM used timers */
-	fsm->a_wait_vrise_tmr = otg_timer_initializer(&set_tmout, TA_WAIT_VRISE,
+	a_wait_vrise_tmr = otg_timer_initializer(&set_tmout, TA_WAIT_VRISE,
 				(unsigned long)&fsm->a_wait_vrise_tmout);
-	fsm->a_wait_bcon_tmr = otg_timer_initializer(&set_tmout, TA_WAIT_BCON,
+	if (a_wait_vrise_tmr == NULL)
+		return -ENOMEM;
+
+	a_wait_bcon_tmr = otg_timer_initializer(&set_tmout, TA_WAIT_BCON,
 				(unsigned long)&fsm->a_wait_bcon_tmout);
-	fsm->a_aidl_bdis_tmr = otg_timer_initializer(&set_tmout, TA_AIDL_BDIS,
+	if (a_wait_bcon_tmr == NULL)
+		return -ENOMEM;
+
+	a_aidl_bdis_tmr = otg_timer_initializer(&set_tmout, TA_AIDL_BDIS,
 				(unsigned long)&fsm->a_aidl_bdis_tmout);
-	fsm->b_ase0_brst_tmr = otg_timer_initializer(&set_tmout, TB_ASE0_BRST,
+	if (a_aidl_bdis_tmr == NULL)
+		return -ENOMEM;
+
+	b_ase0_brst_tmr = otg_timer_initializer(&set_tmout, TB_ASE0_BRST,
 				(unsigned long)&fsm->b_ase0_brst_tmout);
-	fsm->b_se0_srp_tmr = otg_timer_initializer(&set_tmout, TB_SE0_SRP,
+	if (b_ase0_brst_tmr == NULL)
+		return -ENOMEM;
+
+	b_se0_srp_tmr = otg_timer_initializer(&set_tmout, TB_SE0_SRP,
 				(unsigned long)&fsm->b_se0_srp);
-	fsm->b_srp_fail_tmr = otg_timer_initializer(&set_tmout, TB_SRP_FAIL,
+	if (b_se0_srp_tmr == NULL)
+		return -ENOMEM;
+
+	b_srp_fail_tmr = otg_timer_initializer(&set_tmout, TB_SRP_FAIL,
 				(unsigned long)&fsm->b_srp_done);
-	fsm->a_wait_enum_tmr = otg_timer_initializer(&a_wait_enum, 10,
+	if (b_srp_fail_tmr == NULL)
+		return -ENOMEM;
+
+	a_wait_enum_tmr = otg_timer_initializer(&a_wait_enum, 10,
 				(unsigned long)&fsm);
+	if (a_wait_enum_tmr == NULL)
+		return -ENOMEM;
 
 	/* device driver used timers */
 	b_srp_wait_tmr = otg_timer_initializer(&b_srp_end, TB_SRP_WAIT, 0);
+	if (b_srp_wait_tmr == NULL)
+		return -ENOMEM;
+
 	b_data_pulse_tmr = otg_timer_initializer(&b_data_pulse_end,
 				TB_DATA_PLS, 0);
+	if (b_data_pulse_tmr == NULL)
+		return -ENOMEM;
+
 	b_vbus_pulse_tmr = otg_timer_initializer(&b_vbus_pulse_end,
 				TB_VBUS_PLS, 0);
+	if (b_vbus_pulse_tmr == NULL)
+		return -ENOMEM;
+
+	return 0;
+}
+
+/* Uninitialize timers */
+void fsl_otg_uninit_timers(void)
+{
+	/* FSM used timers */
+	if (a_wait_vrise_tmr != NULL)
+		kfree(a_wait_vrise_tmr);
+	if (a_wait_bcon_tmr != NULL)
+		kfree(a_wait_bcon_tmr);
+	if (a_aidl_bdis_tmr != NULL)
+		kfree(a_aidl_bdis_tmr);
+	if (b_ase0_brst_tmr != NULL)
+		kfree(b_ase0_brst_tmr);
+	if (b_se0_srp_tmr != NULL)
+		kfree(b_se0_srp_tmr);
+	if (b_srp_fail_tmr != NULL)
+		kfree(b_srp_fail_tmr);
+	if (a_wait_enum_tmr != NULL)
+		kfree(a_wait_enum_tmr);
 
+	/* device driver used timers */
+	if (b_srp_wait_tmr != NULL)
+		kfree(b_srp_wait_tmr);
+	if (b_data_pulse_tmr != NULL)
+		kfree(b_data_pulse_tmr);
+	if (b_vbus_pulse_tmr != NULL)
+		kfree(b_vbus_pulse_tmr);
 }
 
 /* Add timer to timer list */
@@ -402,8 +398,7 @@ void fsl_otg_del_timer(void *gtimer)
 			list_del(&timer->list);
 }
 
-/*
- * Reduce timer count by 1, and find timeout conditions.
+/* Reduce timer count by 1, and find timeout conditions.
  * Called by fsl_otg 1ms timer interrupt
  */
 int fsl_otg_tick_timer(void)
@@ -428,25 +423,11 @@ int fsl_otg_tick_timer(void)
 void otg_reset_controller(void)
 {
 	u32 command;
-	unsigned long flags;
-	int timeout;
-
-	VDBG("\n");
-
-	spin_lock_irqsave(&usb_dr_regs_lock, flags);
 
 	command = fsl_readl(&usb_dr_regs->usbcmd);
-	command |= USB_CMD_CTRL_RESET;
+	command |= (1 << 1);
 	fsl_writel(command, &usb_dr_regs->usbcmd);
-	spin_unlock_irqrestore(&usb_dr_regs_lock, flags);
-
-	/* Wait reset completed */
-	timeout = 500;
-	while (fsl_readl(&usb_dr_regs->usbcmd) & USB_CMD_CTRL_RESET)
-		udelay(1);
-	if (timeout <= 0)
-		ERR("%s - USBCMD_RST never clear. Timeout is %d \n",
-			__FUNCTION__, timeout);
+	while (fsl_readl(&usb_dr_regs->usbcmd) & (1 << 1)) ;
 }
 
 /* Call suspend/resume routines in host driver */
@@ -459,11 +440,9 @@ int fsl_otg_start_host(struct otg_fsm *fsm, int on)
 
 	if (!xceiv->host)
 		return -ENODEV;
-
 	dev = xceiv->host->controller;
 
-	/*
-	 * Update a_vbus_vld state as a_vbus_vld int is disabled
+	/* Update a_vbus_vld state as a_vbus_vld int is disabled
 	 * in device mode
 	 */
 	fsm->a_vbus_vld =
@@ -498,7 +477,7 @@ int fsl_otg_start_host(struct otg_fsm *fsm, int on)
 		else {
 			VDBG("host off......\n");
 			if (dev && dev->driver) {
-				retval = dev->driver->suspend(dev, PMSG_SUSPEND);
+				retval = dev->driver->suspend(dev, otg_suspend_state);
 				if (fsm->id)
 					/* default-b */
 					fsl_otg_drv_vbus(0);
@@ -510,8 +489,7 @@ end:
 	return retval;
 }
 
-/*
- * Call suspend and resume function in udc driver
+/* Call suspend and resume function in udc driver
  * to stop and start udc driver.
  */
 int fsl_otg_start_gadget(struct otg_fsm *fsm, int on)
@@ -519,64 +497,21 @@ int fsl_otg_start_gadget(struct otg_fsm *fsm, int on)
 	struct otg_transceiver *xceiv = fsm->transceiver;
 	struct device *dev;
 
-	VDBG("DDD fsm=%p  xceiv=%p\n", fsm, xceiv);
 	if (!xceiv->gadget || !xceiv->gadget->dev.parent)
 		return -ENODEV;
 
-	VDBG("DDD xceiv=%p  xceiv->gadget=%p  parent=%p\n", xceiv, xceiv->gadget,
-		xceiv->gadget->dev.parent);
-
-	VDBG("gadget %s\n", on ? "on" : "off");
-	/* DDD  dump_state("starting gadget", fsm); */
-
+	VDBG("gadget %s \n", on ? "on" : "off");
 	dev = xceiv->gadget->dev.parent;
 
 	if (on)
 		dev->driver->resume(dev);
 	else
-		dev->driver->suspend(dev, PMSG_SUSPEND);
+		dev->driver->suspend(dev, otg_suspend_state);
 
 	return 0;
 }
 
-#if 0
-static void fsl_otg_enable(struct otg_transceiver *otg_p)
-{
-	struct fsl_otg *otg_dev = container_of(otg_p, struct fsl_otg, otg);
-	struct otg_fsm *fsm = &(otg_dev)->fsm;
-	u32 otg_sc;
-
-	/* DDD VDBG(""); */
-	/* enable OTG interrupt */
-	otg_sc = fsl_readl(&usb_dr_regs->otgsc);
-	otg_sc |= OTGSC_INTERRUPT_ENABLE_BITS_MASK;
-	otg_sc &= ~OTGSC_IE_1ms_TIMER;
-	otg_sc &= ~OTGSC_CTRL_VBUS_DISCHARGE;
-	otg_sc |= OTGSC_IE_USB_ID;
-	fsl_writel(otg_sc, &usb_dr_regs->otgsc);
-
-	fsm->id = (otg_sc & OTGSC_STS_USB_ID) ? 1 : 0;
-
-	if (fsm->id) {
-		otg_p->state = OTG_STATE_UNDEFINED;
-	} else {
-		otg_p->state = OTG_STATE_A_IDLE;
-	}
-
-	otg_p->default_a = (fsm->id == 0);
-	otg_p->host->is_b_host = fsm->id;
-	otg_p->gadget->is_a_peripheral = !fsm->id;
-
-	fsm->a_vbus_vld = 1;
-
-	fsm->b_sess_vld = (otg_sc & OTGSC_STS_B_SESSION_VALID) ? 1 : 0;
-	fsm->a_sess_vld = (otg_sc & OTGSC_STS_A_SESSION_VALID) ? 1 : 0;
-	fsm->b_sess_end = (otg_sc & OTGSC_STS_B_SESSION_END) ? 1 : 0;
-}
-#endif
-
-/*
- * Called by initialization code of host driver.  Register host controller
+/* Called by initialization code of host driver.  Register host controller
  * to the OTG.  Suspend host for OTG role detection.
  */
 static int fsl_otg_set_host(struct otg_transceiver *otg_p, struct usb_bus *host)
@@ -605,7 +540,7 @@ static int fsl_otg_set_host(struct otg_transceiver *otg_p, struct usb_bus *host)
 		return 0;
 	} else {		/* host driver going away */
 
-		if (!(le32_to_cpu(otg_dev->dr_mem_map->otgsc) &
+		if (!(fsl_readl(&otg_dev->dr_mem_map->otgsc) &
 		      OTGSC_STS_USB_ID)) {
 			/* Mini-A cable connected */
 			struct otg_fsm *fsm = &otg_dev->fsm;
@@ -628,7 +563,8 @@ static int fsl_otg_set_peripheral(struct otg_transceiver *otg_p,
 {
 	struct fsl_otg *otg_dev = container_of(otg_p, struct fsl_otg, otg);
 
-	VDBG("\n");
+	VDBG("otg_dev 0x%x\n", (int)otg_dev);
+	VDBG("fsl_otg_dev 0x%x\n", (int)fsl_otg_dev);
 
 	if (!otg_p || otg_dev != fsl_otg_dev)
 		return -ENODEV;
@@ -652,7 +588,7 @@ static int fsl_otg_set_peripheral(struct otg_transceiver *otg_p,
 	DBG("ID pin=%d\n", otg_dev->fsm.id);
 	if (otg_dev->fsm.id == 1) {
 		fsl_otg_start_host(&otg_dev->fsm, 0);
-		fsl_otg_drv_vbus(0);
+		otg_drv_vbus(&otg_dev->fsm, 0);
 		fsl_otg_start_gadget(&otg_dev->fsm, 1);
 	}
 
@@ -665,7 +601,7 @@ static int fsl_otg_set_power(struct otg_transceiver *otg_p, unsigned mA)
 	if (!fsl_otg_dev)
 		return -ENODEV;
 	if (otg_p->state == OTG_STATE_B_PERIPHERAL)
-		printk(KERN_DEBUG "FSL OTG:Draw %d mA\n", mA);
+		printk(KERN_INFO "FSL OTG:Draw %d mA\n", mA);
 
 	return 0;
 }
@@ -684,10 +620,9 @@ static void fsl_otg_event(struct work_struct *work)
 	struct fsl_otg *og = container_of(work, struct fsl_otg, otg_event.work);
 	struct otg_fsm *fsm = &og->fsm;
 
-	VDBG("DDD fsm->id=%d\n", fsm->id);
 	if (fsm->id) {		/* switch to gadget */
 		fsl_otg_start_host(fsm, 0);
-		fsl_otg_drv_vbus(0);
+		otg_drv_vbus(fsm, 0);
 		fsl_otg_start_gadget(fsm, 1);
 	}
 }
@@ -715,7 +650,7 @@ static int fsl_otg_start_hnp(struct otg_transceiver *otg_p)
 	if (!otg_p || otg_dev != fsl_otg_dev)
 		return -ENODEV;
 
-	VDBG("start_hnp.............\n");
+	/* printk("start_hnp.............\n"); */
 	/* clear a_bus_req to enter a_suspend state */
 	otg_dev->fsm.a_bus_req = 0;
 	otg_statemachine(&otg_dev->fsm);
@@ -723,8 +658,7 @@ static int fsl_otg_start_hnp(struct otg_transceiver *otg_p)
 	return 0;
 }
 
-/*
- * Interrupt handler.  OTG/host/peripheral share the same int line.
+/* Interrupt handler.  OTG/host/peripheral share the same int line.
  * OTG driver clears OTGSC interrupts and leaves USB interrupts
  * intact.  It needs to have knowledge of some USB interrupts
  * such as port change.
@@ -747,8 +681,6 @@ irqreturn_t fsl_otg_isr(int irq, void *dev_id)
 
 	/* process OTG interrupts */
 	if (otg_int_src) {
-		VDBG("\nOTG irq 0x%08x\n", otg_int_src);
-
 		if (otg_int_src & OTGSC_INTSTS_USB_ID) {
 			fsm->id = (otg_sc & OTGSC_STS_USB_ID) ? 1 : 0;
 			otg->default_a = (fsm->id == 0);
@@ -766,24 +698,21 @@ irqreturn_t fsl_otg_isr(int irq, void *dev_id)
 
 			if (fsm->id) {	/* switch to gadget */
 				schedule_delayed_work(&((struct fsl_otg *)
-							dev_id)->otg_event, 25);
+							dev_id)->otg_event, 100);
 			} else {	/* switch to host */
 				cancel_delayed_work(&
 						    ((struct fsl_otg *)dev_id)->
 						    otg_event);
 				fsl_otg_start_gadget(fsm, 0);
-				fsl_otg_drv_vbus(1);
+				otg_drv_vbus(fsm, 1);
 				fsl_otg_start_host(fsm, 1);
 			}
-
 			return IRQ_HANDLED;
 		}
 	}
-
 	return IRQ_NONE;
 }
 
-
 static struct otg_fsm_ops fsl_otg_ops = {
 	.chrg_vbus = fsl_otg_chrg_vbus,
 	.drv_vbus = fsl_otg_drv_vbus,
@@ -799,14 +728,15 @@ static struct otg_fsm_ops fsl_otg_ops = {
 };
 
 /* Initialize the global variable fsl_otg_dev and request IRQ for OTG */
-int fsl_otg_cfg(struct platform_device *pdev)
+static int fsl_otg_conf(struct platform_device *pdev)
 {
 	int status;
 	struct fsl_otg *fsl_otg_tc;
-	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
-	struct resource *res;
+	struct fsl_usb2_platform_data *pdata;
 
-	DBG("\n");
+	pdata = pdev->dev.platform_data;
+
+	DBG();
 
 	if (fsl_otg_dev)
 		return 0;
@@ -816,43 +746,21 @@ int fsl_otg_cfg(struct platform_device *pdev)
 	if (!fsl_otg_tc)
 		return -ENODEV;
 
-	if (pdata->regs) {
-		fsl_otg_tc->dr_mem_map = pdata->regs;
-	} else {
-		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-		if (!res) {
-			dev_err(&pdev->dev, "no register addr.\n");
-			return -ENODEV;
-		}
-
-		/*
-		printk("DDD %s(): rsrc_start=0x%x  rsrc_len=0x%x\n",
-		     __FUNCTION__, res->start, res->end - res->start + 1);
-		*/
-
-		if (!request_mem_region(res->start, res->end - res->start + 1,
-					"OTG")) {
-			dev_dbg(&pdev->dev, "request_mem_region failed\n");
-			return -EBUSY;
-		}
-		fsl_otg_tc->dr_mem_map = ioremap(res->start,
-						 res->end - res->start + 1);
-	}
-	DBG("set dr_mem_map to 0x%p\n", fsl_otg_tc->dr_mem_map);
-
 	INIT_DELAYED_WORK(&fsl_otg_tc->otg_event, fsl_otg_event);
 
 	INIT_LIST_HEAD(&active_timers);
-	fsl_otg_init_timers(&fsl_otg_tc->fsm);
+	status = fsl_otg_init_timers(&fsl_otg_tc->fsm);
+	if (status) {
+		printk(KERN_INFO "Couldn't init OTG timers\n");
+		fsl_otg_uninit_timers();
+		kfree(fsl_otg_tc);
+		return status;
+	}
+	spin_lock_init(&fsl_otg_tc->fsm.lock);
 
 	/* Set OTG state machine operations */
 	fsl_otg_tc->fsm.ops = &fsl_otg_ops;
 
-	/* record initial state of ID pin */
-	fsl_otg_tc->fsm.id = (fsl_otg_tc->dr_mem_map->otgsc & OTGSC_STS_USB_ID)
-	    ? 1 : 0;
-	DBG("initial ID pin=%d\n", fsl_otg_tc->fsm.id);
-
 	/* initialize the otg structure */
 	fsl_otg_tc->otg.label = DRIVER_DESC;
 	fsl_otg_tc->otg.set_host = fsl_otg_set_host;
@@ -879,12 +787,11 @@ int usb_otg_start(struct platform_device *pdev)
 	struct fsl_otg *p_otg;
 	struct otg_transceiver *otg_trans = otg_get_transceiver();
 	struct otg_fsm *fsm;
+	volatile unsigned long *p;
 	int status;
+	struct resource *res;
 	u32 temp;
 	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
-	int timeout;
-
-	DBG("\n");
 
 	p_otg = container_of(otg_trans, struct fsl_otg, otg);
 	fsm = &p_otg->fsm;
@@ -893,8 +800,17 @@ int usb_otg_start(struct platform_device *pdev)
 	SET_OTG_STATE(otg_trans, OTG_STATE_UNDEFINED);
 	fsm->transceiver = &p_otg->otg;
 
-	usb_dr_regs = p_otg->dr_mem_map;
-	DBG("set usb_dr_regs to 0x%p\n", usb_dr_regs);
+	/* We don't require predefined MEM/IRQ resource index */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENXIO;
+
+	/* We don't request_mem_region here to enable resource sharing
+	 * with host/device */
+
+	usb_dr_regs = ioremap(res->start, sizeof(struct usb_dr_mmap));
+	p_otg->dr_mem_map = (struct usb_dr_mmap *)usb_dr_regs;
+	pdata->regs = (void *)usb_dr_regs;
 
 	/* request irq */
 	p_otg->irq = platform_get_irq(pdev, 0);
@@ -903,56 +819,74 @@ int usb_otg_start(struct platform_device *pdev)
 	if (status) {
 		dev_dbg(p_otg->otg.dev, "can't get IRQ %d, error %d\n",
 			p_otg->irq, status);
+		iounmap(p_otg->dr_mem_map);
 		kfree(p_otg);
 		return status;
 	}
 
+	if (pdata->platform_init && pdata->platform_init(pdev) != 0)
+		return -EINVAL;
+
+
+	/* Export DR controller resources */
+	otg_set_resources(pdev->resource);
 
 	/* stop the controller */
-	temp = fsl_readl(&usb_dr_regs->usbcmd) & ~USB_CMD_RUN_STOP;
-	fsl_writel(temp, &usb_dr_regs->usbcmd);
+	temp = fsl_readl(&p_otg->dr_mem_map->usbcmd);
+	temp &= ~USB_CMD_RUN_STOP;
+	fsl_writel(temp, &p_otg->dr_mem_map->usbcmd);
 
 	/* reset the controller */
-	temp = fsl_readl(&usb_dr_regs->usbcmd);
+	temp = fsl_readl(&p_otg->dr_mem_map->usbcmd);
 	temp |= USB_CMD_CTRL_RESET;
-	fsl_writel(temp, &usb_dr_regs->usbcmd);
+	fsl_writel(temp, &p_otg->dr_mem_map->usbcmd);
 
 	/* wait reset completed */
-	timeout = 500;
-	while (timeout-- &&
-		fsl_readl(&usb_dr_regs->usbcmd) & USB_CMD_CTRL_RESET)
-		udelay(1);
-	if (timeout <= 0)
-		ERR("%s - USBCMD_RST never clear. Timeout is %d \n",
-			__FUNCTION__, timeout);
+	while (fsl_readl(&p_otg->dr_mem_map->usbcmd) & USB_CMD_CTRL_RESET) ;
 
 	/* configure the VBUSHS as IDLE(both host and device) */
-	temp = USB_MODE_STREAM_DISABLE | (pdata->es ? USBMODE_ES : 0);
-	fsl_writel(temp, &usb_dr_regs->usbmode);
+	temp = USB_MODE_STREAM_DISABLE | (pdata->es ? USB_MODE_ES : 0);
+	fsl_writel(temp, &p_otg->dr_mem_map->usbmode);
 
 	/* configure PHY interface */
-	temp = fsl_readl(&usb_dr_regs->portsc1);
-	temp &= ~(PORTSCX_PHY_TYPE_SEL | PORTSCX_PTW_8BIT);
-
-	/* DDD wrong xcvr setting stuff follows */
-	temp |= PORTSCX_PTS_ULPI;
-	fsl_writel(temp, &usb_dr_regs->portsc1);
-
+	temp = fsl_readl(&p_otg->dr_mem_map->portsc);
+	temp &= ~(PORTSC_PHY_TYPE_SEL | PORTSC_PTW);
+	switch (pdata->phy_mode) {
+	case FSL_USB2_PHY_ULPI:
+		temp |= PORTSC_PTS_ULPI;
+		break;
+	case FSL_USB2_PHY_UTMI_WIDE:
+		temp |= PORTSC_PTW_16BIT;
+		/* fall through */
+	case FSL_USB2_PHY_UTMI:
+		temp |= PORTSC_PTS_UTMI;
+		/* fall through */
+	default:
+		break;
+	}
+	fsl_writel(temp, &p_otg->dr_mem_map->portsc);
+
+	if (pdata->have_sysif_regs) {
+		/* configure control enable IO output, big endian register */
+		p = (volatile unsigned long *)(&p_otg->dr_mem_map->control);
+		temp = *p;
+		temp |= USB_CTRL_IOENB;
+		*p = temp;
+	}
 
 	/* disable all interrupt and clear all OTGSC status */
-	temp = fsl_readl(&usb_dr_regs->otgsc);
+	temp = fsl_readl(&p_otg->dr_mem_map->otgsc);
 	temp &= ~OTGSC_INTERRUPT_ENABLE_BITS_MASK;
 	temp |= OTGSC_INTERRUPT_STATUS_BITS_MASK | OTGSC_CTRL_VBUS_DISCHARGE;
-	fsl_writel(temp, &usb_dr_regs->otgsc);
+	fsl_writel(temp, &p_otg->dr_mem_map->otgsc);
 
-	fsl_otg_drv_vbus(0);
 
 	/*
 	 * The identification (id) input is FALSE when a Mini-A plug is inserted
 	 * in the devices Mini-AB receptacle. Otherwise, this input is TRUE.
 	 * Also: record initial state of ID pin
 	 */
-	if (fsl_readl(&usb_dr_regs->otgsc) & OTGSC_STS_USB_ID) {
+	if (fsl_readl(&p_otg->dr_mem_map->otgsc) & OTGSC_STS_USB_ID) {
 		p_otg->otg.state = OTG_STATE_UNDEFINED;
 		p_otg->fsm.id = 1;
 	} else {
@@ -963,25 +897,10 @@ int usb_otg_start(struct platform_device *pdev)
 	DBG("initial ID pin=%d\n", p_otg->fsm.id);
 
 	/* enable OTG ID pin interrupt */
-	temp = fsl_readl(&usb_dr_regs->otgsc);
-	temp |= OTGSC_IE_USB_ID;
-	temp &= ~(OTGSC_CTRL_VBUS_DISCHARGE | OTGSC_IE_1ms_TIMER);
-	fsl_writel(temp, &usb_dr_regs->otgsc);
-
-	return 0;
-}
-
-/* Initialize board specific registers,PIB board,clock and pin multiplexing */
-static int board_init(struct platform_device *pdev)
-{
-	struct fsl_usb2_platform_data *pdata;
-	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
-
-	/*
-	 * do platform specific init: check the clock, grab/config pins, etc.
-	 */
-	if (pdata->platform_init(pdev) != 0)
-		return -EINVAL;
+	temp = fsl_readl(&p_otg->dr_mem_map->otgsc);
+	temp |= OTGSC_INTR_USB_ID_EN;
+	temp &= ~(OTGSC_CTRL_VBUS_DISCHARGE | OTGSC_INTR_1MS_TIMER_EN);
+	fsl_writel(temp, &p_otg->dr_mem_map->otgsc);
 
 	return 0;
 }
@@ -1019,44 +938,37 @@ static int otg_proc_read(char *page, char **start, off_t off, int count,
 	next += t;
 
 	/* ------ Registers ----- */
-	/* tmp_reg = le32_to_cpu(usb_dr_regs->otgsc); */
 	tmp_reg = fsl_readl(&usb_dr_regs->otgsc);
-	t = scnprintf(next, size, "OTGSC reg: 0x%08x\n", tmp_reg);
+	t = scnprintf(next, size, "OTGSC reg: %08x\n", tmp_reg);
 	size -= t;
 	next += t;
 
-	/* tmp_reg = le32_to_cpu(usb_dr_regs->portsc); */
-	tmp_reg = fsl_readl(&usb_dr_regs->portsc1);
-	t = scnprintf(next, size, "PORTSC reg: 0x%08x\n", tmp_reg);
+	tmp_reg = fsl_readl(&usb_dr_regs->portsc);
+	t = scnprintf(next, size, "PORTSC reg: %08x\n", tmp_reg);
 	size -= t;
 	next += t;
 
-	/* tmp_reg = le32_to_cpu(usb_dr_regs->usbmode); */
 	tmp_reg = fsl_readl(&usb_dr_regs->usbmode);
-	t = scnprintf(next, size, "USBMODE reg: 0x%08x\n", tmp_reg);
+	t = scnprintf(next, size, "USBMODE reg: %08x\n", tmp_reg);
 	size -= t;
 	next += t;
 
-	/* tmp_reg = le32_to_cpu(usb_dr_regs->usbcmd); */
 	tmp_reg = fsl_readl(&usb_dr_regs->usbcmd);
-	t = scnprintf(next, size, "USBCMD reg: 0x%08x\n", tmp_reg);
+	t = scnprintf(next, size, "USBCMD reg: %08x\n", tmp_reg);
 	size -= t;
 	next += t;
 
-	/* tmp_reg = le32_to_cpu(usb_dr_regs->usbsts); */
 	tmp_reg = fsl_readl(&usb_dr_regs->usbsts);
-	t = scnprintf(next, size, "USBSTS reg: 0x%08x\n", tmp_reg);
+	t = scnprintf(next, size, "USBSTS reg: %08x\n", tmp_reg);
 	size -= t;
 	next += t;
 
-	/* ------ State ----- */
-	t = scnprintf(next, size, "FSM protocol=%d %s\n", fsm->protocol,
-		fsm->protocol ?
-		(fsm->protocol == PROTO_HOST ? "Host" : "Gadget")
-		: "None");
+	tmp_reg = fsl_readl(&usb_dr_regs->usbintr);
+	t = scnprintf(next, size, "USBINTR reg: %08x\n", tmp_reg);
 	size -= t;
 	next += t;
 
+	/* ------ State ----- */
 	t = scnprintf(next, size,
 		      "OTG state: %s\n\n",
 		      state_string(fsl_otg_dev->otg.state));
@@ -1145,8 +1057,7 @@ static int otg_proc_read(char *page, char **start, off_t off, int count,
 /*----------------------------------------------------------*/
 /* Char driver interface to control some OTG input */
 
-/*
- * This function handle some ioctl command,such as get otg
+/* This function handle some ioctl command,such as get otg
  * status and set host suspend
  */
 static int fsl_otg_ioctl(struct inode *inode, struct file *file,
@@ -1220,11 +1131,10 @@ static int __init fsl_otg_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	pdata = pdev->dev.platform_data;
-	/* Initialize the clock, multiplexing pin and PHY interface */
-	board_init(pdev);
+	fsl_set_usb_accessors(pdata);
 
 	/* configure the OTG */
-	status = fsl_otg_cfg(pdev);
+	status = fsl_otg_conf(pdev);
 	if (status) {
 		printk(KERN_INFO "Couldn't init OTG module\n");
 		return -status;
@@ -1243,26 +1153,15 @@ static int __init fsl_otg_probe(struct platform_device *pdev)
 	return status;
 }
 
-static int fsl_otg_remove(struct platform_device *pdev)
+static int __exit fsl_otg_remove(struct platform_device *pdev)
 {
-	u32 ie;
 	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
-	unsigned long flags;
-
-	DBG("pdev=0x%p  pdata=0x%p\n", pdev, pdata);
 
 	otg_set_transceiver(NULL);
-
-	/* disable and clear OTGSC interrupts */
-	spin_lock_irqsave(&usb_dr_regs_lock, flags);
-	ie = fsl_readl(&usb_dr_regs->otgsc);
-	ie &= ~OTGSC_INTERRUPT_ENABLE_BITS_MASK;
-	ie |= OTGSC_INTERRUPT_STATUS_BITS_MASK;
-	fsl_writel(ie, &usb_dr_regs->otgsc);
-	spin_unlock_irqrestore(&usb_dr_regs_lock, flags);
-
 	free_irq(fsl_otg_dev->irq, fsl_otg_dev);
 
+	iounmap((void *)usb_dr_regs);
+
 	kfree(fsl_otg_dev);
 
 	remove_proc_file();
@@ -1270,17 +1169,16 @@ static int fsl_otg_remove(struct platform_device *pdev)
 	unregister_chrdev(FSL_OTG_MAJOR, FSL_OTG_NAME);
 
 	if (pdata->platform_uninit)
-		pdata->platform_uninit(pdev);
+		pdata->platform_uninit(pdata);
 
-	fsl_otg_dev = NULL;
 	return 0;
 }
 
 struct platform_driver fsl_otg_driver = {
 	.probe = fsl_otg_probe,
-	.remove = fsl_otg_remove,
+	.remove = __exit_p(fsl_otg_remove),
 	.driver = {
-		.name  = driver_name,
+		.name = driver_name,
 		.owner = THIS_MODULE,
 	},
 };
@@ -1296,6 +1194,7 @@ static int __init fsl_usb_otg_init(void)
 static void __exit fsl_usb_otg_exit(void)
 {
 	platform_driver_unregister(&fsl_otg_driver);
+	printk(KERN_INFO DRIVER_DESC " unloaded\n");
 }
 
 module_init(fsl_usb_otg_init);
diff --git a/drivers/usb/otg/fsl_otg.h b/drivers/usb/otg/fsl_otg.h
index 61e6d4f..d389ba5 100644
--- a/drivers/usb/otg/fsl_otg.h
+++ b/drivers/usb/otg/fsl_otg.h
@@ -1,24 +1,255 @@
-/*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
+/* Copyright (C) 2007,2008 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
  *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#ifndef FSL_OTG_H
-#define FSL_OTG_H
-#include <linux/usb/otg.h>
 #include "otg_fsm.h"
+#include <linux/usb/otg.h>
 #include <linux/ioctl.h>
 
-#define ERR(format, arg...) \
-printk(KERN_ERR "%s:%s: " format "\n" , __FILE__,  __FUNCTION__ , ## arg)
+#ifdef CONFIG_PPC32
+#include <asm/fsl_usb_io.h>
+#elif CONFIG_COLDFIRE
+#include <asm/mcfsim.h>
+#include <asm/fsl_usb_io.h>
+#endif
+
+ /* USB Command  Register Bit Masks */
+#define USB_CMD_RUN_STOP		(0x1<<0  )
+#define USB_CMD_CTRL_RESET		(0x1<<1  )
+#define USB_CMD_PERIODIC_SCHEDULE_EN	(0x1<<4  )
+#define USB_CMD_ASYNC_SCHEDULE_EN	(0x1<<5  )
+#define USB_CMD_INT_AA_DOORBELL		(0x1<<6  )
+#define USB_CMD_ASP			(0x3<<8  )
+#define USB_CMD_ASYNC_SCH_PARK_EN	(0x1<<11 )
+#define USB_CMD_SUTW			(0x1<<13 )
+#define USB_CMD_ATDTW			(0x1<<14 )
+#define USB_CMD_ITC			(0xFF<<16)
+
+/* bit 15,3,2 are frame list size */
+#define USB_CMD_FRAME_SIZE_1024		(0x0<<15 | 0x0<<2)
+#define USB_CMD_FRAME_SIZE_512		(0x0<<15 | 0x1<<2)
+#define USB_CMD_FRAME_SIZE_256		(0x0<<15 | 0x2<<2)
+#define USB_CMD_FRAME_SIZE_128		(0x0<<15 | 0x3<<2)
+#define USB_CMD_FRAME_SIZE_64		(0x1<<15 | 0x0<<2)
+#define USB_CMD_FRAME_SIZE_32		(0x1<<15 | 0x1<<2)
+#define USB_CMD_FRAME_SIZE_16		(0x1<<15 | 0x2<<2)
+#define USB_CMD_FRAME_SIZE_8		(0x1<<15 | 0x3<<2)
+
+/* bit 9-8 are async schedule park mode count */
+#define USB_CMD_ASP_00			(0x0<<8)
+#define USB_CMD_ASP_01			(0x1<<8)
+#define USB_CMD_ASP_10			(0x2<<8)
+#define USB_CMD_ASP_11			(0x3<<8)
+#define USB_CMD_ASP_BIT_POS		(8)
+
+/* bit 23-16 are interrupt threshold control */
+#define USB_CMD_ITC_NO_THRESHOLD	(0x00<<16)
+#define USB_CMD_ITC_1_MICRO_FRM		(0x01<<16)
+#define USB_CMD_ITC_2_MICRO_FRM		(0x02<<16)
+#define USB_CMD_ITC_4_MICRO_FRM		(0x04<<16)
+#define USB_CMD_ITC_8_MICRO_FRM		(0x08<<16)
+#define USB_CMD_ITC_16_MICRO_FRM	(0x10<<16)
+#define USB_CMD_ITC_32_MICRO_FRM	(0x20<<16)
+#define USB_CMD_ITC_64_MICRO_FRM	(0x40<<16)
+#define USB_CMD_ITC_BIT_POS		(16)
+
+/* USB Status Register Bit Masks */
+#define USB_STS_INT			(0x1<<0 )
+#define USB_STS_ERR			(0x1<<1 )
+#define USB_STS_PORT_CHANGE		(0x1<<2 )
+#define USB_STS_FRM_LST_ROLL		(0x1<<3 )
+#define USB_STS_SYS_ERR			(0x1<<4 )
+#define USB_STS_IAA			(0x1<<5 )
+#define USB_STS_RESET_RECEIVED		(0x1<<6 )
+#define USB_STS_SOF			(0x1<<7 )
+#define USB_STS_DCSUSPEND		(0x1<<8 )
+#define USB_STS_HC_HALTED		(0x1<<12)
+#define USB_STS_RCL			(0x1<<13)
+#define USB_STS_PERIODIC_SCHEDULE	(0x1<<14)
+#define USB_STS_ASYNC_SCHEDULE		(0x1<<15)
+
+/* USB Interrupt Enable Register Bit Masks */
+#define USB_INTR_INT_EN			(0x1<<0 )
+#define USB_INTR_ERR_INT_EN		(0x1<<1 )
+#define USB_INTR_PC_DETECT_EN		(0x1<<2 )
+#define USB_INTR_FRM_LST_ROLL_EN	(0x1<<3 )
+#define USB_INTR_SYS_ERR_EN		(0x1<<4 )
+#define USB_INTR_ASYN_ADV_EN		(0x1<<5 )
+#define USB_INTR_RESET_EN		(0x1<<6 )
+#define USB_INTR_SOF_EN			(0x1<<7 )
+#define USB_INTR_DEVICE_SUSPEND		(0x1<<8 )
+
+/* Device Address bit masks */
+#define USB_DEVICE_ADDRESS_MASK		(0x7F<<25)
+#define USB_DEVICE_ADDRESS_BIT_POS	(25)
+/* PORTSC  Register Bit Masks,Only one PORT in OTG mode*/
+#define PORTSC_CURRENT_CONNECT_STATUS	(0x1<<0)
+#define PORTSC_CONNECT_STATUS_CHANGE	(0x1<<1)
+#define PORTSC_PORT_ENABLE		(0x1<<2)
+#define PORTSC_PORT_EN_DIS_CHANGE	(0x1<<3)
+#define PORTSC_OVER_CURRENT_ACT		(0x1<<4)
+#define PORTSC_OVER_CUURENT_CHG		(0x1<<5)
+#define PORTSC_PORT_FORCE_RESUME	(0x1<<6)
+#define PORTSC_PORT_SUSPEND		(0x1<<7)
+#define PORTSC_PORT_RESET		(0x1<<8)
+#define PORTSC_LINE_STATUS_BITS		(0x3<<10)
+#define PORTSC_PORT_POWER		(0x1<<12)
+#define PORTSC_PORT_INDICTOR_CTRL	(0x3<<14)
+#define PORTSC_PORT_TEST_CTRL		(0xF<<16)
+#define PORTSC_WAKE_ON_CONNECT_EN	(0x1<<20)
+#define PORTSC_WAKE_ON_CONNECT_DIS	(0x1<<21)
+#define PORTSC_WAKE_ON_OVER_CURRENT	(0x1<<22)
+#define PORTSC_PHY_LOW_POWER_SPD	(0x1<<23)
+#define PORTSC_PORT_FORCE_FULL_SPEED	(0x1<<24)
+#define PORTSC_PORT_SPEED_MASK		(0x3<<26)
+#define PORTSC_TRANSCEIVER_WIDTH	(0x1<<28)
+#define PORTSC_PHY_TYPE_SEL		(0x3<<30)
+/* bit 11-10 are line status */
+#define PORTSC_LINE_STATUS_SE0		(0x0<<10)
+#define PORTSC_LINE_STATUS_JSTATE	(0x1<<10)
+#define PORTSC_LINE_STATUS_KSTATE	(0x2<<10)
+#define PORTSC_LINE_STATUS_UNDEF	(0x3<<10)
+#define PORTSC_LINE_STATUS_BIT_POS	(10)
+
+/* bit 15-14 are port indicator control */
+#define PORTSC_PIC_OFF			(0x0<<14)
+#define PORTSC_PIC_AMBER		(0x1<<14)
+#define PORTSC_PIC_GREEN		(0x2<<14)
+#define PORTSC_PIC_UNDEF		(0x3<<14)
+#define PORTSC_PIC_BIT_POS		(14)
+
+/* bit 19-16 are port test control */
+#define PORTSC_PTC_DISABLE		(0x0<<16)
+#define PORTSC_PTC_JSTATE		(0x1<<16)
+#define PORTSC_PTC_KSTATE		(0x2<<16)
+#define PORTSC_PTC_SEQNAK		(0x3<<16)
+#define PORTSC_PTC_PACKET		(0x4<<16)
+#define PORTSC_PTC_FORCE_EN		(0x5<<16)
+#define PORTSC_PTC_BIT_POS		(16)
+
+/* bit 27-26 are port speed */
+#define PORTSC_PORT_SPEED_FULL		(0x0<<26)
+#define PORTSC_PORT_SPEED_LOW		(0x1<<26)
+#define PORTSC_PORT_SPEED_HIGH		(0x2<<26)
+#define PORTSC_PORT_SPEED_UNDEF		(0x3<<26)
+#define PORTSC_SPEED_BIT_POS		(26)
+
+/* bit 28 is parallel transceiver width for UTMI interface */
+#define PORTSC_PTW			(0x1<<28)
+#define PORTSC_PTW_8BIT			(0x0<<28)
+#define PORTSC_PTW_16BIT		(0x1<<28)
+
+/* bit 31-30 are port transceiver select */
+#define PORTSC_PTS_UTMI			(0x0<<30)
+#define PORTSC_PTS_ULPI			(0x2<<30)
+#define PORTSC_PTS_FSLS_SERIAL		(0x3<<30)
+#define PORTSC_PTS_BIT_POS		(30)
+
+#define PORTSC_W1C_BITS                    \
+       (PORTSC_CONNECT_STATUS_CHANGE |     \
+	PORTSC_PORT_EN_DIS_CHANGE    |     \
+	PORTSC_OVER_CUURENT_CHG)
+
+/* OTG Status Control Register Bit Masks */
+#define OTGSC_CTRL_VBUS_DISCHARGE	(0x1<<0)
+#define OTGSC_CTRL_VBUS_CHARGE		(0x1<<1)
+#define OTGSC_CTRL_OTG_TERMINATION	(0x1<<3)
+#define OTGSC_CTRL_DATA_PULSING		(0x1<<4)
+#define OTGSC_CTRL_ID_PULL_EN		(0x1<<5)
+#define OTGSC_HA_DATA_PULSE		(0x1<<6)
+#define OTGSC_HA_BA			(0x1<<7)
+#define OTGSC_STS_USB_ID		(0x1<<8)
+#define OTGSC_STS_A_VBUS_VALID		(0x1<<9)
+#define OTGSC_STS_A_SESSION_VALID	(0x1<<10)
+#define OTGSC_STS_B_SESSION_VALID	(0x1<<11)
+#define OTGSC_STS_B_SESSION_END		(0x1<<12)
+#define OTGSC_STS_1MS_TOGGLE		(0x1<<13)
+#define OTGSC_STS_DATA_PULSING		(0x1<<14)
+#define OTGSC_INTSTS_USB_ID		(0x1<<16)
+#define OTGSC_INTSTS_A_VBUS_VALID	(0x1<<17)
+#define OTGSC_INTSTS_A_SESSION_VALID	(0x1<<18)
+#define OTGSC_INTSTS_B_SESSION_VALID	(0x1<<19)
+#define OTGSC_INTSTS_B_SESSION_END	(0x1<<20)
+#define OTGSC_INTSTS_1MS		(0x1<<21)
+#define OTGSC_INTSTS_DATA_PULSING	(0x1<<22)
+#define OTGSC_INTR_USB_ID_EN		(0x1<<24)
+#define OTGSC_INTR_A_VBUS_VALID_EN	(0x1<<25)
+#define OTGSC_INTR_A_SESSION_VALID_EN	(0x1<<26)
+#define OTGSC_INTR_B_SESSION_VALID_EN	(0x1<<27)
+#define OTGSC_INTR_B_SESSION_END_EN	(0x1<<28)
+#define OTGSC_INTR_1MS_TIMER_EN		(0x1<<29)
+#define OTGSC_INTR_DATA_PULSING_EN	(0x1<<30)
+#define OTGSC_INTSTS_MASK		(0x00ff0000)
+
+/* USB MODE Register Bit Masks */
+#define  USB_MODE_CTRL_MODE_IDLE	(0x0<<0)
+#define  USB_MODE_CTRL_MODE_DEVICE	(0x2<<0)
+#define  USB_MODE_CTRL_MODE_HOST	(0x3<<0)
+#define  USB_MODE_CTRL_MODE_RSV		(0x1<<0)
+#define  USB_MODE_SETUP_LOCK_OFF	(0x1<<3)
+#define  USB_MODE_STREAM_DISABLE	(0x1<<4)
+#define  USB_MODE_ES			(0x1<<2) /* (big) Endian Select */
+
+#define MPC8349_OTG_IRQ			(38)
+#define CFG_IMMR_BASE	        	(0xfe000000)
+#define MPC83xx_USB_DR_BASE     	(CFG_IMMR_BASE + 0x23000)
+
+/* control Register Bit Masks */
+#define  USB_CTRL_IOENB			(0x1<<2)
+#define  USB_CTRL_ULPI_INT0EN		(0x1<<0)
+
+/* BCSR5 */
+#define BCSR5_INT_USB			(0x02)
+
+/* USB module clk cfg */
+#define SCCR_OFFS			(0xA08)
+#define SCCR_USB_CLK_DISABLE		(0x00000000)	/* USB clk disable */
+#define SCCR_USB_MPHCM_11		(0x00c00000)
+#define SCCR_USB_MPHCM_01		(0x00400000)
+#define SCCR_USB_MPHCM_10		(0x00800000)
+#define SCCR_USB_DRCM_11		(0x00300000)
+#define SCCR_USB_DRCM_01		(0x00100000)
+#define SCCR_USB_DRCM_10		(0x00200000)
+
+#define SICRL_OFFS			(0x114)
+#define SICRL_USB0			(0x40000000)
+#define SICRL_USB1			(0x20000000)
+
+#define SICRH_OFFS			(0x118)
+#define SICRH_USB_UTMI			(0x00020000)
+
+/* OTG interrupt enable bit masks */
+#define  OTGSC_INTERRUPT_ENABLE_BITS_MASK  \
+	(OTGSC_INTR_USB_ID_EN            | \
+	OTGSC_INTR_1MS_TIMER_EN		 | \
+	OTGSC_INTR_A_VBUS_VALID_EN       | \
+	OTGSC_INTR_A_SESSION_VALID_EN    | \
+	OTGSC_INTR_B_SESSION_VALID_EN    | \
+	OTGSC_INTR_B_SESSION_END_EN      | \
+	OTGSC_INTR_DATA_PULSING_EN)
+
+/* OTG interrupt status bit masks */
+#define  OTGSC_INTERRUPT_STATUS_BITS_MASK  \
+	(OTGSC_INTSTS_USB_ID          |    \
+	OTGSC_INTR_1MS_TIMER_EN       |    \
+	OTGSC_INTSTS_A_VBUS_VALID     |    \
+	OTGSC_INTSTS_A_SESSION_VALID  |    \
+	OTGSC_INTSTS_B_SESSION_VALID  |    \
+	OTGSC_INTSTS_B_SESSION_END    |    \
+	OTGSC_INTSTS_DATA_PULSING)
 
 /*
  *  A-DEVICE timing  constants
@@ -28,11 +259,11 @@ printk(KERN_ERR "%s:%s: " format "\n" , __FILE__,  __FUNCTION__ , ## arg)
 #define TA_WAIT_VRISE	(100)	/* a_wait_vrise 100 ms, section: 6.6.5.1 */
 
 /* Wait for B-Connect */
-#define TA_WAIT_BCON	(10000)	/* a_wait_bcon > 1 sec, section: 6.6.5.2
-				 * This is only used to get out of
-				 * OTG_STATE_A_WAIT_BCON state if there was
-				 * no connection for these many milliseconds
-				 */
+#define TA_WAIT_BCON	(10000)  /* a_wait_bcon > 1 sec, section: 6.6.5.2
+				  * This is only used to get out of
+				  * OTG_STATE_A_WAIT_BCON state if there was
+				  * no connection for these many milliseconds
+				  */
 
 /* A-Idle to B-Disconnect */
 /* It is necessary for this timer to be more than 750 ms because of a bug in OPT
@@ -46,6 +277,7 @@ printk(KERN_ERR "%s:%s: " format "\n" , __FILE__,  __FUNCTION__ , ## arg)
 
 /* B-device timing constants */
 
+
 /* Data-Line Pulse Time*/
 #define TB_DATA_PLS	(10)	/* b_srp_init,continue 5~10ms, section:5.3.3 */
 #define TB_DATA_PLS_MIN	(5)	/* minimum 5 ms */
@@ -55,7 +287,7 @@ printk(KERN_ERR "%s:%s: " format "\n" , __FILE__,  __FUNCTION__ , ## arg)
 #define TB_SRP_INIT	(100)	/* b_srp_init,maximum 100 ms, section:5.3.8 */
 
 /* SRP Fail Time  */
-#define TB_SRP_FAIL	(7000)	/* b_srp_init,Fail time 5~30s, section:6.8.2.2 */
+#define TB_SRP_FAIL	(7000)	/* b_srp_init,Fail time 5~30s, section:6.8.2.2*/
 
 /* SRP result wait time */
 #define TB_SRP_WAIT	(60)
@@ -77,20 +309,67 @@ printk(KERN_ERR "%s:%s: " format "\n" , __FILE__,  __FUNCTION__ , ## arg)
 /* SE0 Time Before SRP */
 #define TB_SE0_SRP	(2)	/* b_idle,minimum 2 ms, section:5.3.2 */
 
-#define SET_OTG_STATE(otg_ptr, newstate)	((otg_ptr)->state = newstate)
+
+#define SET_OTG_STATE(otg_ptr, newstate)	((otg_ptr)->state=newstate)
+
+struct usb_dr_mmap {
+	/* Capability register */
+	u8 res1[256];
+	u16 caplength;		/* Capability Register Length */
+	u16 hciversion;		/* Host Controller Interface Version */
+	u32 hcsparams;		/* Host Controller Structual Parameters */
+	u32 hccparams;		/* Host Controller Capability Parameters */
+	u8 res2[20];
+	u32 dciversion;		/* Device Controller Interface Version */
+	u32 dccparams;		/* Device Controller Capability Parameters */
+	u8 res3[24];
+	/* Operation register */
+	u32 usbcmd;		/* USB Command Register */
+	u32 usbsts;		/* USB Status Register */
+	u32 usbintr;		/* USB Interrupt Enable Register */
+	u32 frindex;		/* Frame Index Register */
+	u8 res4[4];
+	u32 deviceaddr;		/* Device Address */
+	u32 endpointlistaddr;	/* Endpoint List Address Register */
+	u8 res5[4];
+	u32 burstsize;		/* Master Interface Data Burst Size Register */
+	u32 txttfilltuning;	/* Transmit FIFO Tuning Controls Register */
+	u8 res6[8];
+	u32 ulpiview;		/* ULPI register access */
+	u8 res7[12];
+	u32 configflag;		/* Configure Flag Register */
+	u32 portsc;		/* Port 1 Status and Control Register */
+	u8 res8[28];
+	u32 otgsc;		/* On-The-Go Status and Control */
+	u32 usbmode;		/* USB Mode Register */
+	u32 endptsetupstat;	/* Endpoint Setup Status Register */
+	u32 endpointprime;	/* Endpoint Initialization Register */
+	u32 endptflush;		/* Endpoint Flush Register */
+	u32 endptstatus;	/* Endpoint Status Register */
+	u32 endptcomplete;	/* Endpoint Complete Register */
+	u32 endptctrl[6];	/* Endpoint Control Registers */
+	u8 res9[552];
+	u32 snoop1;
+	u32 snoop2;
+	u32 age_cnt_thresh;	/* Age Count Threshold Register */
+	u32 pri_ctrl;		/* Priority Control Register */
+	u32 si_ctrl;		/* System Interface Control Register */
+	u8 res10[236];
+	u32 control;		/* General Purpose Control Register */
+};
 
 
 struct fsl_otg_timer {
 	unsigned long expires;	/* Number of count increase to timeout */
 	unsigned long count;	/* Tick counter */
-	void (*function) (unsigned long);	/* Timeout function */
+	void (*function)(unsigned long);	/* Timeout function */
 	unsigned long data;	/* Data passed to function */
 	struct list_head list;
 };
 
 struct fsl_otg_timer inline *otg_timer_initializer
-    (void (*function) (unsigned long), unsigned long expires,
-     unsigned long data) {
+(void (*function)(unsigned long), unsigned long expires, unsigned long data)
+{
 	struct fsl_otg_timer *timer;
 	timer = kmalloc(sizeof(struct fsl_otg_timer), GFP_KERNEL);
 	if (timer == NULL)
@@ -104,12 +383,12 @@ struct fsl_otg_timer inline *otg_timer_initializer
 struct fsl_otg {
 	struct otg_transceiver otg;
 	struct otg_fsm fsm;
-	struct fsl_usb_device_regs *dr_mem_map;
+	struct usb_dr_mmap *dr_mem_map;
 	struct delayed_work otg_event;
 
-	/*used for usb host */
-	u8 host_working;
-	u8 on_off;
+	/* used for usb host */
+	struct work_struct work_wq;
+	u8	host_working;
 
 	int irq;
 };
@@ -120,7 +399,7 @@ struct fsl_otg_config {
 
 /*For SRP and HNP handle*/
 #define FSL_OTG_MAJOR	66
-#define FSL_OTG_NAME	"fsl-otg"
+#define FSL_OTG_NAME	"fsl-usb2-otg"
 /*Command to OTG driver(ioctl)*/
 #define OTG_IOCTL_MAGIC		FSL_OTG_MAJOR
 /*if otg work as host,it should return 1,otherwise it return 0*/
@@ -134,6 +413,5 @@ struct fsl_otg_config {
 #define GET_A_BUS_REQ		_IOR(OTG_IOCTL_MAGIC, 8, int)
 #define GET_B_BUS_REQ		_IOR(OTG_IOCTL_MAGIC, 9, int)
 
-
-/********************************************************************/
-#endif
+extern const char *state_string(enum usb_otg_state state);
+extern int otg_set_resources(struct resource *resources);
diff --git a/drivers/usb/otg/otg_fsm.c b/drivers/usb/otg/otg_fsm.c
index 8ee39f6..a678daa 100644
--- a/drivers/usb/otg/otg_fsm.c
+++ b/drivers/usb/otg/otg_fsm.c
@@ -1,6 +1,6 @@
 /* OTG Finite State Machine from OTG spec
  *
- * Copyright (C) 2007 Freescale Semiconductor, Inc.
+ * Copyright (C) 2007,2008 Freescale Semiconductor, Inc.
  *
  * Author: 	Li Yang <LeoLi@freescale.com>
  * 		Jerry Huang <Chang-Ming.Huang@freescale.com>
@@ -26,8 +26,9 @@
 #include <linux/spinlock.h>
 #include <linux/delay.h>
 #include <linux/usb.h>
-#include <linux/usb_gadget.h>
+#include <linux/usb/gadget.h>
 
+#include <asm/types.h>
 #include "otg_fsm.h"
 
 
@@ -54,15 +55,12 @@ const char *state_string(enum usb_otg_state state)
 	default:			return "UNDEFINED";
 	}
 }
-EXPORT_SYMBOL(state_string);
 
 /* Change USB protocol when there is a protocol change */
 static int otg_set_protocol(struct otg_fsm *fsm, int protocol)
 {
 	int ret = 0;
 
-	VDBG("DDD old fsm->protocol= %d; new protocol= %d\n",
-		     fsm->protocol, protocol);
 	if (fsm->protocol != protocol) {
 		VDBG("Changing role fsm->protocol= %d; new protocol= %d\n",
 				fsm->protocol, protocol);
@@ -92,11 +90,11 @@ static int otg_set_protocol(struct otg_fsm *fsm, int protocol)
 static int state_changed;
 
 /* Called when leaving a state.  Do state clean up jobs here */
-static void otg_leave_state(struct otg_fsm *fsm, enum usb_otg_state old_state)
+void otg_leave_state(struct otg_fsm *fsm, enum usb_otg_state old_state)
 {
 	switch (old_state) {
 	case OTG_STATE_B_IDLE:
-		otg_del_timer(fsm, fsm->b_se0_srp_tmr);
+		otg_del_timer(fsm, b_se0_srp_tmr);
 		fsm->b_se0_srp = 0;
 		break;
 	case OTG_STATE_B_SRP_INIT:
@@ -105,7 +103,7 @@ static void otg_leave_state(struct otg_fsm *fsm, enum usb_otg_state old_state)
 	case OTG_STATE_B_PERIPHERAL:
 		break;
 	case OTG_STATE_B_WAIT_ACON:
-		otg_del_timer(fsm, fsm->b_ase0_brst_tmr);
+		otg_del_timer(fsm, b_ase0_brst_tmr);
 		fsm->b_ase0_brst_tmout = 0;
 		break;
 	case OTG_STATE_B_HOST:
@@ -113,26 +111,25 @@ static void otg_leave_state(struct otg_fsm *fsm, enum usb_otg_state old_state)
 	case OTG_STATE_A_IDLE:
 		break;
 	case OTG_STATE_A_WAIT_VRISE:
-		otg_del_timer(fsm, fsm->a_wait_vrise_tmr);
+		otg_del_timer(fsm, a_wait_vrise_tmr);
 		fsm->a_wait_vrise_tmout = 0;
 		break;
 	case OTG_STATE_A_WAIT_BCON:
-		otg_del_timer(fsm, fsm->a_wait_bcon_tmr);
+		otg_del_timer(fsm, a_wait_bcon_tmr);
 		fsm->a_wait_bcon_tmout = 0;
 		break;
 	case OTG_STATE_A_HOST:
-		otg_del_timer(fsm, fsm->a_wait_enum_tmr);
+		otg_del_timer(fsm, a_wait_enum_tmr);
 		break;
 	case OTG_STATE_A_SUSPEND:
-		otg_del_timer(fsm, fsm->a_aidl_bdis_tmr);
+		otg_del_timer(fsm, a_aidl_bdis_tmr);
 		fsm->a_aidl_bdis_tmout = 0;
 		fsm->a_suspend_req = 0;
-		fsm->a_bus_req = 1;	/* FIXME */
 		break;
 	case OTG_STATE_A_PERIPHERAL:
 		break;
 	case OTG_STATE_A_WAIT_VFALL:
-		otg_del_timer(fsm, fsm->a_wait_vrise_tmr);
+		otg_del_timer(fsm, a_wait_vrise_tmr);
 		break;
 	case OTG_STATE_A_VBUS_ERR:
 		break;
@@ -142,15 +139,12 @@ static void otg_leave_state(struct otg_fsm *fsm, enum usb_otg_state old_state)
 }
 
 /* Called when entering a state */
-static int otg_set_state(struct otg_fsm *fsm, enum usb_otg_state new_state)
+int otg_set_state(struct otg_fsm *fsm, enum usb_otg_state new_state)
 {
 	state_changed = 1;
-	VDBG("State: old=%s new=%s \n",
-		state_string(fsm->transceiver->state), state_string(new_state));
-
 	if (fsm->transceiver->state == new_state)
 		return 0;
-
+	VDBG("Set state: %s \n", state_string(new_state));
 	otg_leave_state(fsm, fsm->transceiver->state);
 	switch (new_state) {
 	case OTG_STATE_B_IDLE:
@@ -159,13 +153,13 @@ static int otg_set_state(struct otg_fsm *fsm, enum usb_otg_state new_state)
 		otg_loc_conn(fsm, 0);
 		otg_loc_sof(fsm, 0);
 		otg_set_protocol(fsm, PROTO_UNDEF);
-		otg_add_timer(fsm, fsm->b_se0_srp_tmr);
+		otg_add_timer(fsm, b_se0_srp_tmr);
 		break;
 	case OTG_STATE_B_SRP_INIT:
 		otg_start_pulse(fsm);
 		otg_loc_sof(fsm, 0);
 		otg_set_protocol(fsm, PROTO_UNDEF);
-		otg_add_timer(fsm, fsm->b_srp_fail_tmr);
+		otg_add_timer(fsm, b_srp_fail_tmr);
 		break;
 	case OTG_STATE_B_PERIPHERAL:
 		otg_chrg_vbus(fsm, 0);
@@ -178,7 +172,7 @@ static int otg_set_state(struct otg_fsm *fsm, enum usb_otg_state new_state)
 		otg_loc_conn(fsm, 0);
 		otg_loc_sof(fsm, 0);
 		otg_set_protocol(fsm, PROTO_HOST);
-		otg_add_timer(fsm, fsm->b_ase0_brst_tmr);
+		otg_add_timer(fsm, b_ase0_brst_tmr);
 		fsm->a_bus_suspend = 0;
 		break;
 	case OTG_STATE_B_HOST:
@@ -187,7 +181,7 @@ static int otg_set_state(struct otg_fsm *fsm, enum usb_otg_state new_state)
 		otg_loc_sof(fsm, 1);
 		otg_set_protocol(fsm, PROTO_HOST);
 		usb_bus_start_enum(fsm->transceiver->host,
-				   fsm->transceiver->host->otg_port);
+				fsm->transceiver->host->otg_port);
 		break;
 	case OTG_STATE_A_IDLE:
 		otg_drv_vbus(fsm, 0);
@@ -201,33 +195,31 @@ static int otg_set_state(struct otg_fsm *fsm, enum usb_otg_state new_state)
 		otg_loc_conn(fsm, 0);
 		otg_loc_sof(fsm, 0);
 		otg_set_protocol(fsm, PROTO_HOST);
-		otg_add_timer(fsm, fsm->a_wait_vrise_tmr);
+		otg_add_timer(fsm, a_wait_vrise_tmr);
 		break;
 	case OTG_STATE_A_WAIT_BCON:
 		otg_drv_vbus(fsm, 1);
 		otg_loc_conn(fsm, 0);
 		otg_loc_sof(fsm, 0);
 		otg_set_protocol(fsm, PROTO_HOST);
-		otg_add_timer(fsm, fsm->a_wait_bcon_tmr);
+		otg_add_timer(fsm, a_wait_bcon_tmr);
 		break;
 	case OTG_STATE_A_HOST:
 		otg_drv_vbus(fsm, 1);
 		otg_loc_conn(fsm, 0);
 		otg_loc_sof(fsm, 1);
 		otg_set_protocol(fsm, PROTO_HOST);
-		/*
-		 * When HNP is triggered while a_bus_req = 0, a_host will
-		 * suspend too fast to complete a_set_b_hnp_en
-		 */
+		/* When HNP is triggered while a_bus_req = 0, a_host will
+		 * suspend too fast to complete a_set_b_hnp_en */
 		if (!fsm->a_bus_req || fsm->a_suspend_req)
-			otg_add_timer(fsm, fsm->a_wait_enum_tmr);
+			otg_add_timer(fsm, a_wait_enum_tmr);
 		break;
 	case OTG_STATE_A_SUSPEND:
 		otg_drv_vbus(fsm, 1);
 		otg_loc_conn(fsm, 0);
 		otg_loc_sof(fsm, 0);
 		otg_set_protocol(fsm, PROTO_HOST);
-		otg_add_timer(fsm, fsm->a_aidl_bdis_tmr);
+		otg_add_timer(fsm, a_aidl_bdis_tmr);
 
 		break;
 	case OTG_STATE_A_PERIPHERAL:
@@ -268,10 +260,9 @@ int otg_statemachine(struct otg_fsm *fsm)
 	state_changed = 0;
 	/* State machine state change judgement */
 
-	VDBG(" State: %s \n", state_string(state));
-
 	switch (state) {
 	case OTG_STATE_UNDEFINED:
+		VDBG("fsm->id = %d \n", fsm->id);
 		if (fsm->id)
 			otg_set_state(fsm, OTG_STATE_B_IDLE);
 		else
@@ -292,9 +283,8 @@ int otg_statemachine(struct otg_fsm *fsm)
 	case OTG_STATE_B_PERIPHERAL:
 		if (!fsm->id || !fsm->b_sess_vld)
 			otg_set_state(fsm, OTG_STATE_B_IDLE);
-		else if (fsm->b_bus_req &&
-			 fsm->transceiver->
-			 gadget->b_hnp_enable && fsm->a_bus_suspend)
+		else if (fsm->b_bus_req && fsm->transceiver->
+				gadget->b_hnp_enable && fsm->a_bus_suspend)
 			otg_set_state(fsm, OTG_STATE_B_WAIT_ACON);
 		break;
 	case OTG_STATE_B_WAIT_ACON:
@@ -321,21 +311,21 @@ int otg_statemachine(struct otg_fsm *fsm)
 		break;
 	case OTG_STATE_A_WAIT_VRISE:
 		if (fsm->id || fsm->a_bus_drop || fsm->a_vbus_vld ||
-		    fsm->a_wait_vrise_tmout) {
+				fsm->a_wait_vrise_tmout) {
 			otg_set_state(fsm, OTG_STATE_A_WAIT_BCON);
 		}
 		break;
 	case OTG_STATE_A_WAIT_BCON:
 		if (!fsm->a_vbus_vld)
 			otg_set_state(fsm, OTG_STATE_A_VBUS_ERR);
-		else if (fsm->id | fsm->a_bus_drop | fsm->a_wait_bcon_tmout)
-			otg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);
 		else if (fsm->b_conn)
 			otg_set_state(fsm, OTG_STATE_A_HOST);
+		else if (fsm->id | fsm->a_bus_drop | fsm->a_wait_bcon_tmout)
+			otg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);
 		break;
 	case OTG_STATE_A_HOST:
 		if ((!fsm->a_bus_req || fsm->a_suspend_req) &&
-		    fsm->transceiver->host->b_hnp_enable)
+				fsm->transceiver->host->b_hnp_enable)
 			otg_set_state(fsm, OTG_STATE_A_SUSPEND);
 		else if (fsm->id || !fsm->b_conn || fsm->a_bus_drop)
 			otg_set_state(fsm, OTG_STATE_A_WAIT_BCON);
@@ -364,7 +354,7 @@ int otg_statemachine(struct otg_fsm *fsm)
 		break;
 	case OTG_STATE_A_WAIT_VFALL:
 		if (fsm->id || fsm->a_bus_req || (!fsm->a_sess_vld &&
-						  !fsm->b_conn))
+					!fsm->b_conn))
 			otg_set_state(fsm, OTG_STATE_A_IDLE);
 		break;
 	case OTG_STATE_A_VBUS_ERR:
@@ -376,6 +366,6 @@ int otg_statemachine(struct otg_fsm *fsm)
 	}
 	spin_unlock_irqrestore(&fsm->lock, flags);
 
+	/*	VDBG("quit statemachine, changed = %d \n", state_changed); */
 	return state_changed;
 }
-EXPORT_SYMBOL(otg_statemachine);
diff --git a/drivers/usb/otg/otg_fsm.h b/drivers/usb/otg/otg_fsm.h
index e90ed31..db0661e 100644
--- a/drivers/usb/otg/otg_fsm.h
+++ b/drivers/usb/otg/otg_fsm.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2006-2007 Freescale Semiconductor, Inc.
+/* Copyright (C) 2006-2008 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -15,17 +15,14 @@
  * 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#ifndef OTG_FSM_H
-#define OTG_FSM_H
-
 #if 0
 #define DEBUG 	1
-#define VERBOSE 	1
+#define VERBOSE	1
 #endif
 
 #ifdef DEBUG
-#define DBG(fmt, args...) 	printk(KERN_DEBUG "[%s]  " fmt , \
-				__FUNCTION__, ## args)
+#define DBG(fmt, args...) printk(KERN_DEBUG "[%s]  " fmt , \
+				 __func__, ## args)
 #else
 #define DBG(fmt, args...)	do {} while (0)
 #endif
@@ -42,13 +39,9 @@
 #define MPC_LOC do {} while (0)
 #endif
 
-#define PROTO_UNDEF	0
-#define PROTO_HOST	1
-#define PROTO_GADGET	2
-
-
-
-
+#define PROTO_UNDEF	(0)
+#define PROTO_HOST	(1)
+#define PROTO_GADGET	(2)
 
 /* OTG state machine according to the OTG spec */
 struct otg_fsm {
@@ -93,24 +86,16 @@ struct otg_fsm {
 	struct otg_fsm_ops *ops;
 	struct otg_transceiver *transceiver;
 
-	void *a_wait_vrise_tmr;
-	void *a_wait_bcon_tmr;
-	void *a_aidl_bdis_tmr;
-	void *b_ase0_brst_tmr;
-	void *b_se0_srp_tmr;
-	void *b_srp_fail_tmr;
-	void *a_wait_enum_tmr;
-
 	/* Current usb protocol used: 0:undefine; 1:host; 2:client */
 	int protocol;
-	spinlock_t lock;		/* fsm lock */
+	spinlock_t lock;
 };
 
 struct otg_fsm_ops {
-	void 	(*chrg_vbus)(int on);
-	void 	(*drv_vbus)(int on);
-	void 	(*loc_conn)(int on);
-	void 	(*loc_sof)(int on);
+	void	(*chrg_vbus)(int on);
+	void	(*drv_vbus)(int on);
+	void	(*loc_conn)(int on);
+	void	(*loc_sof)(int on);
 	void	(*start_pulse)(void);
 	void	(*add_timer)(void *timer);
 	void	(*del_timer)(void *timer);
@@ -163,8 +148,4 @@ static inline void otg_del_timer(struct otg_fsm *fsm, void *timer)
 	fsm->ops->del_timer(timer);
 }
 
-extern int otg_statemachine(struct otg_fsm *fsm);
-
-extern const char *state_string(enum usb_otg_state state);
-
-#endif
+int otg_statemachine(struct otg_fsm *fsm);
diff --git a/drivers/usb/otg/usb.c b/drivers/usb/otg/usb.c
new file mode 100644
index 0000000..ab8f3fd
--- /dev/null
+++ b/drivers/usb/otg/usb.c
@@ -0,0 +1,76 @@
+/* Copyright (C) 2007,2008 Freescale Semiconductor, Inc.
+ *
+ * Author: Li Yang <LeoLi@freescale.com>
+ *         Jerry Huang <Chang-Ming.Huang@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/usb/otg.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+
+
+static struct otg_transceiver *transceiver;
+static struct resource *otg_resources;
+
+/*
+ * otg_get_transceiver - find the (single) OTG transceiver driver
+ *
+ * Returns the transceiver driver, after getting a refcount to it; or
+ * null if there is no such transceiver.  The caller is responsible for
+ * releasing that count.
+ */
+struct otg_transceiver *otg_get_transceiver(void)
+{
+	pr_debug("%s transceiver=0x%p\n", __FUNCTION__, transceiver);
+	if (transceiver)
+		get_device(transceiver->dev);
+
+	return transceiver;
+}
+EXPORT_SYMBOL(otg_get_transceiver);
+
+int otg_set_transceiver(struct otg_transceiver *otg)
+{
+	if (transceiver && otg)
+		return -EBUSY;
+
+	transceiver = otg;
+
+	return 0;
+}
+EXPORT_SYMBOL(otg_set_transceiver);
+
+struct resource *otg_get_resources(void)
+{
+	return otg_resources;
+}
+EXPORT_SYMBOL(otg_get_resources);
+
+int otg_set_resources(struct resource *resources)
+{
+	otg_resources = resources;
+	return 0;
+}
+EXPORT_SYMBOL(otg_set_resources);
-- 
1.6.0.1

