From 5680fad3d55bba877f4b3e66e37891ca873115c6 Mon Sep 17 00:00:00 2001
From: Kurt Mahan <kmahan@freescale.com>
Date: Thu, 25 Sep 2008 14:37:19 -0600
Subject: [PATCH] Finish update to EDMA.

LTIBName: m5445x-edma-cleanup
Signed-off-by: Kurt Mahan <kmahan@freescale.com>
---
 drivers/spi/coldfire_edma.c      |  446 --------------------------------------
 include/asm-m68k/coldfire_edma.h |  125 -----------
 include/asm-m68k/mcf_edma.h      |    9 +
 sound/mcf/mcf_ssi_audio.c        |    1 -
 4 files changed, 9 insertions(+), 572 deletions(-)
 delete mode 100644 drivers/spi/coldfire_edma.c
 delete mode 100644 include/asm-m68k/coldfire_edma.h

diff --git a/drivers/spi/coldfire_edma.c b/drivers/spi/coldfire_edma.c
deleted file mode 100644
index a1e09ef..0000000
--- a/drivers/spi/coldfire_edma.c
+++ /dev/null
@@ -1,446 +0,0 @@
-/*
- *
- * coldfire_edma.c - eDMA driver for Coldfire MCF5445x
- *
- * Yaroslav Vinogradov yaroslav.vinogradov@freescale.com
- *
- * Copyright Freescale Semiconductor, Inc. 2007
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <asm/virtconvert.h>
-#include <asm/coldfire.h>
-#include <linux/fs.h>
-#include <linux/cdev.h>
-#include <linux/seq_file.h>
-#include <linux/proc_fs.h>
-#ifdef CONFIG_M5445X
-#include <asm/mcf5445x_edma.h>
-#include <asm/mcf5445x_intc.h>
-#endif /* CONFIG_M5445X */
-#include <asm/coldfire_edma.h>
-
-/*
- * Callback handler data for each TCD
- */
-struct edma_isr_record {
-	edma_irq_handler irq_handler;	  /* interrupt handler */
-	edma_error_handler error_handler; /* error interrupt handler */
-	void *arg;			  /* argument to pass back */
-	int allocated;			  /* busy flag */
-	spinlock_t *lock;		  /* spin lock (optional) */
-	const char *device_id;		  /* dev id string, used in procfs */
-};
-
-/*
- * Device structure
- */
-struct coldfire_edma_dev {
-	struct cdev cdev;		  /* character device */
-	struct edma_isr_record dma_interrupt_handlers[EDMA_CHANNELS];
-};
-
-/* allocated major device number */
-static int coldfire_dma_major;
-
-/* device driver structure */
-static struct coldfire_edma_dev *devp = NULL;
-
-/* device driver file operations */
-struct file_operations coldfire_edma_fops = {
-	.owner = THIS_MODULE,
-};
-
-/**
- * dmaisr - eDMA channel interrupt handler
- * @irq: interrupt number
- * @dev_id: argument
- */
-static int dmaisr(int irq, void *dev_id)
-{
-	int channel = irq - EDMA_INT_CONTROLLER_BASE - EDMA_INT_CHANNEL_BASE;
-	int result = IRQ_HANDLED;
-
-	if ((devp != NULL) &&
-	    (devp->dma_interrupt_handlers[channel].irq_handler)) {
-		/* call user irq handler */
-		if (devp->dma_interrupt_handlers[channel].lock)
-			spin_lock(devp->dma_interrupt_handlers[channel].lock);
-
-		result = devp->dma_interrupt_handlers[channel].irq_handler(
-			channel, devp->dma_interrupt_handlers[channel].arg);
-
-   		if (devp->dma_interrupt_handlers[channel].lock)
-			spin_unlock(devp->dma_interrupt_handlers[channel].lock);
-	} else {
-		/* no irq handler so just ack it */
-		confirm_edma_interrupt_handled(channel);
-		printk(EDMA_DRIVER_NAME ": No handler for DMA channel %d\n",
-		       channel);
-	}
-
-	return result;
-}
-
-/**
- * dma_error_isr - eDMA error interrupt handler
- * @irq: interrupt number
- * @dev_id: argument
- */
-static int dma_error_isr(int irq, void* dev_id)
-{
-	u16 err;
-	int i;
-
-	err = MCF_EDMA_ERR;
-	for (i=0; i<EDMA_CHANNELS; i++) {
-		if (err & (1<<i)) {
-			if (devp!=NULL && devp->dma_interrupt_handlers[i].error_handler)
-				devp->dma_interrupt_handlers[i].error_handler(i, devp->dma_interrupt_handlers[i].arg);
-			else
-				printk(KERN_WARNING EDMA_DRIVER_NAME ": DMA error on channel %d\n", i);
-		}
-	}
-
-	MCF_EDMA_CERR = MCF_EDMA_CERR_CAER;
-	return IRQ_HANDLED;
-}
-
-/**
- * set_edma_params - Set transfer control descriptor (TCD)
- * @channel: channel number
- * @source: source address
- * @dest: destination address
- * @attr: attributes
- * @soff: source offset
- * @nbytes: number of bytes to be transfered in minor loop
- * @slast: last source address adjustment
- * @citer: major loop count
- * @biter: beginning minor loop count
- * @doff: destination offset
- * @dlast_sga: last destination address adjustment
- * @major_int: generate interrupt after each major loop
- * @disable_req: disable DMA request after major loop
- */
-void set_edma_params(int channel, u32 source, u32 dest,
-	u32 attr, u32 soff, u32 nbytes, u32 slast,
-	u32 citer, u32 biter, u32 doff, u32 dlast_sga,
-	int major_int, int disable_req)
-{
-
-	if (channel<0 || channel>EDMA_CHANNELS)
-		return;
-
-	MCF_EDMA_TCD_SADDR(channel) = source;
-	MCF_EDMA_TCD_DADDR(channel) = dest;
-	MCF_EDMA_TCD_ATTR(channel) = attr;
-	MCF_EDMA_TCD_SOFF(channel) = MCF_EDMA_TCD_SOFF_SOFF(soff);
-	MCF_EDMA_TCD_NBYTES(channel) = MCF_EDMA_TCD_NBYTES_NBYTES(nbytes);
-	MCF_EDMA_TCD_SLAST(channel) = MCF_EDMA_TCD_SLAST_SLAST(slast);
-	MCF_EDMA_TCD_CITER(channel) = MCF_EDMA_TCD_CITER_CITER(citer);
-	MCF_EDMA_TCD_BITER(channel)=MCF_EDMA_TCD_BITER_BITER(biter);
-	MCF_EDMA_TCD_DOFF(channel) = MCF_EDMA_TCD_DOFF_DOFF(doff);
-	MCF_EDMA_TCD_DLAST_SGA(channel) = MCF_EDMA_TCD_DLAST_SGA_DLAST_SGA(dlast_sga);
-
-	/* interrupt at the end of major loop */
-	if (major_int)
-		MCF_EDMA_TCD_CSR(channel) |= MCF_EDMA_TCD_CSR_INT_MAJOR;
-	else
-		MCF_EDMA_TCD_CSR(channel) &= ~MCF_EDMA_TCD_CSR_INT_MAJOR;
-
-	/* disable request at the end of major loop of transfer or not*/
-	if (disable_req)
-		MCF_EDMA_TCD_CSR(channel) |= MCF_EDMA_TCD_CSR_D_REQ;
-	else
-		MCF_EDMA_TCD_CSR(channel) &= ~MCF_EDMA_TCD_CSR_D_REQ;
-}
-EXPORT_SYMBOL(set_edma_params);
-
-/**
- * init_edma - Initialize the eDMA controller
- */
-void init_edma(void)
-{
-	MCF_EDMA_CR = 0;
-}
-EXPORT_SYMBOL(init_edma);
-
-/**
- * request_edma_channel - Request an eDMA channel
- * @channel: channel number
- * @handler: dma handler
- * @error_handler: dma error handler
- * @arg: argument to pass back
- * @lock: optional spinlock to hold over interrupt
- * @device_id: device id
- *
- * Returns 0 if success or a negative value if failure
- */
-int request_edma_channel(int channel,
-	edma_irq_handler handler,
-	edma_error_handler error_handler,
-	void *arg,
-	spinlock_t *lock,
-	const char *device_id )
-{
-	if (devp!=NULL && channel>=0 && channel<=EDMA_CHANNELS) {
-		if (devp->dma_interrupt_handlers[channel].allocated)
-			return -EBUSY;
-
-		devp->dma_interrupt_handlers[channel].allocated = 1;
-		devp->dma_interrupt_handlers[channel].irq_handler = handler;
-		devp->dma_interrupt_handlers[channel].error_handler = error_handler;
-		devp->dma_interrupt_handlers[channel].arg = arg;
-		devp->dma_interrupt_handlers[channel].lock = lock;
-		devp->dma_interrupt_handlers[channel].device_id = device_id;
-		return 0;
-	}
-	return -EINVAL;
-}
-EXPORT_SYMBOL(request_edma_channel);
-
-/**
- * set_edma_callback - Update the channel callback/arg
- * @channel: channel number
- * @handler: dma handler
- * @error_handler: dma error handler
- * @arg: argument to pass back
- *
- * Returns 0 if success or a negative value if failure
- */
-int set_edma_callback(int channel,
-	edma_irq_handler handler,
-	edma_error_handler error_handler,
-	void *arg )
-{
-	if (devp!=NULL && channel>=0 && channel<=EDMA_CHANNELS &&
-	    devp->dma_interrupt_handlers[channel].allocated) {
-		devp->dma_interrupt_handlers[channel].irq_handler = handler;
-		devp->dma_interrupt_handlers[channel].error_handler = error_handler;
-		devp->dma_interrupt_handlers[channel].arg = arg;
-		return 0;
-	}
-	return -EINVAL;
-}
-EXPORT_SYMBOL(set_edma_callback);
-
-/**
- * free_edma_channel - Free the edma channel
- * @channel: channel number
- * @arg: argument created with
- *
- * Returns 0 if success or a negative value if failure
- */
-int free_edma_channel(int channel, void *arg)
-{
-	if (devp!=NULL && channel>=0 && channel<=EDMA_CHANNELS) {
-		if (devp->dma_interrupt_handlers[channel].allocated) {
-#if 0
-			if (devp->dma_interrupt_handlers[channel].arg != arg)
-				return -EBUSY;
-#endif
-
-			devp->dma_interrupt_handlers[channel].allocated = 0;
-			devp->dma_interrupt_handlers[channel].arg = NULL;
-			devp->dma_interrupt_handlers[channel].irq_handler = NULL;
-			devp->dma_interrupt_handlers[channel].error_handler = NULL;
-			devp->dma_interrupt_handlers[channel].lock = NULL;
-		}
-		return 0;
-	}
-	return -EINVAL;
-}
-EXPORT_SYMBOL(free_edma_channel);
-
-/**
- * coldfire_edma_cleanup - cleanup driver allocated resources
- */
-static void coldfire_edma_cleanup(void)
-{
-	dev_t devno;
-	int i;
-
-	/* free interrupts/memory */
-	if (devp) {
-		for (i=0; i<EDMA_CHANNELS; i++)
-			free_irq(EDMA_INT_BASE+i, devp);
-
-		free_irq(EDMA_INT_BASE+EDMA_INT_ERR, devp);
-		cdev_del(&devp->cdev);
-		kfree(devp);
-	}
-
-	/* unregister character device */
-	devno = MKDEV(coldfire_dma_major, 0);
-	unregister_chrdev_region(devno, 1);
-}
-
-#ifdef CONFIG_PROC_FS
-/*
- * proc file system support
- */
-
-#define FREE_CHANNEL "free"
-#define DEVICE_UNKNOWN "device unknown"
-
-/**
- * proc_edma_show - print out proc info
- * @m: seq_file
- * @v:
- */
-static int proc_edma_show(struct seq_file *m, void *v)
-{
-	int i;
-
-	if (devp == NULL)
-		return 0;
-
-	for (i = 0 ; i < EDMA_CHANNELS ; i++) {
-		if (devp->dma_interrupt_handlers[i].allocated) {
-			if (devp->dma_interrupt_handlers[i].device_id)
-		    		seq_printf(m, "%2d: %s\n", i, devp->dma_interrupt_handlers[i].device_id);
-			else
-				seq_printf(m, "%2d: %s\n", i, DEVICE_UNKNOWN);
-		} else
-			seq_printf(m, "%2d: %s\n", i, FREE_CHANNEL);
-	}
-	return 0;
-}
-
-/**
- * proc_edma_open - open the proc file
- * @inode: inode ptr
- * @file: file ptr
- */
-static int proc_edma_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, proc_edma_show, NULL);
-}
-
-static const struct file_operations proc_edma_operations = {
-	.open		= proc_edma_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-/**
- * proc_edma_init - initialize proc filesystem
- */
-static int __init proc_edma_init(void)
-{
-	struct proc_dir_entry *e;
-
-	e = create_proc_entry("edma", 0, NULL);
-	if (e)
-		e->proc_fops = &proc_edma_operations;
-
-	return 0;
-}
-
-#endif
-
-/**
- * coldfire_edma_init - eDMA module init
- */
-static int __init coldfire_edma_init(void)
-{
-	dev_t dev;
-	int result;
-	int i;
-
-	/* allocate free major number */
-	result = alloc_chrdev_region(&dev, DMA_DEV_MINOR, 1, EDMA_DRIVER_NAME);
-	if (result < 0) {
-		printk(KERN_WARNING EDMA_DRIVER_NAME": can't get major %d\n",
-		       result);
-		return result;
-	}
-	coldfire_dma_major = MAJOR(dev);
-
-	/* allocate device driver structure */
-	devp = kmalloc(sizeof(struct coldfire_edma_dev), GFP_KERNEL);
-	if (!devp) {
-		result = -ENOMEM;
-		goto fail;
-	}
-
-	/* init handlers (no handlers for beginning) */
-   	for (i = 0; i < EDMA_CHANNELS; i++) {
-		devp->dma_interrupt_handlers[i].irq_handler = NULL;
-		devp->dma_interrupt_handlers[i].error_handler = NULL;
-		devp->dma_interrupt_handlers[i].arg = NULL;
-		devp->dma_interrupt_handlers[i].allocated = 0;
-		devp->dma_interrupt_handlers[i].lock = NULL;
-		devp->dma_interrupt_handlers[i].device_id = NULL;
-	}
-
-	/* register char device */
-	cdev_init(&devp->cdev, &coldfire_edma_fops);
-	devp->cdev.owner = THIS_MODULE;
-	devp->cdev.ops = &coldfire_edma_fops;
-	result = cdev_add(&devp->cdev, dev, 1);
-	if (result) {
-		printk(KERN_NOTICE EDMA_DRIVER_NAME
-		       ": Error %d adding coldfire-dma device\n", result);
-		result = -ENODEV;
-		goto fail;
-	}
-
-	/* request/enable irq for each eDMA channel */
-	for (i = 0; i < EDMA_CHANNELS;i++) {
-		result = request_irq(EDMA_INT_BASE + i,
-				     dmaisr, IRQF_DISABLED,
-				     EDMA_DRIVER_NAME, devp);
-		if (result) {
-			printk(KERN_WARNING EDMA_DRIVER_NAME
-			       ": Cannot request irq %d\n",
-			       (EDMA_INT_BASE + EDMA_INT_ERR+i));
-			result = -EBUSY;
-			goto fail;
-		}
-	}
-
-	/* request error interrupt */
-	result = request_irq(EDMA_INT_BASE + EDMA_INT_ERR,
-			     dma_error_isr, IRQF_DISABLED,
-			     EDMA_DRIVER_NAME, devp);
-	if (result) {
-		printk(KERN_WARNING EDMA_DRIVER_NAME
-		       ": Cannot request irq %d\n",
-		       (EDMA_INT_BASE + EDMA_INT_ERR));
-		result = -EBUSY;
-		goto fail;
-	}
-
-#ifdef CONFIG_PROC_FS
-	proc_edma_init();
-#endif
-
-	printk(EDMA_DRIVER_NAME ": initialized successfully\n");
-	return 0;
-fail:
-	coldfire_edma_cleanup();
-	return result;
-}
-
-/**
- * coldfire_edma_exit - eDMA module exit
- */
-static void __exit coldfire_edma_exit(void)
-{
-	coldfire_edma_cleanup();
-}
-
-module_init(coldfire_edma_init);
-module_exit(coldfire_edma_exit);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Freescale Semiconductor, Inc.");
-MODULE_DESCRIPTION("eDMA library for Coldfire M5445x");
diff --git a/include/asm-m68k/coldfire_edma.h b/include/asm-m68k/coldfire_edma.h
deleted file mode 100644
index 0edaa34..0000000
--- a/include/asm-m68k/coldfire_edma.h
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * coldfire_edma.h - eDMA driver for Coldfire MCF5445x
- *
- * Yaroslav Vinogradov yaroslav.vinogradov@freescale.com
- *
- * Copyright Freescale Semiconductor, Inc. 2007
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
- */
-
-#ifndef _LINUX_COLDFIRE_DMA_H
-#define _LINUX_COLDFIRE_DMA_H
-
-#include <linux/interrupt.h>
-#include <asm/mcf5445x_edma.h>
-
-#define EDMA_DRIVER_NAME "ColdFire-eDMA"
-#define DMA_DEV_MINOR 1
-
-#ifdef CONFIG_M5445X
-#define EDMA_INT_CHANNEL_BASE 		8
-#define EDMA_INT_CONTROLLER_BASE 	64
-#define EDMA_INT_BASE			(EDMA_INT_CHANNEL_BASE + \
-					 EDMA_INT_CONTROLLER_BASE)
-#define EDMA_CHANNELS			16
-#define EDMA_INT_ERR			16	/* edma error interrupt */
-#endif /* CONFIG_M5445X */
- 
-typedef irqreturn_t (*edma_irq_handler)(int, void *);
-typedef void (*edma_error_handler)(int, void *);
- 
-/* Setup transfer control descriptor (TCD)
- *   channel - descriptor number
- *   source  - source address
- *   dest    - destination address
- *   attr    - attributes
- *   soff    - source offset
- *   nbytes  - number of bytes to be transfered in minor loop
- *   slast   - last source address adjustment
- *   citer   - major loop count
- *   biter   - begining minor loop count
- *   doff    - destination offset
- *   dlast_sga - last destination address adjustment
- *   major_int - generate interrupt after each major loop
- *   disable_req - disable DMA request after major loop
- */
-void set_edma_params(int channel, u32 source, u32 dest,
-		u32 attr, u32 soff, u32 nbytes, u32 slast,
-		u32 citer, u32 biter, u32 doff, u32 dlast_sga,
-		int major_int, int disable_req);
-
-/* Starts eDMA transfer on specified channel
- *   channel - eDMA TCD number
- */
-static inline void  start_edma_transfer(int channel)
-{
-	MCF_EDMA_SERQ = channel;
-	MCF_EDMA_SSRT = channel;
-}
-
-/* Stops eDMA transfer
- *   channel - eDMA TCD number
- */
-static inline void stop_edma_transfer(int channel)
-{
-	MCF_EDMA_CINT = channel;
-	MCF_EDMA_CERQ = channel;
-}
-
-
-/* Confirm that interrupt has been handled
- *   channel - eDMA TCD number
- */
-static inline void confirm_edma_interrupt_handled(int channel)
-{
-	MCF_EDMA_CINT = channel;
-}
- 
-/* Initialize eDMA controller */
-void init_edma(void);
- 
-/* Request eDMA channel:
- *   channel - eDMA TCD number
- *   handler - channel IRQ callback
- *   error_handler - error interrupt handler callback for channel
- *   dev - device
- *   lock - spinlock to be locked (can be NULL)
- *   device_id - device driver name for proc file system output
- */
-int request_edma_channel(int channel,
-		edma_irq_handler handler,
-		edma_error_handler error_handler,
-		void *dev,
-		spinlock_t *lock,
-		const char *device_id);
-
-/**
- * set_edma_callback - Update the channel callback/arg
- * @channel: channel number
- * @handler: dma handler
- * @error_handler: dma error handler
- * @arg: argument to pass back
- *
- * Returns 0 if success or a negative value if failure
- */
-int set_edma_callback(int channel,
-		edma_irq_handler handler,
-		edma_error_handler error_handler,
-		void *arg);
-  
-/* Free eDMA channel
- *  channel - eDMA TCD number
- *  dev - device
- */
-int free_edma_channel(int channel, void *dev);
-
-/*
- * DMA Modes
- */
-#define	DMA_MODE_READ		0
-#define DMA_MODE_WRITE		1
-#endif
diff --git a/include/asm-m68k/mcf_edma.h b/include/asm-m68k/mcf_edma.h
index 867e309..cf5ba26 100644
--- a/include/asm-m68k/mcf_edma.h
+++ b/include/asm-m68k/mcf_edma.h
@@ -56,6 +56,15 @@ mcf_edma_start_transfer(int channel)
 	MCF_EDMA_SSRT = channel;
 }
 
+/* Starts eDMA transfer on specified channel based on peripheral request
+ *   channel - eDMA TCD number
+ */
+static inline void  mcf_edma_enable_transfer(int channel)
+{
+	MCF_EDMA_SERQ = channel;
+}
+
+
 /* Stops eDMA transfer
  *   channel - eDMA TCD number
  */
diff --git a/sound/mcf/mcf_ssi_audio.c b/sound/mcf/mcf_ssi_audio.c
index b0a2a3f..bd5f0ac 100644
--- a/sound/mcf/mcf_ssi_audio.c
+++ b/sound/mcf/mcf_ssi_audio.c
@@ -57,7 +57,6 @@
 #include <linux/uaccess.h>
 #include <asm/coldfire.h>
 #if defined(CONFIG_M5445X)
-#include <asm/coldfire_edma.h>
 #include <asm/mcf5445x_ssi.h>
 #include <asm/mcf5445x_ccm.h>
 #endif
-- 
1.6.0.1

