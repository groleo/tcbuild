From 4daf60d8dcb6ac3b78811018771fc922086a54da Mon Sep 17 00:00:00 2001
From: Wang Huan <wanghuan@zch06.freescale.net>
Date: Thu, 5 Aug 2010 09:41:53 +0800
Subject: [PATCH] Add OCF/Talitos Framework for M547x and M548x 1

Add OCF/Talitos Framework for M547x and M548x in linux-2.6.29.

Signed-off-by: Shrek Wu <b16972@freescale.com>
---
 crypto/Makefile                    |    2 +-
 crypto/aes_generic.c               |    2 +-
 crypto/des_generic.c               |    2 +-
 crypto/ocf/Kconfig                 |  113 ++
 crypto/ocf/Makefile                |  171 +++
 crypto/ocf/sectest/Kconfig         |   13 +
 crypto/ocf/sectest/Makefile        |   17 +
 crypto/ocf/sectest/ocf_aes.c       |  378 ++++++
 crypto/ocf/sectest/ocf_arc4.c      |  467 ++++++++
 crypto/ocf/sectest/ocf_des.c       |  792 +++++++++++++
 crypto/ocf/talitos/Kconfig         |   21 +
 crypto/ocf/talitos/Makefile        |   13 +
 crypto/ocf/talitos/gtimer/Makefile |   13 +
 crypto/ocf/talitos/gtimer/gtimer.c |  296 +++++
 crypto/ocf/talitos/gtimer/gtimer.h |   47 +
 crypto/ocf/talitos/ktimer/Makefile |   10 +
 crypto/ocf/talitos/ktimer/ktimer.c |  312 +++++
 crypto/ocf/talitos/talitos.c       | 2285 ++++++++++++++++++++++++++++++++++++
 crypto/ocf/talitos/talitos_dev.h   |  437 +++++++
 crypto/ocf/talitos/talitos_soft.h  |   83 ++
 drivers/char/random.c              |   64 +
 drivers/crypto/geode-aes.c         |    2 +-
 drivers/crypto/hifn_795x.c         |    2 +-
 drivers/crypto/padlock-aes.c       |    2 +-
 include/crypto/aes.h               |    4 +-
 include/crypto/des.h               |   15 +-
 include/linux/miscdevice.h         |    1 +
 include/linux/pid.h                |    4 +-
 include/linux/random.h             |    6 +
 include/linux/sched.h              |    3 +
 kernel/pid.c                       |    8 +-
 kernel/signal.c                    |   12 +
 net/Kconfig                        |    4 +
 net/Makefile                       |    1 +
 net/ipv4/af_inet.c                 |   10 +
 35 files changed, 5591 insertions(+), 21 deletions(-)
 create mode 100644 crypto/ocf/Kconfig
 create mode 100644 crypto/ocf/Makefile
 create mode 100644 crypto/ocf/sectest/Kconfig
 create mode 100644 crypto/ocf/sectest/Makefile
 create mode 100644 crypto/ocf/sectest/ocf_aes.c
 create mode 100644 crypto/ocf/sectest/ocf_arc4.c
 create mode 100644 crypto/ocf/sectest/ocf_des.c
 create mode 100644 crypto/ocf/talitos/Kconfig
 create mode 100644 crypto/ocf/talitos/Makefile
 create mode 100644 crypto/ocf/talitos/gtimer/Makefile
 create mode 100644 crypto/ocf/talitos/gtimer/gtimer.c
 create mode 100644 crypto/ocf/talitos/gtimer/gtimer.h
 create mode 100644 crypto/ocf/talitos/ktimer/Makefile
 create mode 100644 crypto/ocf/talitos/ktimer/ktimer.c
 create mode 100644 crypto/ocf/talitos/talitos.c
 create mode 100644 crypto/ocf/talitos/talitos_dev.h
 create mode 100644 crypto/ocf/talitos/talitos_soft.h

diff --git a/crypto/Makefile b/crypto/Makefile
index 46b08bf..fca3594 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -78,7 +78,7 @@ obj-$(CONFIG_CRYPTO_RNG2) += rng.o
 obj-$(CONFIG_CRYPTO_RNG2) += krng.o
 obj-$(CONFIG_CRYPTO_ANSI_CPRNG) += ansi_cprng.o
 obj-$(CONFIG_CRYPTO_TEST) += tcrypt.o
-
+obj-$(CONFIG_OCF_OCF) += ocf/
 #
 # generic algorithms and the async_tx api
 #
diff --git a/crypto/aes_generic.c b/crypto/aes_generic.c
index b8b66ec..7d791d7 100644
--- a/crypto/aes_generic.c
+++ b/crypto/aes_generic.c
@@ -47,7 +47,7 @@
  * ---------------------------------------------------------------------------
  */
 
-#include <crypto/aes.h>
+#include <crypto/aes_generic.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/types.h>
diff --git a/crypto/des_generic.c b/crypto/des_generic.c
index 5bd3ee3..4d48d79 100644
--- a/crypto/des_generic.c
+++ b/crypto/des_generic.c
@@ -20,7 +20,7 @@
 #include <linux/crypto.h>
 #include <linux/types.h>
 
-#include <crypto/des.h>
+#include <crypto/des_generic.h>
 
 #define ROL(x, r) ((x) = rol32((x), (r)))
 #define ROR(x, r) ((x) = ror32((x), (r)))
diff --git a/crypto/ocf/Kconfig b/crypto/ocf/Kconfig
new file mode 100644
index 0000000..1868e6e
--- /dev/null
+++ b/crypto/ocf/Kconfig
@@ -0,0 +1,113 @@
+
+menu "OCF Configuration"
+
+config OCF_OCF
+	tristate "OCF (Open Cryptograhic Framework)"
+	help
+	  A linux port of the OpenBSD/FreeBSD crypto framework.
+
+config OCF_CRYPTODEV
+	tristate "cryptodev (user space support)"
+	depends on OCF_OCF
+	help
+	  The user space API to access crypto hardware.
+
+config OCF_RANDOMHARVEST
+	tristate "crypto random --- harvest entropy for /dev/random"
+	depends on OCF_OCF
+	help
+	  Includes code to harvest random numbers from devices that support it.
+          Currently requires patch to drivers/char/random.c
+
+config OCF_FIPS
+	tristate "enable fips RNG checks"
+	depends on OCF_OCF && OCF_RANDOMHARVEST
+	help
+	  Run all RNG provided data through a fips check before
+	  adding it /dev/random's entropy pool.
+
+config OCF_CRYPTOSOFT
+	tristate "cryptosoft (software crypto engine)"
+	depends on CRYPTO && OCF_OCF
+	help
+	  A software driver for the OCF framework that uses
+	  the kernel CryptoAPI.
+
+config OCF_CRYPTOSOFT_DEBUG_COUNTERS
+	bool "enable debug counters for cryptosoft usage"
+	depends on OCF_CRYPTOSOFT && DEBUG_FS
+	help
+	  This option adds several counters into debugfs /cryptosoft
+          that are incremented for each operation performed by software.
+	  Used for testing and debugging.
+
+config OCF_SAFE
+	tristate "safenet (HW crypto engine)"
+	depends on OCF_OCF
+	help
+	  A driver for a number of the safenet Excel crypto accelerators.
+	  Currently tested and working on the 1141 and 1741.
+
+config OCF_IXP4XX
+	tristate "IXP4xx (HW crypto engine)"
+	depends on OCF_OCF && ARM
+	help
+	  XScale IXP4xx crypto accelerator driver.  Requires the
+	  Intel Access library.
+
+config OCF_HIFN
+	tristate "Hifn Vulcan (HW crypto engine)"
+	depends on OCF_OCF
+	help
+	  OCF driver for various HIFN based crypto accelerators (VULCAN)
+	  (7951, 7955, 7956, 7751, 7811)
+
+config OCF_HIFN_PKMMAP
+	bool "Hifn Vulcan mmap interface (/dev/vulcanpk)"
+	depends on OCF_HIFN
+	help
+	  Enables direct access to the vulcan PK engine via /dev/vulcanpk.
+          Turning this on disables the OCF interface for the PK engine.
+
+config OCF_HIFN_DEBUG_COUNTERS
+	bool "enable debug counters for hifn chip usage"
+	depends on OCF_HIFN && DEBUG_FS
+	help
+	  This option adds several counters into debugfs /hifn that 
+          are incremented for each operation performed by this hardware.
+	  Used for testing and debugging.
+
+config OCF_HIFNHIPP
+	tristate "Hifn HIPP (HW packet crypto engine)"
+	depends on OCF_OCF
+	help
+	  OCF driver for various HIFN based crypto accelerators (HIPP)
+	  (7855)
+
+source "crypto/ocf/talitos/Kconfig"
+source "crypto/ocf/sectest/Kconfig"
+
+config OCF_BENCH
+	tristate "ocf-bench (HW crypto in-kernel benchmark)"
+	depends on OCF_OCF
+	help
+	  A very simple encryption test for the in-kernel interface
+	  of OCF.  Also includes code to benchmark the IXP Access library
+	  for comparison. This code is mutually exclusive with actually
+	  using OCF for IPsec or SSL.
+
+config OCF_OCFNULL
+        tristate "ocf-null (Measuring protocol chaining overhead)"
+        depends on OCF_OCF
+        help
+          A very simple implementation where everything of IPsec protocol
+          chain is processed, except for crypto operation.
+
+config OCF_PROFILE
+	bool "OCF operation profiling"
+	depends on OCF_OCF && X86_TSC
+	help
+	  Keep track of how much time is spent in each state of the OCF engine.
+          Report min/avarage/max values in /sysfs.
+
+endmenu
diff --git a/crypto/ocf/Makefile b/crypto/ocf/Makefile
new file mode 100644
index 0000000..f67d403
--- /dev/null
+++ b/crypto/ocf/Makefile
@@ -0,0 +1,171 @@
+
+ifdef obj
+my_inc_base = $(obj)
+else
+my_inc_base = .
+O_TARGET := ocfdrv.o
+endif
+
+# for SGlinux builds
+-include $(ROOTDIR)/modules/.config
+
+obj-$(CONFIG_OCF_OCF)        += $(obj-base)ocf.o
+obj-$(CONFIG_OCF_CRYPTODEV)  += $(obj-base)cryptodev.o
+obj-$(CONFIG_OCF_CRYPTOSOFT) += $(obj-base)cryptosoft/
+
+obj-$(CONFIG_OCF_SAFE)       += $(obj-base)safe/
+obj-$(CONFIG_OCF_HIFN)       += $(obj-base)hifn/
+obj-$(CONFIG_OCF_IXP4XX)     += $(obj-base)ixp4xx/
+obj-$(CONFIG_OCF_TALITOS)    += $(obj-base)talitos/
+obj-$(CONFIG_SEC_TEST)       += $(obj-base)sectest/
+obj-$(CONFIG_OCF_OCFNULL)    += $(obj-base)ocfnull/
+
+obj-$(CONFIG_OCF_BENCH)      += $(obj-base)ocf-bench.o
+obj-$(CONFIG_OCF_PROFILE)    += $(obj-base)cryptoprof.o
+
+obj-$(CONFIG_OCF_RANDOMHARVEST) += $(obj-base)random.o
+
+ifndef obj
+list-multi += ocf.o 
+export-objs += crypto.o criov.o 
+endif
+
+ocf-objs   := $(obj-base)crypto.o $(obj-base)criov.o 
+
+ifdef CONFIG_OCF_FIPS
+ocf-objs     += $(obj-base)rndtest.o
+EXTRA_CFLAGS += -DFIPS_TEST_RNG
+endif
+
+EXTRA_CFLAGS += -I$(my_inc_base)/.
+
+#
+# You will need to point this at your Intel ixp425 includes,  this portion
+# of the Makefile only really works under SGLinux with the appropriate libs
+# installed.  They can be downloaded from http://www.snapgear.org/
+#
+
+ifdef CONFIG_IXP400_LIB_2_0
+IX_XSCALE_SW = $(ROOTDIR)/modules/ixp425/ixp400-2.0/ixp400_xscale_sw
+OSAL_DIR     = $(ROOTDIR)/modules/ixp425/ixp400-2.0/ixp_osal
+
+IXP_CFLAGS = \
+	-I$(ROOTDIR)/. \
+	-I$(IX_XSCALE_SW)/src/include \
+	-I$(OSAL_DIR)/ \
+	-I$(OSAL_DIR)/os/linux/include/ \
+	-I$(OSAL_DIR)/os/linux/include/modules/ \
+	-I$(OSAL_DIR)/os/linux/include/modules/ioMem/ \
+	-I$(OSAL_DIR)/os/linux/include/modules/core/ \
+	-I$(OSAL_DIR)/os/linux/include/modules/bufferMgt/ \
+	-I$(OSAL_DIR)/os/linux/include/core/  \
+	-I$(OSAL_DIR)/os/linux/include/platforms/ \
+	-I$(OSAL_DIR)/os/linux/include/platforms/ixp400/ \
+	-I$(OSAL_DIR)/os/linux/include/platforms/ixp400/ixp425 \
+	-I$(OSAL_DIR)/os/linux/include/platforms/ixp400/ixp465 \
+	-I$(OSAL_DIR)/os/linux/include/core/ \
+	-I$(OSAL_DIR)/include/ \
+	-I$(OSAL_DIR)/include/modules/ \
+	-I$(OSAL_DIR)/include/modules/bufferMgt/ \
+	-I$(OSAL_DIR)/include/modules/ioMem/ \
+	-I$(OSAL_DIR)/include/modules/core/ \
+	-I$(OSAL_DIR)/include/platforms/ \
+	-I$(OSAL_DIR)/include/platforms/ixp400/ \
+	-I$(OSAL_DIR)/include/platforms/ixp400/ixp425 \
+	-I$(OSAL_DIR)/include/platforms/ixp400/ixp465 \
+	-I$(IX_XSCALE_SW)/src/linux \
+	-DUSE_IXP4XX_CRYPTO
+endif
+ifdef CONFIG_IXP400_LIB_1_4
+IXP_CFLAGS   = \
+	-I$(ROOTDIR)/. \
+	-I$(ROOTDIR)/modules/ixp425/ixp400-1.4/ixp400_xscale_sw/src/include \
+	-I$(ROOTDIR)/modules/ixp425/ixp400-1.4/ixp400_xscale_sw/src/linux \
+	-DUSE_IXP4XX_CRYPTO
+endif
+ifndef IXPDIR
+IXPDIR = ixp-version-is-not-supported
+endif
+
+ifeq ($(CONFIG_MACH_IXDP465),y)
+IXP_CFLAGS += -D__ixp46X
+else
+IXP_CFLAGS += -D__ixp42X
+endif
+
+CFLAGS_ixp4xx/ixp4xx.o += $(IXP_CFLAGS)
+CFLAGS_ixp4xx.o += $(IXP_CFLAGS)
+CFLAGS_ocf-bench.o += $(IXP_CFLAGS)
+
+ifdef TOPDIR
+-include $(TOPDIR)/Rules.make
+endif
+
+.PHONY: clean mrproper distclean
+clean:
+	rm -f $(obj-m) *.o *.ko .*.o.flags .*.ko.cmd .*.o.cmd .*.mod.o.cmd *.mod.c
+	rm -f */*.o */*.ko */.*.o.cmd */.*.ko.cmd */.*.mod.o.cmd */*.mod.c */.*.o.flags
+
+mrproper: clean
+	rm -f .depend
+distclean: mrproper
+
+$(obj-base)ocf.o: $(ocf-objs)
+	$(LD) -r -o $@ $(ocf-objs)
+
+.PHONY: patch
+patch:
+	REL=`date +%Y%m%d`; \
+		patch=ocf-linux-$$REL.patch; \
+		patch24=ocf-linux-24-$$REL.patch; \
+		patch26=ocf-linux-26-$$REL.patch; \
+		( \
+			find . -name Makefile; \
+			find . -name Config.in; \
+			find . -name Kconfig; \
+			find . -name README; \
+			find . -name '*.[ch]' | grep -v '.mod.c'; \
+		) | while read t; do \
+			diff -Nau /dev/null $$t | sed 's?^+++ \./?+++ linux/crypto/ocf/?'; \
+		done > $$patch; \
+		cat patches/linux-2.4.29-ocf.patch $$patch > $$patch24; \
+		cat patches/linux-2.6.11-ocf.patch $$patch > $$patch26
+
+.PHONY: tarball
+tarball:
+	REL=`date +%Y%m%d`; RELDIR=/tmp/ocf-linux-$$REL; \
+		CURDIR=`pwd`; \
+		rm -rf /tmp/ocf-linux-$$REL*; \
+		mkdir -p $$RELDIR/tools; \
+		cp README* $$RELDIR; \
+		cp patches/ss?.patch $$RELDIR; \
+		cp patches/crypto-tools.patch $$RELDIR; \
+		cp tools/[!C]* $$RELDIR/tools; \
+		cd ..; \
+		tar cvf $$RELDIR/ocf-linux.tar \
+					--exclude=CVS \
+					--exclude=.* \
+					--exclude=*.o \
+					--exclude=*.ko \
+					--exclude=*.mod.* \
+					--exclude=README* \
+					--exclude=ocf-*.patch \
+					--exclude=ocf/patches/ss?.patch \
+					--exclude=ocf/patches/crypto-tools.patch \
+					--exclude=ocf/tools \
+					ocf; \
+		gzip -9 $$RELDIR/ocf-linux.tar; \
+		cd /tmp; \
+		tar cvf ocf-linux-$$REL.tar ocf-linux-$$REL; \
+		gzip -9 ocf-linux-$$REL.tar; \
+		cd $$CURDIR/../../user; \
+		rm -rf /tmp/crypto-tools-$$REL*; \
+		tar cvf /tmp/crypto-tools-$$REL.tar \
+					--exclude=CVS \
+					--exclude=.* \
+					--exclude=*.o \
+					--exclude=cryptotest \
+					--exclude=cryptokeytest \
+					crypto-tools; \
+		gzip -9 /tmp/crypto-tools-$$REL.tar
+
diff --git a/crypto/ocf/sectest/Kconfig b/crypto/ocf/sectest/Kconfig
new file mode 100644
index 0000000..ea0aab7
--- /dev/null
+++ b/crypto/ocf/sectest/Kconfig
@@ -0,0 +1,13 @@
+#
+# SEC driver testing configuration
+#
+
+menu "SEC Test Options"
+#	depends on MPC836x_MDS
+	depends on OCF_TALITOS
+config SEC_TEST
+	tristate "SEC1.x and SEC2.x testing support"
+#	depends on 83xx
+	depends on OCF_TALITOS
+	default M
+endmenu
diff --git a/crypto/ocf/sectest/Makefile b/crypto/ocf/sectest/Makefile
new file mode 100644
index 0000000..f289223
--- /dev/null
+++ b/crypto/ocf/sectest/Makefile
@@ -0,0 +1,17 @@
+# Copyright (C) 2007 Freescale Semiconductor, Inc. All rights reserved.
+#
+# Author:Roy Zang <tie-fei.zang@freescale.com>, July, 2007
+#
+# Description:
+# 2.6 Makefile for sec device driver test
+#
+# This is free software; you can redistribute it and/or modify
+# it under the terms of  the GNU General  Public License as published by
+# the Free Software Foundation;  either version 2 of the  License, or
+# (at your option) any later version.
+#
+
+EXTRA_CFLAGS += -Icrypto/ocf
+
+obj-$(CONFIG_SEC_TEST) += ocf_des.o ocf_aes.o ocf_arc4.o
+sec2drvTest-objs := ocf_des.o
diff --git a/crypto/ocf/sectest/ocf_aes.c b/crypto/ocf/sectest/ocf_aes.c
new file mode 100644
index 0000000..8cef101
--- /dev/null
+++ b/crypto/ocf/sectest/ocf_aes.c
@@ -0,0 +1,378 @@
+/*
+ * Copyright (C) 2007-2010 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Author: Daniela Sirocchi <r52684@freescale.com>
+ * Maintainer: Olivia Yin <r63875@@freescale.com> for MPC83xxE family
+ *
+ * Description:
+ * ocftest.c - DES known-answer test for SEC2 device driver
+ *
+ * Changelog:
+ *
+ * July, 2007, Roy Zang <tie-fei.zang@freescale.com>
+ * 	- Change For MPC8544DS board SEC driver test
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of  the GNU General  Public License as published by
+ * the Free Software Foundation;  either version 2 of the  License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/uio.h>
+#include <linux/types.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/list.h>
+#include <linux/sched.h>
+#include <linux/unistd.h>
+#include <linux/module.h>
+#include <linux/wait.h>
+#include <linux/fs.h>
+#include <linux/dcache.h>
+#include <linux/file.h>
+#include <linux/version.h>
+#include <asm/uaccess.h>
+#if 0
+#include <crypto/cryptodev.h>
+#endif
+#if 1
+#include <opencrypto/crypto.h>
+#include <opencrypto/cryptodev.h>
+#endif
+
+#define AES_KEYSIZE     (24)//16 24 32
+#define AES_CTXSIZE     (8)
+#define AES_MAXTESTSIZE (1024)
+
+static const unsigned char aesData1[] = "Single block msg";
+static const unsigned char result1[] = { 
+	0xe3, 0x53, 0x77, 0x9c, 0x10, 0x79, 0xae, 0xb8,
+	0x27, 0x08, 0x94, 0x2d, 0xbe, 0x77, 0x18, 0x1a 
+};
+
+static const unsigned char aesData2[] = {
+	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
+};
+
+static const unsigned char result2[] = { 
+	0xd2, 0x96, 0xcd, 0x94, 0xc2, 0xcc, 0xcf, 0x8a,
+	0x3a, 0x86, 0x30, 0x28, 0xb5, 0xe1, 0xdc, 0x0a,
+	0x75, 0x86, 0x60, 0x2d, 0x25, 0x3c, 0xff, 0xf9,
+	0x1b, 0x82, 0x66, 0xbe, 0xa6, 0xd6, 0x1a, 0xb1 
+};
+
+static const unsigned char aesKey1[] = {
+	0x06, 0xa9, 0x21, 0x40, 0x36, 0xb8, 0xa1, 0x5b,
+       	0x51, 0x2e, 0x03, 0xd5, 0x34, 0x12, 0x00, 0x06 
+};
+
+static const unsigned char aesKey2[] = {
+	0xc2, 0x86, 0x69, 0x6d, 0x88, 0x7c, 0x9a, 0xa0,
+	0x61, 0x1b, 0xbb, 0x3e, 0x20, 0x25, 0xa4, 0x5a 
+};
+static const unsigned char iv_in1[] = { 
+	0x3d, 0xaf, 0xba, 0x42, 0x9d, 0x9e, 0xb4, 0x30,
+        0xb4, 0x22, 0xda, 0x80, 0x2c, 0x9f, 0xac, 0x41 
+};
+
+static const unsigned char iv_in2[] = { 
+	0x56, 0x2e, 0x17, 0x99, 0x6d, 0x09, 0x3d, 0x28,
+        0xdd, 0xb3, 0xba, 0x69, 0x5a, 0x2e, 0x6f, 0x58 
+};
+
+static int cryptotest_cb(void *op)
+{
+	struct cryptop *crp = (struct cryptop *) op;
+
+	printk("%s()\n", __FUNCTION__);
+	if (crp->crp_etype == EAGAIN) {
+		crp->crp_flags &= ~CRYPTO_F_DONE;
+#ifdef NOTYET
+		/*
+		 * DAVIDM I am fairly sure that we should turn this into a batch
+		 * request to stop bad karma/lockup, revisit
+		 */
+		crp->crp_flags |= CRYPTO_F_BATCH;
+#endif
+		return crypto_dispatch(crp);
+	}
+
+	wake_up_interruptible(&crp->crp_waitq);
+
+	return 0;
+}
+
+int testAes(int len, int b)
+{
+	int status=0;
+	int keybytes;
+	int ivbytes = 16;
+	struct cryptoini cri;
+	struct cryptop *crp;
+	struct cryptodesc *crd=NULL;
+	u_int64_t sid;
+	int i;
+	unsigned char *aesDecResult;
+	unsigned char *aesEncResult;
+	unsigned char *aes_key;
+
+	if (len > 1024)
+	{
+		printk("%s: test data size limit is %d\n", __FUNCTION__, AES_MAXTESTSIZE);
+		return -1;
+	}
+
+	aesDecResult = kmalloc(len, GFP_KERNEL);
+	aesEncResult = kmalloc(len, GFP_KERNEL);
+	memset(&cri, 0, sizeof(cri));
+	printk("%s: aesDecResult %x,aesEncResult %x\n", __FUNCTION__, aesDecResult, aesEncResult);
+	if (b == 0) {
+		printk("\n*** Test AES CBC *** %d size\n", len);
+		keybytes = 16;
+		cri.cri_alg = CRYPTO_AES_CBC;
+	}else {
+		printk("\n*** Test AES ECB *** %d size\n", len);
+		keybytes = 16;
+		cri.cri_alg = CRYPTO_AES_CBC;
+	}
+
+/*************************************************************/
+	/* Encrypto */
+	aes_key = kmalloc(keybytes, GFP_KERNEL);
+	if(len == 16) {
+		memcpy(aes_key, aesKey1, keybytes);
+		memcpy(aesEncResult, aesData1, len);
+	}
+	else if (len == 32) {
+		memcpy(aes_key, aesKey2, keybytes);
+                memcpy(aesEncResult, aesData2, len);
+	}
+	else {
+		printk("The test do not support the len \n");
+	}
+	cri.cri_klen= keybytes*8;
+	cri.cri_key = (caddr_t)aes_key;
+	if(len == 16) {
+		memcpy(cri.cri_iv, iv_in1, ivbytes);
+	}
+	else if(len == 32) {
+        	memcpy(cri.cri_iv, iv_in2, ivbytes);
+	}
+        else {
+                printk("The test do not support the len \n");
+        }
+
+	status = crypto_newsession(&sid, &cri, CRYPTO_ANYHARDWARE);
+	if (status) {
+		printk("%s - newsession %d\n", __FUNCTION__, status);
+		return -1;
+	}
+
+	crp = crypto_getreq(1);
+
+	if (crp == NULL) {
+		printk("%s: ENOMEM\n", __FUNCTION__);
+		status = ENOMEM;
+		return status;
+	}
+
+	crd = crp->crp_desc;
+	crd->crd_alg = cri.cri_alg;
+	crd->crd_key = cri.cri_key;
+	crd->crd_klen = cri.cri_klen;
+	crd->crd_len = len;
+	crd->crd_skip = 0;
+	memcpy(crd->crd_iv, cri.cri_iv, ivbytes);
+	crd->crd_flags |= CRD_F_ENCRYPT | CRD_F_IV_EXPLICIT | CRD_F_IV_PRESENT;
+
+	crp->crp_buf = (caddr_t)aesEncResult;
+	crp->crp_sid = sid;
+	crp->crp_ilen = len;
+	crp->crp_flags = CRYPTO_F_CBIMM;
+	crp->crp_callback = (int (*) (struct cryptop *)) cryptotest_cb;
+	status = crypto_dispatch(crp);
+	if (status == 0) {
+		printk("%s 1 about to WAIT\n", __FUNCTION__);
+		//
+		// we really need to wait for driver to complete to maintain
+		// state,  luckily interrupts will be remembered
+		//
+		do {
+			status = wait_event_interruptible(crp->crp_waitq,
+					((crp->crp_flags & CRYPTO_F_DONE) != 0));
+			//
+			// we can't break out of this loop or we will leave behind
+			// a huge mess,  however,  staying here means if your driver
+			// is broken user applications can hang and not be killed.
+			// The solution,  fix your driver :-)
+			//
+			// XXX - MCR says BS, processes should always be killable.
+			//
+			if (status) {
+				schedule();
+				status = 0;
+			}
+		} while ((crp->crp_flags & CRYPTO_F_DONE) == 0);
+		printk("%s 1 finished WAITING status=%d\n", __FUNCTION__, status);
+	}
+
+	if (crp->crp_etype != 0) {
+		status = crp->crp_etype;
+		printk("%s error in crp processing %x\n", __FUNCTION__,status);
+		return -1;
+	}
+
+	/*----------------------------------------------------------------------*/
+        if(len == 16) {
+                if ((memcmp(result1, aesEncResult, len)) == 0) {
+                        printk("*** Test AES CBC Enc Passed ***\n");
+                        status = 0;
+                } else {
+                        printk("*** Test AES CBC Enc Failed ***\n");
+                        status = -1;
+                }
+        }
+        else if(len == 32) {
+                if ((memcmp(result2, aesEncResult, len)) == 0) {
+                        printk("*** Test AES CBC Enc Passed ***\n");
+                        status = 0;
+                } else {
+                        printk("*** Test AES CBC Enc Failed ***\n");
+                        status = -1;
+                }
+        }
+        else {
+                printk("The test case do not support the Len\n");
+        }
+
+	/* Decrypto */
+	memcpy(aesDecResult, aesEncResult, len);
+	memcpy(crd->crd_iv, cri.cri_iv, ivbytes);
+	crp->crp_buf = (caddr_t)aesDecResult;
+	crd->crd_flags &= ~CRD_F_ENCRYPT;
+	crd->crd_flags |= CRD_F_IV_EXPLICIT | CRD_F_IV_PRESENT;
+	crp->crp_flags = CRYPTO_F_CBIMM;
+	status = crypto_dispatch(crp);
+	if (status == 0) {
+		printk("%s 2 about to WAIT\n", __FUNCTION__);
+		do {
+			status = wait_event_interruptible(crp->crp_waitq,
+					((crp->crp_flags & CRYPTO_F_DONE) != 0));
+			if (status) {
+				schedule();
+				status = 0;
+			}
+		} while ((crp->crp_flags & CRYPTO_F_DONE) == 0);
+		printk("%s 2 finished WAITING error=%d\n", __FUNCTION__, status);
+	}
+
+	if (crp->crp_etype != 0) {
+		status = crp->crp_etype;
+		printk("%s error in crp processing %x\n", __FUNCTION__,status);
+		return -1;
+	}
+
+	/*compare */
+	if(len == 16) {
+		if ((memcmp(aesData1, aesDecResult, len)) == 0) {
+			printk("*** Test AES CBC Dec Passed ***\n");
+			status = 0;
+		} else {
+			printk("*** Test AES CBC Dec Failed ***\n");
+			status = -1;
+		}
+	}
+	else if(len == 32) {
+                if ((memcmp(aesData2, aesDecResult, len)) == 0) {
+                        printk("*** Test AES CBC Dec Passed ***\n");
+                        status = 0;
+                } else {
+                        printk("*** Test AES CBC Dec Failed ***\n");
+                        status = -1;
+                }
+        }
+        else {
+		printk("The test case do not support the Len\n");
+	}
+
+
+	for(i=1;i<=8;i++){
+		printk("0x%x",*(aesDecResult+i));
+	//	desDecResult++;
+	}
+	printk("\n");
+	for(i=1;i<=8;i++){
+		if(len == 16) {
+                	printk("0x%x",aesData1[i]);
+        //      desDecResult++;
+                } 
+		else if (len == 32) {
+                	printk("0x%x",aesData2[i]);
+		}
+        }              
+printk("%s: aesDecResult %x,aesEncResult %x\n",__FUNCTION__,aesDecResult,aesEncResult);
+printk("\n*** Test AES CBC 1*\n");
+	kfree(aesDecResult);
+printk("\n*** Test AES CBC 2*\n");
+	kfree(aesEncResult);\
+printk("\n*** Test AES CBC 3*\n");
+	kfree(aes_key);
+	printk("\n*** Test AES CBC 4*\n");
+	crypto_freesession(sid);
+	printk("\n*** Test AES CBC Done ***\n");
+
+	return status;
+}
+
+
+/* Top level of test */
+int testAesAll(void)
+{
+	int status=0, nFails=0, nTests=0;
+
+	/* All tests complete, show status and exit */
+	if ((status = testAes(16, 1)) == 0)  /* DES (0x2.) */
+		nTests++;
+	else
+		printk("testAes(%d) Failed! %04x\n", ++nFails, status);
+
+        if ((status = testAes(32, 0)) == 0)  /* DES (0x2.) */
+                nTests++;
+        else
+                printk("testAes(%d) Failed! %04x\n", ++nFails, status);
+
+	if (nFails == 0)
+		printk("testAll(): All %d Tests Passed\n", nTests);
+	else
+		printk("Tests Passed %d, Failed %d!\n", nTests, nFails);
+
+	if (nFails)
+		return -1;
+
+	return 0;
+}
+
+static int __init sec1test_aes_init(void)
+{
+	testAesAll();
+	return 0;
+}
+
+static void __exit sec1test_aes_exit(void)
+{
+	return;
+}
+
+module_init(sec1test_aes_init);
+module_exit(sec1test_aes_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("SEC1.x driver test module");
+MODULE_AUTHOR("Freescale Semiconductor Inc.");
diff --git a/crypto/ocf/sectest/ocf_arc4.c b/crypto/ocf/sectest/ocf_arc4.c
new file mode 100644
index 0000000..c0f491c
--- /dev/null
+++ b/crypto/ocf/sectest/ocf_arc4.c
@@ -0,0 +1,467 @@
+/*
+ * Copyright (C) 2007-2010 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Author: Daniela Sirocchi <r52684@freescale.com>
+ * Maintainer: Olivia Yin <r63875@@freescale.com> for MPC83xxE family
+ *
+ * Description:
+ * ocftest.c - DES known-answer test for SEC2 device driver
+ *
+ * Changelog:
+ *
+ * July, 2007, Roy Zang <tie-fei.zang@freescale.com>
+ * 	- Change For MPC8544DS board SEC driver test
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of  the GNU General  Public License as published by
+ * the Free Software Foundation;  either version 2 of the  License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/uio.h>
+#include <linux/types.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/list.h>
+#include <linux/sched.h>
+#include <linux/unistd.h>
+#include <linux/module.h>
+#include <linux/wait.h>
+#include <linux/fs.h>
+#include <linux/dcache.h>
+#include <linux/file.h>
+#include <linux/version.h>
+#include <asm/uaccess.h>
+#if 0
+#include <crypto/cryptodev.h>
+#endif
+#if 1
+#include <opencrypto/crypto.h>
+#include <opencrypto/cryptodev.h>
+#endif
+
+#define AES_KEYSIZE     (24)//16 24 32
+#define AES_CTXSIZE     (8)
+#define AES_MAXTESTSIZE (1024)
+
+static const unsigned char RC4Data1[] = {
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef
+};
+static const unsigned char result1[] = { 
+	0x75, 0xb7, 0x87, 0x80, 0x99, 0xe0, 0xc5, 0x96
+};
+static const unsigned char arc4Key1[] = {
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef
+};
+static int arc4KeyLen1 = 8;
+
+static const unsigned char RC4Data2[] = {
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+static const unsigned char result2[] = {
+        0x74, 0x94, 0xc2, 0xe7, 0x10, 0x4b, 0x08, 0x79
+};
+static const unsigned char arc4Key2[] = {
+        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef
+};
+static int arc4KeyLen2 = 8;
+
+static const unsigned char RC4Data3[] = {
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+static const unsigned char result3[] = {
+        0xde, 0x18, 0x89, 0x41, 0xa3, 0x37, 0x5d, 0x3a
+};
+static const unsigned char arc4Key3[] = {
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+static int arc4KeyLen3 = 8;
+
+static const unsigned char RC4Data4[] = {
+	0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0,
+	0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0,
+	0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0,
+	0x12, 0x34, 0x56, 0x78
+};/*len = 28*/
+static const unsigned char result4[] = {
+	0x66, 0xa0, 0x94, 0x9f, 0x8a, 0xf7, 0xd6, 0x89,
+	0x1f, 0x7f, 0x83, 0x2b, 0xa8, 0x33, 0xc0, 0x0c,
+	0x89, 0x2e, 0xbe, 0x30, 0x14, 0x3c, 0xe2, 0x87,
+	0x40, 0x01, 0x1e, 0xcf
+};
+static const unsigned char arc4Key4[] = {
+        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef
+};
+static int arc4KeyLen4 = 8;
+
+static const unsigned char RC4Data5[] = {
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF
+};/*len = 8*/
+static const unsigned char result5[] = {
+	0x69, 0x72, 0x36, 0x59, 0x1B, 0x52, 0x42, 0xB1
+};
+static const unsigned char arc4Key5[] = {
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+static int arc4KeyLen5 = 16;
+
+static int cryptotest_cb(void *op)
+{
+	struct cryptop *crp = (struct cryptop *) op;
+
+	printk("%s()\n", __FUNCTION__);
+	if (crp->crp_etype == EAGAIN) {
+		crp->crp_flags &= ~CRYPTO_F_DONE;
+#ifdef NOTYET
+		/*
+		 * DAVIDM I am fairly sure that we should turn this into a batch
+		 * request to stop bad karma/lockup, revisit
+		 */
+		crp->crp_flags |= CRYPTO_F_BATCH;
+#endif
+		return crypto_dispatch(crp);
+	}
+
+	wake_up_interruptible(&crp->crp_waitq);
+
+	return 0;
+}
+
+int testArc4(int len, int b, int num)
+{
+	int status=0;
+	int keybytes;
+	int ivbytes = 259;
+	struct cryptoini cri;
+	struct cryptop *crp;
+	struct cryptodesc *crd=NULL;
+	u_int64_t sid;
+	int i;
+	unsigned char *arc4DecResult;
+	unsigned char *arc4EncResult;
+	unsigned char *arc4_key;
+
+	if (len > 1024)
+	{
+		printk("%s: test data size limit is %d\n", __FUNCTION__, AES_MAXTESTSIZE);
+		return -1;
+	}
+
+	arc4DecResult = kmalloc(len, GFP_KERNEL);
+	arc4EncResult = kmalloc(len, GFP_KERNEL);
+	memset(&cri, 0, sizeof(cri));
+	printk("%s: arc4DecResult %x,arc4EncResult %x\n", __FUNCTION__, arc4DecResult, arc4EncResult);
+	if (b == 0) {
+		printk("\n*** Test ARC4 ECB *** %d size, klen %d\n", len, 16);
+		keybytes = 16;
+		cri.cri_alg = CRYPTO_ARC4;
+	}else {
+		printk("\n*** Test ARC4 ECB *** %d size, klen %d\n", len, 8);
+		keybytes = 8;
+		cri.cri_alg = CRYPTO_ARC4;
+	}
+
+/*************************************************************/
+	/* Encrypto */
+	arc4_key = kmalloc(keybytes, GFP_KERNEL);
+	if (num == 1){
+		memcpy(arc4_key, arc4Key1, keybytes);
+		memcpy(arc4EncResult, RC4Data1, len);
+	}
+	else if (num == 2){
+                memcpy(arc4_key, arc4Key2, keybytes);
+                memcpy(arc4EncResult, RC4Data2, len);
+        }
+        else if (num == 3){
+                memcpy(arc4_key, arc4Key3, keybytes);
+                memcpy(arc4EncResult, RC4Data3, len);
+        }
+        else if (num == 4){
+                memcpy(arc4_key, arc4Key4, keybytes);
+                memcpy(arc4EncResult, RC4Data4, len);
+        }
+        else if (num == 5){
+                memcpy(arc4_key, arc4Key5, keybytes);
+                memcpy(arc4EncResult, RC4Data5, len);
+        }
+	else {
+		printk("ARC test do not support\n");	
+	}
+
+	cri.cri_klen= keybytes*8;
+	cri.cri_key = (caddr_t)arc4_key;
+
+	status = crypto_newsession(&sid, &cri, CRYPTO_ANYHARDWARE);
+	if (status) {
+		printk("%s - newsession %d\n", __FUNCTION__, status);
+		return -1;
+	}
+
+	crp = crypto_getreq(1);
+
+	if (crp == NULL) {
+		printk("%s: ENOMEM\n", __FUNCTION__);
+		status = ENOMEM;
+		return status;
+	}
+
+	crd = crp->crp_desc;
+	crd->crd_alg = cri.cri_alg;
+	crd->crd_key = cri.cri_key;
+	crd->crd_klen = cri.cri_klen;
+	crd->crd_len = len;
+	crd->crd_skip = 0;
+	//memcpy(crd->crd_iv, cri.cri_iv, ivbytes);
+	//crd->crd_iv = 0;
+	crd->crd_flags |= CRD_F_ENCRYPT | CRD_F_IV_EXPLICIT | CRD_F_IV_PRESENT | CRD_ARC4_FIRST;
+
+	crp->crp_buf = (caddr_t)arc4EncResult;
+	crp->crp_sid = sid;
+	crp->crp_ilen = len;
+	crp->crp_flags = CRYPTO_F_CBIMM;
+	crp->crp_callback = (int (*) (struct cryptop *)) cryptotest_cb;
+	status = crypto_dispatch(crp);
+	if (status == 0) {
+		printk("%s 1 about to WAIT\n", __FUNCTION__);
+		//
+		// we really need to wait for driver to complete to maintain
+		// state,  luckily interrupts will be remembered
+		//
+		do {
+			status = wait_event_interruptible(crp->crp_waitq,
+					((crp->crp_flags & CRYPTO_F_DONE) != 0));
+			//
+			// we can't break out of this loop or we will leave behind
+			// a huge mess,  however,  staying here means if your driver
+			// is broken user applications can hang and not be killed.
+			// The solution,  fix your driver :-)
+			//
+			// XXX - MCR says BS, processes should always be killable.
+			//
+			if (status) {
+				schedule();
+				status = 0;
+			}
+		} while ((crp->crp_flags & CRYPTO_F_DONE) == 0);
+		printk("%s 1 finished WAITING status=%d\n", __FUNCTION__, status);
+	}
+
+	if (crp->crp_etype != 0) {
+		status = crp->crp_etype;
+		printk("%s error in crp processing %x\n", __FUNCTION__,status);
+		return -1;
+	}
+
+	/*----------------------------------------------------------------------*/
+	if (num == 1) {
+		if ((memcmp(result1, arc4EncResult, len)) == 0) {
+			printk("*** Test ARC4 ECB Enc Passed ***\n");
+			status = 0;
+		} else {
+			printk("*** Test ARC4 ECB Enc Failed ***\n");
+			status = -1;
+		}
+	}
+	else if (num == 2) {
+                if ((memcmp(result2, arc4EncResult, len)) == 0) {
+                        printk("*** Test ARC4 ECB Enc Passed ***\n");
+                        status = 0;
+                } else {
+                        printk("*** Test ARC4 ECB Enc Failed ***\n");
+                        status = -1;
+		}
+        }
+        else if (num == 3) {
+                if ((memcmp(result3, arc4EncResult, len)) == 0) {
+                        printk("*** Test ARC4 ECB Enc Passed ***\n");
+                        status = 0;
+                } else {
+                        printk("*** Test ARC4 ECB Enc Failed ***\n");
+                        status = -1;
+		}
+        }
+        else if (num == 4) {
+                if ((memcmp(result4, arc4EncResult, len)) == 0) {
+                        printk("*** Test ARC4 ECB Enc Passed ***\n");
+                        status = 0;
+                } else {
+                        printk("*** Test ARC4 ECB Enc Failed ***\n");
+                        status = -1;
+		}
+        }
+        else if (num == 5) {
+                if ((memcmp(result5, arc4EncResult, len)) == 0) {
+                        printk("*** Test ARC4 ECB Enc Passed ***\n");
+                        status = 0;
+                } else {
+                        printk("*** Test ARC4 ECB Enc Failed ***\n");
+                        status = -1;
+		}
+        }
+
+        for(i=1;i<=8;i++){
+                printk("0x%x ",*(arc4EncResult+i));
+        }
+	printk("\n");
+	//memcpy(cri.cri_iv, crd->crd_iv, ivbytes);
+	/************************8 Decrypto *****************************/
+	memcpy(arc4DecResult, arc4EncResult, len);
+	//memcpy(crd->crd_iv, cri.cri_iv, ivbytes);
+	//crd->crd_iv = NULL;
+	crd->crd_next = 0;
+	crp->crp_buf = (caddr_t)arc4DecResult;
+	crd->crd_flags &= ~CRD_F_ENCRYPT;
+	crd->crd_flags |= CRD_F_IV_EXPLICIT | CRD_F_IV_PRESENT | CRD_ARC4_FIRST;
+	crp->crp_flags = CRYPTO_F_CBIMM;
+	status = crypto_dispatch(crp);
+	if (status == 0) {
+		printk("%s 2 about to WAIT\n", __FUNCTION__);
+		do {
+			status = wait_event_interruptible(crp->crp_waitq,
+					((crp->crp_flags & CRYPTO_F_DONE) != 0));
+			if (status) {
+				schedule();
+				status = 0;
+			}
+		} while ((crp->crp_flags & CRYPTO_F_DONE) == 0);
+		printk("%s 2 finished WAITING error=%d\n", __FUNCTION__, status);
+	}
+
+	if (crp->crp_etype != 0) {
+		status = crp->crp_etype;
+		printk("%s error in crp processing %x\n", __FUNCTION__,status);
+		return -1;
+	}
+
+	/*compare */
+	if (num == 1) {
+		if ((memcmp(RC4Data1, arc4DecResult, len)) == 0) {
+			printk("*** Test ARC4 ECB Dec Passed ***\n");
+			status = 0;
+		} else {
+			printk("*** Test AES ECB Dec Failed ***\n");
+			status = -1;
+		}
+	}
+        else if (num == 2) {
+                if ((memcmp(RC4Data2, arc4DecResult, len)) == 0) {
+                        printk("*** Test ARC4 ECB Dec Passed ***\n");
+                        status = 0;
+                } else {
+                        printk("*** Test AES ECB Dec Failed ***\n");
+                        status = -1;
+		}
+        }
+        else if (num == 3) {
+                if ((memcmp(RC4Data3, arc4DecResult, len)) == 0) {
+                        printk("*** Test ARC4 ECB Dec Passed ***\n");
+                        status = 0;
+                } else {
+                        printk("*** Test AES ECB Dec Failed ***\n");
+                        status = -1;
+		}
+        }
+        else if (num == 4) {
+                if ((memcmp(RC4Data4, arc4DecResult, len)) == 0) {
+                        printk("*** Test ARC4 ECB Dec Passed ***\n");
+                        status = 0;
+                } else {
+                        printk("*** Test AES ECB Dec Failed ***\n");
+                        status = -1;
+		}
+        }
+        else if (num == 5) {
+                if ((memcmp(RC4Data5, arc4DecResult, len)) == 0) {
+                        printk("*** Test ARC4 ECB Dec Passed ***\n");
+                        status = 0;
+                } else {
+                        printk("*** Test AES ECB Dec Failed ***\n");
+                        status = -1;
+		}
+        }
+
+
+	for(i=1;i<=8;i++){
+		printk("0x%x",*(arc4DecResult+i));
+	//	desDecResult++;
+	}
+	printk("\n");
+	for(i=1;i<=8;i++){
+                printk("0x%x",RC4Data1[i]);
+        //      desDecResult++;
+        
+        }              
+
+	kfree(arc4DecResult);
+	kfree(arc4EncResult);
+	kfree(arc4_key);
+	crypto_freesession(sid);
+	printk("\n*** Test ARC4 ECB Done ***\n");
+
+	return status;
+}
+
+
+/* Top level of test */
+int testArc4All(void)
+{
+	int status=0, nFails=0, nTests=0;
+
+	/* All tests complete, show status and exit */
+	if ((status = testArc4(8, 1, 1)) == 0)  
+		nTests++;
+	else
+		printk("testArc4(%d) Failed! %04x\n", ++nFails, status);
+/*
+        if ((status = testArc4(8, 1, 2)) == 0)  
+                nTests++;
+        else
+                printk("testArc4(%d) Failed! %04x\n", ++nFails, status);
+
+        if ((status = testArc4(8, 1, 3)) == 0)  
+                nTests++;
+        else
+                printk("testArc4(%d) Failed! %04x\n", ++nFails, status);
+        if ((status = testArc4(28, 1, 4)) == 0)  
+                nTests++;
+        else
+                printk("testArc4(%d) Failed! %04x\n", ++nFails, status);
+        if ((status = testArc4(8, 0, 5)) == 0)  
+                nTests++;
+        else
+                printk("testArc4(%d) Failed! %04x\n", ++nFails, status);
+*/
+
+	if (nFails == 0)
+		printk("testAll(): All %d Tests Passed\n", nTests);
+	else
+		printk("Tests Passed %d, Failed %d!\n", nTests, nFails);
+
+	if (nFails)
+		return -1;
+
+	return 0;
+}
+
+static int __init sec1test_arc4_init(void)
+{
+	testArc4All();
+	return 0;
+}
+
+static void __exit sec1test_arc4_exit(void)
+{
+	return;
+}
+
+module_init(sec1test_arc4_init);
+module_exit(sec1test_arc4_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("SEC1.x driver test module");
+MODULE_AUTHOR("Freescale Semiconductor Inc.");
diff --git a/crypto/ocf/sectest/ocf_des.c b/crypto/ocf/sectest/ocf_des.c
new file mode 100644
index 0000000..0b24c79
--- /dev/null
+++ b/crypto/ocf/sectest/ocf_des.c
@@ -0,0 +1,792 @@
+/*
+ * Copyright (C) 2007-2010 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Author: Daniela Sirocchi <r52684@freescale.com>
+ * Maintainer: Olivia Yin <r63875@@freescale.com> for MPC83xxE family
+ *
+ * Description:
+ * ocftest.c - DES known-answer test for SEC2 device driver
+ *
+ * Changelog:
+ *
+ * July, 2007, Roy Zang <tie-fei.zang@freescale.com>
+ * 	- Change For MPC8544DS board SEC driver test
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of  the GNU General  Public License as published by
+ * the Free Software Foundation;  either version 2 of the  License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/uio.h>
+#include <linux/types.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/list.h>
+#include <linux/sched.h>
+#include <linux/unistd.h>
+#include <linux/module.h>
+#include <linux/wait.h>
+#include <linux/fs.h>
+#include <linux/dcache.h>
+#include <linux/file.h>
+#include <linux/version.h>
+#include <asm/uaccess.h>
+#if 0
+#include <crypto/cryptodev.h>
+#endif
+#if 1
+#include <opencrypto/crypto.h>
+#include <opencrypto/cryptodev.h>
+#endif
+
+#define DES_KEYSIZE     (24)
+#define DES_CTXSIZE     (8)
+#define DES_MAXTESTSIZE (4096)
+
+static const unsigned char desData[] = {
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde,
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
+	0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
+	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
+	0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23,
+	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
+	0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
+	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56,
+	0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67,
+	0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78,
+	0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89,
+	0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a,
+	0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab,
+	0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
+	0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd,
+	0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde
+};
+
+static const unsigned char desKey[] = {
+	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+	0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
+	0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88
+};
+
+static const unsigned char iv_in[] = "abcedf01";
+
+static int cryptotest_cb(void *op)
+{
+	struct cryptop *crp = (struct cryptop *) op;
+
+	printk("%s()\n", __FUNCTION__);
+	if (crp->crp_etype == EAGAIN) {
+		crp->crp_flags &= ~CRYPTO_F_DONE;
+#ifdef NOTYET
+		/*
+		 * DAVIDM I am fairly sure that we should turn this into a batch
+		 * request to stop bad karma/lockup, revisit
+		 */
+		crp->crp_flags |= CRYPTO_F_BATCH;
+#endif
+		return crypto_dispatch(crp);
+	}
+
+	wake_up_interruptible(&crp->crp_waitq);
+
+	return 0;
+}
+
+int testDes(int len, int b)
+{
+	int status=0;
+	int keybytes;
+	struct cryptoini cri;
+	struct cryptop *crp;
+	struct cryptodesc *crd=NULL;
+	u_int64_t sid;
+	int i;
+	unsigned char *desDecResult;
+	unsigned char *desEncResult;
+	unsigned char *des_key;
+
+	if (len > 4096)
+	{
+		printk("testDes(): test data size limit is %d\n", DES_MAXTESTSIZE);
+		return -1;
+	}
+
+	desDecResult = kmalloc(len, GFP_KERNEL);
+	desEncResult = kmalloc(len, GFP_KERNEL);
+	memset(&cri, 0, sizeof(cri));
+	/*printk("%s: desDecResult %x,desEncResult %x\n",__FUNCTION__,desDecResult,desEncResult);*/
+	if (b == 0) {
+		printk("\n*** Test 3DES CBC *** %d size\n", len);
+		keybytes = 24;
+		cri.cri_alg = CRYPTO_3DES_CBC;
+	}else {
+		printk("\n*** Test DES CBC *** %d size\n", len);
+		keybytes = 8;
+		cri.cri_alg = CRYPTO_DES_CBC;
+	}
+
+	des_key = kmalloc(keybytes, GFP_KERNEL);
+	memcpy(des_key, desKey, keybytes);
+	memcpy(desEncResult, desData, len);
+	cri.cri_klen= keybytes*8;
+	cri.cri_key = (caddr_t)des_key;
+	memcpy(cri.cri_iv, iv_in, 8);
+	status = crypto_newsession(&sid, &cri, CRYPTO_ANYHARDWARE);
+	if (status) {
+		printk("%s - newsession %d\n", __FUNCTION__, status);
+		return -1;
+	}
+
+	crp = crypto_getreq(1);
+
+	if (crp == NULL) {
+		printk("%s: ENOMEM\n", __FUNCTION__);
+		status = ENOMEM;
+		return status;
+	}
+
+	crd = crp->crp_desc;
+	crd->crd_alg = cri.cri_alg;
+	crd->crd_key = cri.cri_key;
+	crd->crd_klen = cri.cri_klen;
+	crd->crd_len = len;
+	crd->crd_skip = 0;
+	memcpy(crd->crd_iv, cri.cri_iv, 8);
+	crd->crd_flags |= CRD_F_ENCRYPT | CRD_F_IV_EXPLICIT | CRD_F_IV_PRESENT;
+
+	crp->crp_buf = (caddr_t)desEncResult;
+	crp->crp_sid = sid;
+	crp->crp_ilen = len;
+	crp->crp_flags = CRYPTO_F_CBIMM;
+	crp->crp_callback = (int (*) (struct cryptop *)) cryptotest_cb;
+	status = crypto_dispatch(crp);
+	if (status == 0) {
+		printk("%s 1 about to WAIT\n", __FUNCTION__);
+		//
+		// we really need to wait for driver to complete to maintain
+		// state,  luckily interrupts will be remembered
+		//
+		do {
+			status = wait_event_interruptible(crp->crp_waitq,
+					((crp->crp_flags & CRYPTO_F_DONE) != 0));
+			//
+			// we can't break out of this loop or we will leave behind
+			// a huge mess,  however,  staying here means if your driver
+			// is broken user applications can hang and not be killed.
+			// The solution,  fix your driver :-)
+			//
+			// XXX - MCR says BS, processes should always be killable.
+			//
+			if (status) {
+				schedule();
+				status = 0;
+			}
+		} while ((crp->crp_flags & CRYPTO_F_DONE) == 0);
+		printk("%s 1 finished WAITING status=%d\n", __FUNCTION__, status);
+	}
+
+	if (crp->crp_etype != 0) {
+		status = crp->crp_etype;
+		printk("%s error in crp processing %x\n", __FUNCTION__,status);
+		return -1;
+	}
+
+	/* Decrypto */
+	memcpy(desDecResult, desEncResult, len);
+	memcpy(crd->crd_iv, cri.cri_iv, 8);
+	crp->crp_buf = (caddr_t)desDecResult;
+	crd->crd_flags &= ~CRD_F_ENCRYPT;
+	crd->crd_flags |= CRD_F_IV_EXPLICIT | CRD_F_IV_PRESENT;
+	crp->crp_flags = CRYPTO_F_CBIMM;
+	status = crypto_dispatch(crp);
+	if (status == 0) {
+		printk("%s 2 about to WAIT\n", __FUNCTION__);
+		do {
+			status = wait_event_interruptible(crp->crp_waitq,
+					((crp->crp_flags & CRYPTO_F_DONE) != 0));
+			if (status) {
+				schedule();
+				status = 0;
+			}
+		} while ((crp->crp_flags & CRYPTO_F_DONE) == 0);
+		printk("%s 2 finished WAITING error=%d\n", __FUNCTION__, status);
+	}
+
+	if (crp->crp_etype != 0) {
+		status = crp->crp_etype;
+		printk("%s error in crp processing %x\n", __FUNCTION__,status);
+		return -1;
+	}
+
+	if ((memcmp(desData, desDecResult, len)) == 0) {
+		printk("*** Test DES CBC Passed ***\n");
+		status = 0;
+	} else {
+		printk("*** Test DES CBC Failed ***\n");
+		status = -1;
+	}
+
+	for(i=1;i<=8;i++){
+		printk("0x%x",*(desDecResult+i));
+	//	desDecResult++;
+	}
+printk("%s: desDecResult %x,desEncResult %x\n",__FUNCTION__,desDecResult,desEncResult);
+printk("\n*** Test DES CBC 1*\n");
+	kfree(desDecResult);
+printk("\n*** Test DES CBC 2*\n");
+	kfree(desEncResult);\
+printk("\n*** Test DES CBC 3*\n");
+	kfree(des_key);
+	printk("\n*** Test DES CBC 4*\n");
+	crypto_freesession(sid);
+	printk("\n*** Test DES CBC Done ***\n");
+
+	return status;
+}
+
+
+/* Top level of test */
+int testAll(void)
+{
+	int status=0, nFails=0, nTests=0;
+
+	/* All tests complete, show status and exit */
+	if ((status = testDes(512, 1)) == 0)  /* DES (0x2.) */
+		nTests++;
+	else
+		printk("testDes(%d) Failed! %04x\n", ++nFails, status);
+
+        if ((status = testDes(512, 0)) == 0)  /* DES (0x2.) */
+                nTests++;
+        else
+                printk("testDes(%d) Failed! %04x\n", ++nFails, status);
+
+	if (nFails == 0)
+		printk("testAll(): All %d Tests Passed\n", nTests);
+	else
+		printk("Tests Passed %d, Failed %d!\n", nTests, nFails);
+
+	if (nFails)
+		return -1;
+
+	return 0;
+}
+
+static int __init sec2test_init(void)
+{
+	testAll();
+	return 0;
+}
+
+static void __exit sec2test_exit(void)
+{
+	return;
+}
+
+module_init(sec2test_init);
+module_exit(sec2test_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("SEC2.x driver test module");
+MODULE_AUTHOR("Freescale Semiconductor Inc.");
diff --git a/crypto/ocf/talitos/Kconfig b/crypto/ocf/talitos/Kconfig
new file mode 100644
index 0000000..849d774
--- /dev/null
+++ b/crypto/ocf/talitos/Kconfig
@@ -0,0 +1,21 @@
+
+menu "Talitos Driver"
+
+config OCF_TALITOS
+	tristate "talitos (HW crypto engine)"
+	depends on OCF_OCF
+	help
+	  OCF driver for Freescale's security engine (SEC/talitos).
+
+config OCF_TALITOS_GTIMER
+	tristate "global timer used with talitos"
+	depends on OCF_TALITOS
+	help
+	  Global timer driver.
+
+config OCF_TALITOS_KTIMER
+	tristate "kernel timer used with talitos"
+	depends on OCF_TALITOS
+	help
+	  Global timer driver.
+endmenu
diff --git a/crypto/ocf/talitos/Makefile b/crypto/ocf/talitos/Makefile
new file mode 100644
index 0000000..bb1814e
--- /dev/null
+++ b/crypto/ocf/talitos/Makefile
@@ -0,0 +1,13 @@
+
+ifdef obj
+my_inc_base = $(obj)
+else
+my_inc_base = .
+O_TARGET := talitos.o
+endif
+obj-$(CONFIG_OCF_TALITOS_KTIMER)    += $(obj-base)ktimer/
+obj-$(CONFIG_OCF_TALITOS_GTIMER)    += $(obj-base)gtimer/
+obj-$(CONFIG_OCF_TALITOS)    += $(obj-base)talitos.o
+
+EXTRA_CFLAGS += -I$(my_inc_base)/.
+
diff --git a/crypto/ocf/talitos/gtimer/Makefile b/crypto/ocf/talitos/gtimer/Makefile
new file mode 100644
index 0000000..9402027
--- /dev/null
+++ b/crypto/ocf/talitos/gtimer/Makefile
@@ -0,0 +1,13 @@
+
+ifdef obj
+my_inc_base = $(obj)
+else
+my_inc_base = .
+O_TARGET := gtimer.o
+endif
+
+obj-$(CONFIG_OCF_TALITOS_GTIMER)    += $(obj-base)gtimer.o
+
+EXTRA_CFLAGS += -I$(my_inc_base)/.
+
+
diff --git a/crypto/ocf/talitos/gtimer/gtimer.c b/crypto/ocf/talitos/gtimer/gtimer.c
new file mode 100644
index 0000000..47e4c4c
--- /dev/null
+++ b/crypto/ocf/talitos/gtimer/gtimer.c
@@ -0,0 +1,296 @@
+/*
+ * Freescale SEC data structures for integration with ocf-linux
+ *
+ * Copyright 2006-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/random.h>
+#include <linux/skbuff.h>
+#include <asm/scatterlist.h>
+#include <linux/dma-mapping.h>  /* dma_map_single() */
+#include <linux/moduleparam.h>
+#include <linux/uio.h>
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15)
+#include <linux/platform_device.h>
+#endif
+
+#include <crypto/cryptodev.h>
+#include "gtimer.h"
+#include <asm/io.h>
+#define DRV_NAME "gtimer0" 
+#define GTIMER0_DEBUG
+
+static void gtimer0_test(void);
+static int  gtimer0_remove (struct platform_device *pdev);
+static inline void gtimer_write(volatile unsigned *addr, u32 val)
+{
+        /*out_be32(addr, val);*/
+	*(volatile unsigned long *)((unsigned long)addr) = val;
+}
+
+static inline u32 gtimer_read(volatile unsigned *addr)
+{
+        u32 val;
+        /*val = in_be32(addr);*/
+	val = *(volatile unsigned long *)((unsigned long)addr) ;
+        return val;
+}
+
+
+struct gtimer0_dev {
+  int (*open) (unsigned long count);
+  int (*close) (void);
+};
+
+struct gtimer0_dev gtimer_dev;
+struct gtimer0_info *tm;
+
+
+static int gtimer0_open (unsigned long count)
+{
+  
+  unsigned long v;
+  int i = 100;
+
+  /* make sure counting is disabled first 
+   * and then put down the base cnt value
+  */
+  v = gtimer_read(tm->tm_base_addr + GTIMER0_GTBCR_OFFSET);
+  v |= 0x80000000; /* disable */
+  gtimer_write(tm->tm_base_addr + GTIMER0_GTBCR_OFFSET, v);
+
+  v = gtimer_read(tm->tm_base_addr + GTIMER0_GTBCR_OFFSET);
+  v &= 0x80000000; /* clear count */
+  gtimer_write(tm->tm_base_addr + GTIMER0_GTBCR_OFFSET, v);
+
+  v = gtimer_read(tm->tm_base_addr + GTIMER0_GTBCR_OFFSET);
+  v |= count; /* base cnt */
+  gtimer_write(tm->tm_base_addr + GTIMER0_GTBCR_OFFSET, v);
+
+  /* clear the count reg just in case */
+  gtimer_write(tm->tm_base_addr + GTIMER0_GTCCR_OFFSET, 0);
+
+
+  /* now enable counting */
+  v = gtimer_read(tm->tm_base_addr + GTIMER0_GTBCR_OFFSET);
+  v &= 0x7fffffff;
+  gtimer_write(tm->tm_base_addr + GTIMER0_GTBCR_OFFSET, v);
+
+  /* poll the current count reg */
+  while (1)
+    {
+      v = gtimer_read(tm->tm_base_addr + GTIMER0_GTCCR_OFFSET);
+      //printk("cur. cnt reg = 0x%8.8x \n", v);
+      if (v & 0x80000000)
+	break;
+    }
+  printk("%s TOG bit of CCR got set ...\n", __FUNCTION__);
+
+  /* now check whether activity bit got set */
+  //#if 0
+  while (1)
+    {
+      v = gtimer_read(tm->tm_base_addr + GTIMER0_GTVPR_OFFSET);
+      printk("%s vec/pri reg = 0x%8.8x \n", __FUNCTION__, v);
+      if (v & 0x40000000)
+	break;
+    }
+  //#endif
+  
+
+}
+
+static int gtimer0_close (void)
+{
+   unsigned long *pRegRead;
+ 
+  /* make sure counting is disabled first */
+  pRegRead = (tm->tm_base_addr + GTIMER0_GTBCR_OFFSET);
+  *pRegRead |= 0x80000000; 
+
+  /* clear the base cnt register */
+  *pRegRead &= 0x80000000;
+
+}
+
+
+static irqreturn_t
+gtimer0_intr (int irq, void *arg, struct pt_regs *regs)
+{
+	/* stop counting and reload initial count value */
+	/* figure out channel# and the FF# which are outstanding */
+	/* access the queue to service those SEC req */
+	/* obtain the desc ptr for all processed req and 
+         clear their status for reuse */
+         printk("%s timer working \n", __FUNCTION__);
+  
+         gtimer_dev.close();
+
+	return IRQ_HANDLED;
+}
+
+
+
+static int  gtimer0_probe (struct platform_device *pdev) 
+{
+ 
+	struct resource *r;
+        int rc;
+	int i;
+	unsigned long offset;
+
+	tm = (struct gtimer0_info *) kmalloc(sizeof(*tm), GFP_KERNEL);
+	if (!tm)
+		return -ENOMEM;
+	memset(tm, 0, sizeof(*tm));
+
+	tm->tm_irq = -1; 
+        tm->tm_dev = pdev;
+       
+        platform_set_drvdata(tm->tm_dev, tm);
+
+	/* obtain irq for this timer */
+	tm->tm_irq = platform_get_irq(pdev, 0);
+	printk("%s IRQ number = %d \n", __FUNCTION__, tm->tm_irq);
+
+	rc = request_irq(tm->tm_irq, gtimer0_intr, 0, DRV_NAME, tm);
+	if (rc) {
+		printk(KERN_ERR DRV_NAME ": failed to hook irq %d\n", 
+			tm->tm_irq);
+		tm->tm_irq = -1;
+		goto out;
+	}
+
+        /* get the pointer to timer registers */
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+        tm->tm_base_addr = (unsigned long) ioremap(r->start, (r->end - r->start));
+	printk("%s Immr base = 0x%8.8x \n", __FUNCTION__, tm->tm_base_addr);
+	if (!tm->tm_base_addr) {
+		printk(KERN_ERR DRV_NAME ": failed to ioremap\n");
+		goto out;
+	}
+
+	/* initialize function pointers : open, close */
+	gtimer_dev.open  = gtimer0_open;
+	gtimer_dev.close = gtimer0_close;  
+
+       /* now test the module */
+	gtimer0_test();  
+
+	return 0;
+
+out:
+	gtimer0_remove(pdev);
+	return -ENOMEM;
+
+}
+
+
+
+static int  gtimer0_remove (struct platform_device *pdev) 
+{
+        struct gtimer0_info *tm = platform_get_drvdata(pdev);
+	int i;
+      
+        /* make sure timer0 counting is disabled */
+	/* clear any malloc memory */
+	/* release IRQ */
+	if (tm->tm_irq != -1)
+	  free_irq(tm->tm_irq, tm);
+	if (tm->tm_base_addr)
+       		iounmap((void *) tm->tm_base_addr);
+
+	kfree(tm);
+        return 0;
+
+}
+
+static void gtimer0_test(void)
+{
+  unsigned long count;
+
+  count = 0x7fffffff;  /* 2 sec wall clock */
+  printk("%s Kicking timer with count = %d \n", __FUNCTION__, count);
+
+  /* Kick the timer */
+  gtimer_dev.open( count);
+
+}
+
+
+/* Structure for a timer0 device driver */
+static struct platform_driver gtimer0_driver = {
+	.probe = gtimer0_probe,
+	.remove = gtimer0_remove,
+	.driver = {
+		.name = "fsl-gtimer0",
+	}
+};
+
+static int __init gtimer0_init(void)
+{
+	return platform_driver_register(&gtimer0_driver);
+}
+
+static void __exit gtimer0_exit(void)
+{
+
+	platform_driver_unregister(&gtimer0_driver);
+}
+
+module_init(gtimer0_init);
+module_exit(gtimer0_exit);
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("ahsan.kabir@freescale.com");
+MODULE_DESCRIPTION("OpenPIC Global timer driver");
+
+
+
+
+/*
+TCR = default value
+GTBCR0 = first CI=1 (disable counting), then load BASECNT = 24x3000= 9000 ticks = 0x384
+GTVPR0 = taken care of by MPC8548CDS BSP
+GTDR0 = default value
+*/
+
+
+//talitos_process ()
+//{
+
+
+	/* if chx and FF0 kick the timer */
+
+
+//}
+
diff --git a/crypto/ocf/talitos/gtimer/gtimer.h b/crypto/ocf/talitos/gtimer/gtimer.h
new file mode 100644
index 0000000..7449f5e
--- /dev/null
+++ b/crypto/ocf/talitos/gtimer/gtimer.h
@@ -0,0 +1,47 @@
+/*
+ * Freescale SEC data structures for integration with ocf-linux
+ *
+ * Copyright 2006-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Holds data specific to timer0.
+ */
+struct gtimer0_info {
+	struct platform_device	*tm_dev;	/* device backpointer */
+	unsigned long		tm_base_addr;
+	int			tm_irq;
+};
+
+
+#define FRR_OFFSET            0x1000
+
+#define TFRR_OFFSET           0x10F0
+#define GTIMER0_GTCCR_OFFSET  0x1100
+#define GTIMER0_GTBCR_OFFSET  0x1110
+#define GTIMER0_GTVPR_OFFSET  0x1120
+#define GTIMER0_GTDR_OFFSET   0x1130
+#define TCR_OFFSET            0x1300
diff --git a/crypto/ocf/talitos/ktimer/Makefile b/crypto/ocf/talitos/ktimer/Makefile
new file mode 100644
index 0000000..95fbf1e
--- /dev/null
+++ b/crypto/ocf/talitos/ktimer/Makefile
@@ -0,0 +1,10 @@
+ifdef obj
+my_inc_base = $(obj)
+else
+my_inc_base = .
+O_TARGET := ktimer.o
+endif
+
+obj-$(CONFIG_OCF_TALITOS_KTIMER)    += $(obj-base)ktimer.o
+
+EXTRA_CFLAGS += -I$(my_inc_base)/.
diff --git a/crypto/ocf/talitos/ktimer/ktimer.c b/crypto/ocf/talitos/ktimer/ktimer.c
new file mode 100644
index 0000000..c4f2d56
--- /dev/null
+++ b/crypto/ocf/talitos/ktimer/ktimer.c
@@ -0,0 +1,312 @@
+/*
+ * Freescale SEC data structures for integration with ocf-linux
+ *
+ * Copyright 2006-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/random.h>
+#include <linux/skbuff.h>
+#include <asm/scatterlist.h>
+#include <linux/dma-mapping.h>  
+#include <linux/moduleparam.h>
+#include <linux/uio.h>
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15)
+#include <linux/platform_device.h>
+#endif
+
+//#define TALITOS_SMALL_PACKET_IMPROVE
+//#define TALITOS_INTERRUPT_COALESCE 
+#define TALITOS_HDR_DONE_BITS	0xff000000
+/* This data structure used as "data" for the timer and tasklet functions */
+struct talitos_timer_data {
+	struct timer_list timer;
+	int (*kick) (unsigned long tdelay);
+	int (*stop) (void);
+        unsigned long prevjiffies;
+};
+
+extern struct talitos_timer_data ktimer_data;
+
+#ifdef TALITOS_SMALL_PACKET_IMPROVE
+extern volatile unsigned long gPending; 
+extern volatile unsigned long gPendingLoopIndex; 
+extern volatile struct cryptop		*pCryptopPending[10]; /* assuming there could */
+                                                      /* 100 req. outstanding at the max. */
+static void talitos_timer_finish_job(void);
+#endif
+
+#ifdef TALITOS_INTERRUPT_COALESCE 
+static void talitos_timer_coalesce_pending_job (void);
+extern int talitos_assign_chnfifo(u32 reset);
+extern int talitos_find_channel(int i, u32 reset, int chnum);
+struct coalesce_info {
+	u32 *pCryptopCoalesce[100]; /* pointer to cryptop struct */
+	u32 *pTalitos_hdr[100];     /* pointer to talitos header */
+	u32 how_many_pending;
+	int chnum;
+};
+extern struct coalesce_info talitos_coalesce_info;
+#endif
+
+
+
+/* function prototypes */
+static void talitos_timer_fn(unsigned long arg);
+static void talitos_kick_timer(unsigned long tdelay);
+static int talitos_stop_timer(void);
+static int talitos_init_timer(void);
+
+
+/*
+ * setup the timer data structure and initialize
+ * the kernel timer
+ */
+static int talitos_init_timer(void)
+{	
+	init_timer(&ktimer_data.timer);
+
+	#if 0
+	if( ktimer_data.timer.entry.next != NULL)
+		printk("%s entry.next is not NULL! panic...\n", __FUNCTION__);
+	else
+		printk("%s entry.next is NULL, cool ...\n", __FUNCTION__);
+	#endif
+
+
+	/* initialize function pointers */
+	ktimer_data.kick = talitos_kick_timer;
+	ktimer_data.stop = talitos_stop_timer;
+	       
+	return 0;
+}
+
+/*
+ * starting th kernel timer to count tdelay jiffies
+ * at the end of which the talitos_timer_fn will
+ * be called
+ */
+static void talitos_kick_timer(unsigned long tdelay)
+{
+	unsigned long j = jiffies;
+	//printk("%s adding the kernel timer ...\n", __FUNCTION__);
+
+	/* fill the data for our timer function */
+	ktimer_data.prevjiffies = j;
+	
+	/* register the timer */
+	ktimer_data.timer.data = &ktimer_data;
+	ktimer_data.timer.function = talitos_timer_fn;
+	ktimer_data.timer.expires = j + tdelay; /* parameter */
+
+	#if 0
+	if( ktimer_data.timer.entry.next != NULL)
+		printk("%s entry.next is not NULL! panic...\n", __FUNCTION__);
+	else
+		printk("%s entry.next is NULL, cool ...\n", __FUNCTION__);
+	#endif
+
+	add_timer(&ktimer_data.timer);
+}
+
+/*
+ * this will delete the timer
+ */
+static int talitos_stop_timer(void)
+{
+        del_timer(&ktimer_data.timer);
+}
+
+/*
+ * this is the function that is invoked after 
+ * tdelay jiffies. Its responsibility is to cleanup
+ * outstanding crypto requests to talitos
+ */
+static void talitos_timer_fn(unsigned long arg)
+{
+
+	/* before doing anything stop the timer first */
+	ktimer_data.stop();
+
+        #ifdef TALITOS_SMALL_PACKET_IMPROVE
+
+	/* finish the outstanding job */
+	talitos_timer_finish_job();
+        #endif
+
+	#ifdef TALITOS_INTERRUPT_COALESCE
+	talitos_timer_coalesce_pending_job();
+
+	#endif
+       
+}
+
+#ifdef TALITOS_SMALL_PACKET_IMPROVE
+static void talitos_timer_finish_job(void)
+{
+	unsigned long i;;
+	gPendingLoopIndex = gPending;
+	printk("%s complete...\n", __FUNCTION__);
+	for (i = 0; i < gPendingLoopIndex; i++) {
+	  if (gPending >= 100) {
+	    printk("%s panic  %d outstanding req. \n", __FUNCTION__, gPending);
+	  }
+
+	  /* AK : do the postprocessing here */
+          crypto_done(pCryptopPending[i]);
+
+	  /* AK : update the pending counter */
+	  gPending--;
+          //printk("%s gPending = %d \n", __FUNCTION__, gPending);
+	}
+
+}
+#endif
+
+#ifdef TALITOS_INTERRUPT_COALESCE
+static void talitos_timer_coalesce_pending_job (void)
+{
+	u32 num_of_pending = 0;
+	u32 num_completed = 0;
+	u32 i;
+	u32 reset;
+	int fifo_num;
+	int chnum;
+
+	/* find out how many jobs where originally submitted */
+
+	num_of_pending = talitos_coalesce_info.how_many_pending;
+
+	/* find out the number of jobs completed and for the
+	 * completed jobs call crypto_done to finish post
+	 * processing 
+	*/
+	for (i = 0; i < num_of_pending; i++) {
+		
+		/* check whether the header associated with 
+		 * this state indicates SEC completion of 
+		 * the job
+		*/
+		//if((*talitos_coalesce_info.pTalitos_hdr[i]
+		//	& TALITOS_HDR_DONE_BITS) 
+		//        == TALITOS_HDR_DONE_BITS) {
+		num_completed++;
+		crypto_done(talitos_coalesce_info.pCryptopCoalesce[i]);
+		/* now tag the descriptor as available */
+		*talitos_coalesce_info.pTalitos_hdr[i] = 0;
+		//}
+	}
+	
+	//printk(KERN_INFO "%s pending=%d, completed=%d \n", __FUNCTION__,
+	//       num_of_pending, num_completed);
+
+	/* if SEC completed all jobs then do housekeeping
+	 * work here, otherwise, kick the timer again so that 
+	 * we can come back here to complete the remainder of 
+	 * the jobs
+	*/
+	if ((num_of_pending - num_completed) == 0) {
+
+		/* do some housekeeping work */
+
+		/* reset the pending counter */
+		talitos_coalesce_info.how_many_pending = 0;
+
+		/* try to implement resetting the fifo number, there
+		   is some problem in doing this due to static defn. 
+		   of fifo number in talitos.c file. FIXME */
+		reset = 1;
+		fifo_num = talitos_assign_chnfifo(reset);
+		//if (fifo_num == -1)
+		//	printk(KERN_INFO "%s fifo num reset OK ...\n", __FUNCTION__);
+		//else
+		//	printk(KERN_INFO "%s fifo num reset not OK ...\n", __FUNCTION__);
+
+		chnum = talitos_find_channel(0, 1, (talitos_coalesce_info.chnum));
+
+	}else {
+		/* schedule the timer again so 
+		 *   that we can complete the pending
+		 *  job
+		*/
+		ktimer_data.kick(1000);
+	}
+	//printk(KERN_INFO "%s trace 5 \n", __FUNCTION__);
+
+}
+#endif
+
+/*
+ * initializes a kernel timer
+ */
+static int  talitos_ktimer_probe (void) 
+{
+        talitos_init_timer();    
+  
+}
+
+/*
+ * removes kernel timer
+ */
+static int  talitos_ktimer_remove (void) 
+{
+        /* delete kernel timer */
+        //del_timer(&data->timer);
+
+        /* now free up the timer struct */
+	printk("%s removing ktimer ...\n", __FUNCTION__);
+ 
+}
+
+
+static int __init talitos_ktimer_init(void)
+{
+	printk("%s ktimer initialized...\n", __FUNCTION__);
+        talitos_ktimer_probe();
+	
+}
+
+static void __exit talitos_ktimer_exit(void)
+{
+        talitos_ktimer_remove();
+
+}
+
+module_init(talitos_ktimer_init);
+module_exit(talitos_ktimer_exit);
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("ahsan.kabir@freescale.com");
+MODULE_DESCRIPTION("Timer for talitos driver");
+
+
+
+
diff --git a/crypto/ocf/talitos/talitos.c b/crypto/ocf/talitos/talitos.c
new file mode 100644
index 0000000..561a36f
--- /dev/null
+++ b/crypto/ocf/talitos/talitos.c
@@ -0,0 +1,2285 @@
+/*
+ * crypto/ocf/talitos/talitos.c
+ *
+ * An OCF-Linux module that uses Freescale's SEC to do the crypto.
+ * Based on crypto/ocf/hifn and crypto/ocf/safe OCF drivers
+ *
+ * Copyright (c) 2006-2010 Freescale Semiconductor, Inc.
+ *
+ * This code written by Kim A. B. Phillips <kim.phillips@freescale.com>
+ * some code copied from files with the following:
+ * Copyright (C) 2004 David McCullough <davidm@snapgear.com>
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * ---------------------------------------------------------------------------
+ *
+ * NOTES:
+ *
+ * The Freescale SEC (also known as 'talitos') resides on the
+ * internal bus, and runs asynchronous to the processor core.  It has
+ * a wide gamut of cryptographic acceleration features, including single-
+ * pass IPsec (also known as algorithm chaining).  To properly utilize 
+ * all of the SEC's performance enhancing features, further reworking 
+ * of higher level code (framework, applications) will be necessary.
+ *
+ * The following table shows which SEC version is present in which devices:
+ * 
+ * Devices       SEC version
+ *
+ * 8272, 8248    SEC 1.0
+ * 885, 875      SEC 1.2
+ * 8555E, 8541E  SEC 2.0
+ * 8349E         SEC 2.01
+ * 8548E         SEC 2.1
+ *
+ * The following table shows the features offered by each SEC version:
+ *
+ * 	                       Max.   chan-
+ * version  Bus I/F       Clock  nels  DEU AESU AFEU MDEU PKEU RNG KEU
+ *
+ * SEC 1.0  internal 64b  100MHz   4     1    1    1    1    1   1   0
+ * SEC 1.2  internal 32b   66MHz   1     1    1    0    1    0   0   0
+ * SEC 2.0  internal 64b  166MHz   4     1    1    1    1    1   1   0
+ * SEC 2.01 internal 64b  166MHz   4     1    1    1    1    1   1   0
+ * SEC 2.1  internal 64b  333MHz   4     1    1    1    1    1   1   1
+ *
+ * Each execution unit in the SEC has two modes of execution; channel and
+ * slave/debug.  This driver employs the channel infrastructure in the
+ * device for convenience.  Only the RNG is directly accessed due to the
+ * convenience of its random fifo pool.  The relationship between the
+ * channels and execution units is depicted in the following diagram:
+ *
+ *    -------   ------------
+ * ---| ch0 |---|          |
+ *    -------   |          |
+ *              |          |------+-------+-------+-------+------------
+ *    -------   |          |      |       |       |       |           |
+ * ---| ch1 |---|          |      |       |       |       |           |
+ *    -------   |          |   ------  ------  ------  ------      ------
+ *              |controller|   |DEU |  |AESU|  |MDEU|  |PKEU| ...  |RNG |
+ *    -------   |          |   ------  ------  ------  ------      ------
+ * ---| ch2 |---|          |      |       |       |       |           |
+ *    -------   |          |      |       |       |       |           |
+ *              |          |------+-------+-------+-------+------------
+ *    -------   |          |
+ * ---| ch3 |---|          |
+ *    -------   ------------
+ *
+ * Channel ch0 may drive an aes operation to the aes unit (AESU),
+ * and, at the same time, ch1 may drive a message digest operation
+ * to the mdeu. Each channel has an input descriptor FIFO, and the 
+ * FIFO can contain, e.g. on the 8541E, up to 24 entries, before a
+ * a buffer overrun error is triggered. The controller is responsible
+ * for fetching the data from descriptor pointers, and passing the 
+ * data to the appropriate EUs. The controller also writes the 
+ * cryptographic operation's result to memory. The SEC notifies 
+ * completion by triggering an interrupt and/or setting the 1st byte 
+ * of the hdr field to 0xff.
+ *
+ * TODO:
+ * o support more algorithms
+ * o support more versions of the SEC
+ * o add support for linux 2.4
+ * o scatter-gather (sg) support
+ * o add support for public key ops (PKEU)
+ * o add statistics
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/random.h>
+#include <linux/skbuff.h>
+//#include <linux/tracer.h> /* AK : tracing for perf */
+#include <asm/scatterlist.h>
+#include <linux/dma-mapping.h>  /* dma_map_single() */
+#include <linux/moduleparam.h>
+#include <linux/uio.h>
+
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15)
+#include <linux/platform_device.h>
+#endif
+#if 0
+#include <crypto/cryptodev.h>
+#endif
+#if 1
+#include <opencrypto/crypto.h>
+#include <opencrypto/cryptodev.h>
+#endif
+
+#define DRV_NAME "talitos" 
+
+#include "talitos_dev.h"
+#include "talitos_soft.h"
+#include <asm/io.h>
+#include <linux/mm.h>
+#include <asm/m5485sec.h>
+#include <asm/m5485sim.h>
+#include <asm/coldfire.h>
+#define read_random(p,l) get_random_bytes(p,l)
+
+const char talitos_driver_name[] = "Talitos OCF";
+const char talitos_driver_version[] = "0.1";
+
+static int talitos_process(void *, struct cryptop *, int);
+static int talitos_newsession(void *, u_int32_t *, struct cryptoini *);
+static int talitos_freesession(void *, u_int64_t);
+static void dump_talitos_status(struct talitos_softc *sc);
+static void skb_copy_bits_back(struct sk_buff *skb, int offset, caddr_t cp,
+								 int len);
+static int talitos_read_random(void *arg, u_int32_t *buf, int maxwords);
+static void talitos_rng_init(struct talitos_softc *sc);
+static int talitos_newsession(void *arg, u_int32_t *sidp, 
+							struct cryptoini *cri);
+static int talitos_submit(struct talitos_softc *sc, struct talitos_desc *td, 
+								int chsel);
+static int talitos_process(void *arg, struct cryptop *crp, int hint);
+static void talitos_init_device(struct talitos_softc *sc);
+static void talitos_reset_device_master(struct talitos_softc *sc);
+static void talitos_reset_device(struct talitos_softc *sc);
+
+
+static void talitos_doneprocessing(struct talitos_softc *sc, unsigned long chnum);
+static void talitos_errorprocessing(struct talitos_softc *sc, unsigned long chnum);
+static int talitos_probe(struct platform_device *pdev);
+static int talitos_remove(struct platform_device *pdev);
+
+#ifdef TALITOS_TASKLET
+static inline int talitos_inline_polling (unsigned long lock_flags);
+static inline void talitos_poll (unsigned long lock_flags);
+static ocf_iomem_t sec_base_addr;
+static u32 chnum = 0;
+static u32 fifo_num = 0;
+static void talitos_tasklet (unsigned long data);	  
+DECLARE_TASKLET(isr_talitos_tasklet, talitos_tasklet, 0);
+static LIST_HEAD(talitos_tasklet_q);
+static spinlock_t talitos_tasklet_q_lock;
+#define	TALITOS_TASKLET_Q_LOCK() \
+			({ \
+				spin_lock_irqsave(&talitos_tasklet_q_lock, r_flags); \
+				dprintk("%s,%d: RETQ_LOCK\n", __FILE__, __LINE__); \
+			 })
+#define	TALITOS_TASKLET_Q_UNLOCK() \
+			({ \
+			 	dprintk("%s,%d: RETQ_UNLOCK\n", __FILE__, __LINE__); \
+				spin_unlock_irqrestore(&talitos_tasklet_q_lock, r_flags); \
+			 })
+
+#endif /* TALITOS_TASKLET */
+
+
+static int debug = 1;
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Enable debug");
+static int coldfire_debug = 0;
+
+static inline void talitos_write(volatile unsigned *addr, u32 val)
+{
+#ifdef FSL_SEC11_MCF547X_8X
+	*(volatile unsigned long *)((unsigned long)addr) = val;
+#else
+        out_be32(addr, val);
+#endif
+}
+
+static inline u32 talitos_read(volatile unsigned *addr)
+{
+        u32 val;
+#ifdef FSL_SEC11_MCF547X_8X
+	val = *(volatile unsigned long *)((unsigned long)addr);
+#else
+        val = in_be32(addr);
+#endif
+        return val;
+}
+		
+static void dump_talitos_status(struct talitos_softc *sc)
+{
+	unsigned int v, v_hi, i, *ptr;
+#ifdef FSL_SEC11_MCF547X_8X
+        v = talitos_read(sc->sc_base_addr + TALITOS_EUACR);
+        v_hi = talitos_read(sc->sc_base_addr + TALITOS_EUACR_HI);
+        printk(KERN_INFO DRV_NAME ": EUACR          0x%08x_%08x\n", v, v_hi);
+        v = talitos_read(sc->sc_base_addr + TALITOS_EUASR);
+        v_hi = talitos_read(sc->sc_base_addr + TALITOS_EUASR_HI);
+        printk(KERN_INFO DRV_NAME ": EUASR          0x%08x_%08x\n", v, v_hi);
+
+        v = talitos_read(sc->sc_base_addr + TALITOS_DEURCR);
+        printk(KERN_INFO DRV_NAME ": DEU  Reset 0x%08x\n", v);
+        v = talitos_read(sc->sc_base_addr + TALITOS_DEUSR);
+        v_hi = talitos_read(sc->sc_base_addr + TALITOS_DEUSR_HI);
+        printk(KERN_INFO DRV_NAME ": DEU  Status 0x%08x_%08x\n", v, v_hi);
+        v = talitos_read(sc->sc_base_addr + TALITOS_DEUISR);
+        v_hi = talitos_read(sc->sc_base_addr + TALITOS_DEUISR_HI);
+        printk(KERN_INFO DRV_NAME ": DEU  ISR 0x%08x_%08x\n", v, v_hi);
+        v = talitos_read(sc->sc_base_addr + TALITOS_DEUICR);
+        v_hi = talitos_read(sc->sc_base_addr + TALITOS_DEUICR_HI);
+        printk(KERN_INFO DRV_NAME ": DEU  ICR 0x%08x_%08x\n", v, v_hi);
+
+        v = talitos_read(sc->sc_base_addr + TALITOS_AESURCR);
+        printk(KERN_INFO DRV_NAME ": AESU  Reset 0x%08x\n", v);
+        v = talitos_read(sc->sc_base_addr + TALITOS_AESUSR);
+        v_hi = talitos_read(sc->sc_base_addr + TALITOS_AESUSR_HI);
+        printk(KERN_INFO DRV_NAME ": AESU  Status 0x%08x_%08x\n", v, v_hi);
+        v = talitos_read(sc->sc_base_addr + TALITOS_AESUISR);
+        v_hi = talitos_read(sc->sc_base_addr + TALITOS_AESUISR_HI);
+        printk(KERN_INFO DRV_NAME ": AESU  ISR 0x%08x_%08x\n", v, v_hi);
+        v = talitos_read(sc->sc_base_addr + TALITOS_AESUICR);
+        v_hi = talitos_read(sc->sc_base_addr + TALITOS_AESUICR_HI);
+        printk(KERN_INFO DRV_NAME ": AESU  ICR 0x%08x_%08x\n", v, v_hi);
+
+        v = talitos_read(sc->sc_base_addr + TALITOS_MDEURCR);
+        printk(KERN_INFO DRV_NAME ": MDEU  Reset 0x%08x\n", v);
+        v = talitos_read(sc->sc_base_addr + TALITOS_MDEUSR);
+        v_hi = talitos_read(sc->sc_base_addr + TALITOS_MDEUSR_HI);
+        printk(KERN_INFO DRV_NAME ": MDEU  Status 0x%08x_%08x\n", v, v_hi);
+        v = talitos_read(sc->sc_base_addr + TALITOS_MDEUISR);
+        v_hi = talitos_read(sc->sc_base_addr + TALITOS_MDEUISR_HI);
+        printk(KERN_INFO DRV_NAME ": MDEU  ISR 0x%08x_%08x\n", v, v_hi);
+        v = talitos_read(sc->sc_base_addr + TALITOS_MDEUICR);
+        v_hi = talitos_read(sc->sc_base_addr + TALITOS_MDEUICR_HI);
+        printk(KERN_INFO DRV_NAME ": MDEU  ICR 0x%08x_%08x\n", v, v_hi);
+
+        v = talitos_read(sc->sc_base_addr + TALITOS_AFEURCR);
+        printk(KERN_INFO DRV_NAME ": AFEU  Reset 0x%08x\n", v);
+        v = talitos_read(sc->sc_base_addr + TALITOS_AFEUSR);
+        v_hi = talitos_read(sc->sc_base_addr + TALITOS_AFEUSR_HI);
+        printk(KERN_INFO DRV_NAME ": AFEU  Status 0x%08x_%08x\n", v, v_hi);
+        v = talitos_read(sc->sc_base_addr + TALITOS_AFEUISR);
+        v_hi = talitos_read(sc->sc_base_addr + TALITOS_AFEUISR_HI);
+        printk(KERN_INFO DRV_NAME ": AFEU  ISR 0x%08x_%08x\n", v, v_hi);
+        v = talitos_read(sc->sc_base_addr + TALITOS_AFEUICR);
+        v_hi = talitos_read(sc->sc_base_addr + TALITOS_AFEUICR_HI);
+        printk(KERN_INFO DRV_NAME ": AFEU  ICR 0x%08x_%08x\n", v, v_hi);
+
+        v = talitos_read(sc->sc_base_addr + TALITOS_RNGRCR);
+        printk(KERN_INFO DRV_NAME ": RNG  Reset 0x%08x\n", v);
+        v = talitos_read(sc->sc_base_addr + TALITOS_RNGSR);
+        v_hi = talitos_read(sc->sc_base_addr + TALITOS_RNGSR_HI);
+        printk(KERN_INFO DRV_NAME ": RNG  Status 0x%08x_%08x\n", v, v_hi);
+        v = talitos_read(sc->sc_base_addr + TALITOS_RNGISR);
+        v_hi = talitos_read(sc->sc_base_addr + TALITOS_RNGISR_HI);
+        printk(KERN_INFO DRV_NAME ": RNG  ISR 0x%08x_%08x\n", v, v_hi);
+        v = talitos_read(sc->sc_base_addr + TALITOS_RNGICR);
+        v_hi = talitos_read(sc->sc_base_addr + TALITOS_RNGICR_HI);
+        printk(KERN_INFO DRV_NAME ": RNG  ICR 0x%08x_%08x\n", v, v_hi);
+#endif
+	v = talitos_read(sc->sc_base_addr + TALITOS_MCR);
+	v_hi = talitos_read(sc->sc_base_addr + TALITOS_MCR_HI);
+	printk(KERN_INFO DRV_NAME ": MCR          0x%08x_%08x\n", v, v_hi);
+	v = talitos_read(sc->sc_base_addr + TALITOS_IMR);
+	v_hi = talitos_read(sc->sc_base_addr + TALITOS_IMR_HI);
+	printk(KERN_INFO DRV_NAME ": IMR          0x%08x_%08x\n", v, v_hi);
+	v = talitos_read(sc->sc_base_addr + TALITOS_ISR);
+	v_hi = talitos_read(sc->sc_base_addr + TALITOS_ISR_HI);
+	printk(KERN_INFO DRV_NAME ": ISR          0x%08x_%08x\n", v, v_hi);
+	for (i = 0; i < sc->sc_num_channels; i++) { 
+		v = talitos_read(sc->sc_base_addr + i*TALITOS_CH_OFFSET + 
+			TALITOS_CH_CDPR);
+		v_hi = talitos_read(sc->sc_base_addr + i*TALITOS_CH_OFFSET + 
+			TALITOS_CH_CDPR_HI);
+		printk(KERN_INFO DRV_NAME ": CDPR     ch%d 0x%08x_%08x\n", 
+			i, v, v_hi);
+	}
+	for (i = 0; i < sc->sc_num_channels; i++) { 
+		v = talitos_read(sc->sc_base_addr + i*TALITOS_CH_OFFSET + 
+			TALITOS_CH_CCPSR);
+		v_hi = talitos_read(sc->sc_base_addr + i*TALITOS_CH_OFFSET + 
+			TALITOS_CH_CCPSR_HI);
+		printk(KERN_INFO DRV_NAME ": CCPSR    ch%d 0x%08x_%08x\n", 
+			i, v, v_hi);
+	}
+	ptr = sc->sc_base_addr + TALITOS_CH_DESCBUF;
+	v = talitos_read(ptr++);
+	 	printk(KERN_INFO DRV_NAME 
+                        ": DESCBUF  ch0 0x%08x (tdp%02d)\n",v);
+	for (i = 0; i < 15; i++) { 
+		v = talitos_read(ptr++); v_hi = talitos_read(ptr++);
+		printk(KERN_INFO DRV_NAME 
+			": DESCBUF  ch0 0x%08x_%08x (tdp%02d)\n", 
+			v, v_hi, i);
+	}
+	return;
+
+}
+
+
+/* taken from crypto/ocf/safe/safe.c driver */
+static void
+skb_copy_bits_back(struct sk_buff *skb, int offset, caddr_t cp, int len)
+{
+	int i;
+	/*printk("%s\n",__FUNCTION__);*/
+	if (offset < skb_headlen(skb)) {
+		memcpy(skb->data + offset, cp, 
+			min_t(int, skb_headlen(skb), len));
+		len -= skb_headlen(skb);
+		cp += skb_headlen(skb);
+	}
+	offset -= skb_headlen(skb);
+	for (i = 0; len > 0 && i < skb_shinfo(skb)->nr_frags; i++) {
+		if (offset < skb_shinfo(skb)->frags[i].size) {
+			memcpy(page_address(skb_shinfo(skb)->frags[i].page) +
+					skb_shinfo(skb)->frags[i].page_offset,
+					cp, min_t(int, 
+					skb_shinfo(skb)->frags[i].size, len));
+			len -= skb_shinfo(skb)->frags[i].size;
+			cp += skb_shinfo(skb)->frags[i].size;
+		}
+		offset -= skb_shinfo(skb)->frags[i].size;
+	}
+}
+
+/* 
+ * pull random numbers off the RNG FIFO, not exceeding amount available
+ */
+static int
+talitos_read_random(void *arg, u_int32_t *buf, int maxwords)
+{
+	struct talitos_softc *sc = (struct talitos_softc *) arg;
+	int rc;
+	u_int32_t v;
+
+#ifdef FSL_SEC11_MCF547X_8X
+	struct talitos_desc *td;
+	int out_fifo = 4;
+	unsigned long r_flags;
+	int maxlen = 0, maxleft = 0;
+
+	td = &sc->sc_chnfifo[0][0].cf_desc;
+	memset(td,0, sizeof(*td));
+	memset((unsigned char*)buf,0, maxwords*4);
+
+	rc = 0 ;
+	if (maxwords <= 0){
+        	printk("%s error:len %x < 0\n",__FUNCTION__,maxwords);
+		return rc;
+	}
+	
+	maxwords = maxwords * 4;
+	if(maxwords % 4 != 0){
+		/*printk("%s error:len %x is not mutiple of 4\n",__FUNCTION__,maxwords);*/
+		maxleft = maxwords % 4;
+		maxlen  = maxwords - maxleft;
+		/*
+		printk("%s error:len %x is not mutiple of 4. left %x len %x\n"
+			,__FUNCTION__,maxwords,maxleft,maxlen); 
+		*/
+	}
+        
+        /*
+ 	* OFL is number of available 64-bit words, 
+ 	* shift and convert to a 32-bit word count
+ 	*/
+        
+	/*printk("%s SR %x. maxwords %x\n",__FUNCTION__,v,maxwords);*/
+
+        td->ptr[out_fifo].ptr = dma_map_single(NULL, (unsigned char *)buf,
+                        	maxwords, DMA_TO_DEVICE);
+        td->ptr[out_fifo].len = maxwords;
+	
+	td->hdr = 0x40000010; 
+	if (coldfire_debug)
+		dump_talitos_status(sc);
+
+	talitos_submit(sc,td,1);
+	rc = maxwords;
+	if (coldfire_debug)
+		dump_talitos_status(sc);
+        //#ifdef TALITOS_TASKLET  
+        //TALITOS_TASKLET_Q_LOCK();       
+        //list_add_tail(&sc->sc_chnfifo[0][0].desc_list , &talitos_tasklet_q);        
+        //talitos_inline_polling(r_flags);
+        //TALITOS_TASKLET_Q_UNLOCK();
+	//while(1){};
+	//#endif
+#else
+	/* check for things like FIFO underflow */
+	v = talitos_read(sc->sc_base_addr + TALITOS_RNGISR_HI);
+	if (unlikely(v)) {
+		printk(KERN_ERR DRV_NAME ": RNGISR_HI error %08x\n", v);
+		return 0;
+	}
+	/*
+	 * OFL is number of available 64-bit words, 
+	 * shift and convert to a 32-bit word count
+	 */
+	v = talitos_read(sc->sc_base_addr + TALITOS_RNGSR_HI);
+	v = (v & TALITOS_RNGSR_HI_OFL) >> (16 - 1);
+	if (maxwords > v)
+		maxwords = v;
+	for (rc = 0; rc < maxwords; rc++) {
+		buf[rc] = talitos_read(sc->sc_base_addr + 
+			TALITOS_RNG_FIFO + rc*sizeof(u_int32_t));
+	}
+	if (maxwords & 1) {
+		/* 
+		 * RNG will complain with an AE in the RNGISR
+		 * if we don't complete the pairs of 32-bit reads
+		 * to its 64-bit register based FIFO
+		 */
+		v = talitos_read(sc->sc_base_addr + 
+			TALITOS_RNG_FIFO + rc*sizeof(u_int32_t));
+	}
+#endif
+	return rc;
+}
+
+static void
+talitos_rng_init(struct talitos_softc *sc)
+{
+	u_int32_t v;
+#ifdef FSL_SEC11_MCF547X_8X
+	unsigned long time = jiffies;
+#endif
+	DPRINTF("%s()\n", __FUNCTION__);
+	/* reset RNG EU */
+#ifdef FSL_SEC11_MCF547X_8X
+        v = talitos_read(sc->sc_base_addr + TALITOS_RNGRCR);
+        v |= TALITOS_RNGRCR_SR;
+        talitos_write(sc->sc_base_addr + TALITOS_RNGRCR, v);
+        while ((talitos_read(sc->sc_base_addr + TALITOS_RNGSR)
+                & TALITOS_RNGSR_RD) == 0){
+                        /*cpu_relax();*/ /* This causes CPU lockup!!! */
+                if(jiffies - time > SEC_INIT_TIMEOUT){
+                        printk("%s fail, timeout\n",__FUNCTION__);
+                        return;
+                }
+        }
+        /*
+	* we tell the RNG to start filling the RNG FIFO
+ 	* by writing the RNGDSR 
+ 	*/
+        v = talitos_read(sc->sc_base_addr + TALITOS_RNGDSR);
+        talitos_write(sc->sc_base_addr + TALITOS_RNGDSR, v);
+        /*
+ 	* 64 bits of data will be pushed onto the FIFO every 
+	* 256 SEC cycles until the FIFO is full.  The RNG then 
+ 	* attempts to keep the FIFO full.
+ 	*/
+        v = talitos_read(sc->sc_base_addr + TALITOS_RNGISR);
+        if (v) {
+                printk(KERN_ERR DRV_NAME ": RNGISR_HI error %08x\n", v);
+                return;
+        }
+
+#else
+	v = talitos_read(sc->sc_base_addr + TALITOS_RNGRCR_HI);
+	v |= TALITOS_RNGRCR_HI_SR;
+	talitos_write(sc->sc_base_addr + TALITOS_RNGRCR_HI, v);
+	while ((talitos_read(sc->sc_base_addr + TALITOS_RNGSR_HI) 
+		& TALITOS_RNGSR_HI_RD) == 0){
+			cpu_relax(); /* This causes CPU lockup!!! */
+	}
+	/*
+	 * we tell the RNG to start filling the RNG FIFO
+	 * by writing the RNGDSR 
+	 */
+	v = talitos_read(sc->sc_base_addr + TALITOS_RNGDSR_HI);
+	talitos_write(sc->sc_base_addr + TALITOS_RNGDSR_HI, v);
+	/*
+	 * 64 bits of data will be pushed onto the FIFO every 
+	 * 256 SEC cycles until the FIFO is full.  The RNG then 
+	 * attempts to keep the FIFO full.
+	 */
+	v = talitos_read(sc->sc_base_addr + TALITOS_RNGISR_HI);
+	if (v) {
+		printk(KERN_ERR DRV_NAME ": RNGISR_HI error %08x\n", v);
+		return;
+	}
+#endif
+	/*
+	 * n.b. we need to add a FIPS test here - if the RNG is going 
+	 * to fail, it's going to fail at reset time
+	 */
+	DPRINTF("%s success\n", __FUNCTION__);
+	return;
+}
+
+/*
+ * Generate a new software session.
+ */
+static int
+talitos_newsession(void *arg, u_int32_t *sidp, struct cryptoini *cri)
+{
+	struct cryptoini *c, *encini = NULL, *macini = NULL;
+	struct talitos_softc *sc = arg;
+	struct talitos_session *ses = NULL;
+	int sesn;
+
+	DPRINTF("%s()\n", __FUNCTION__);
+	if (sidp == NULL || cri == NULL || sc == NULL) {
+		DPRINTF("%s,%d - EINVAL\n", __FILE__, __LINE__);
+		return EINVAL;
+	}
+
+	for (c = cri; c != NULL; c = c->cri_next) {
+#ifdef FSL_SEC11_MCF547X_8X
+		if(coldfire_debug)
+			DPRINTF("%s: c->cri_alg %x\n", 
+				__FUNCTION__,c->cri_alg);
+#endif
+		if (c->cri_alg == CRYPTO_MD5 ||
+		    c->cri_alg == CRYPTO_MD5_HMAC ||
+		    c->cri_alg == CRYPTO_SHA1 ||
+		    c->cri_alg == CRYPTO_SHA1_HMAC ||
+		    c->cri_alg == CRYPTO_NULL_HMAC) {
+			if (macini)
+#ifdef FSL_SEC11_MCF547X_8X
+                        {
+				if(coldfire_debug)
+					DPRINTF("%s: macini =0\n",
+                                		__FUNCTION__);
+				return EINVAL;
+			}
+#else
+				return EINVAL;
+#endif
+			macini = c;
+		} else if (c->cri_alg == CRYPTO_DES_CBC ||
+			c->cri_alg == CRYPTO_3DES_CBC ||
+			c->cri_alg == CRYPTO_AES_CBC ||
+			c->cri_alg == CRYPTO_NULL_CBC ||
+			c->cri_alg == CRYPTO_ARC4) {
+			if (encini)
+#ifdef FSL_SEC11_MCF547X_8X
+                        {
+				if(coldfire_debug)
+                                	DPRINTF("%s: encini =0\n",
+                                		__FUNCTION__);
+				return EINVAL;
+                        }
+#else
+				return EINVAL;
+#endif
+			encini = c;
+		} else {
+			DPRINTF("UNKNOWN c->cri_alg %d\n", encini->cri_alg);
+			return EINVAL;
+		}
+	}
+
+	if (encini == NULL && macini == NULL)
+#ifdef FSL_SEC11_MCF547X_8X
+        {      
+		if(coldfire_debug)
+			DPRINTF("%s encini NULL,macini NULL\n",
+				__FUNCTION__);
+		return EINVAL;
+	}
+#else
+		return EINVAL;
+#endif
+
+	if (encini) {
+#ifdef FSL_SEC11_MCF547X_8X
+		if(coldfire_debug)
+			DPRINTF("%s encini: cri_klen %x,cri_alg %x \n",
+				__FUNCTION__,encini->cri_klen,
+				encini->cri_alg);
+#endif
+		/* validate key length */
+		switch (encini->cri_alg) {
+		case CRYPTO_DES_CBC:
+			if (encini->cri_klen != 64)
+				return EINVAL;
+			break;
+		case CRYPTO_3DES_CBC:
+			if (encini->cri_klen != 192) {
+				return EINVAL;
+			}
+			break;
+		case CRYPTO_AES_CBC:
+			if (encini->cri_klen != 128 &&
+			    encini->cri_klen != 192 &&
+			    encini->cri_klen != 256)
+				return EINVAL;
+			break;
+		case CRYPTO_ARC4:
+			if ( ( encini->cri_klen < ARC4_SEC_MIN_KEY_SIZE*8 ) ||
+			( encini->cri_klen > ARC4_SEC_MAX_KEY_SIZE*8 ) ) {
+				printk("%s: ARC4 do not support the "
+					"key size %d\n", __FUNCTION__, encini->cri_klen);
+				return EINVAL;
+			}
+			else {
+				/*printk("%s: ARC4 support klen %d", __FUNCTION__, encini->cri_klen);*/
+				sc->sc_rc4_first = 1;
+			}
+			break;
+		default:
+			DPRINTF("UNKNOWN encini->cri_alg %d\n", 
+				encini->cri_alg);
+			return EINVAL;
+		}
+	}
+
+	if (sc->sc_sessions == NULL) {
+		ses = sc->sc_sessions = (struct talitos_session *)
+			kmalloc(sizeof(struct talitos_session), GFP_ATOMIC);
+		if (ses == NULL)
+			return ENOMEM;
+		memset(ses, 0, sizeof(struct talitos_session));
+		sesn = 0;
+		sc->sc_nsessions = 1;
+	} else {
+		for (sesn = 0; sesn < sc->sc_nsessions; sesn++) {
+			if (sc->sc_sessions[sesn].ses_used == 0) {
+				ses = &sc->sc_sessions[sesn];
+				break;
+			}
+		}
+
+		if (ses == NULL) {
+			/* allocating session */
+			sesn = sc->sc_nsessions;
+			ses = (struct talitos_session *) kmalloc(
+				(sesn + 1) * sizeof(struct talitos_session), 
+				GFP_ATOMIC);
+			if (ses == NULL)
+				return ENOMEM;
+			memset(ses, 0,
+				(sesn + 1) * sizeof(struct talitos_session));
+			memcpy(ses, sc->sc_sessions, 
+				sesn * sizeof(struct talitos_session));
+			memset(sc->sc_sessions, 0,
+				sesn * sizeof(struct talitos_session));
+			kfree(sc->sc_sessions);
+			sc->sc_sessions = ses;
+			ses = &sc->sc_sessions[sesn];
+			sc->sc_nsessions++;
+		}
+	}
+
+	ses->ses_used = 1;
+
+	if (encini) {
+		/* get an IV */
+		/* XXX may read fewer than requested */
+		read_random(ses->ses_iv, sizeof(ses->ses_iv));
+
+		ses->ses_klen = (encini->cri_klen + 7) / 8;
+#ifdef FSL_SEC11_MCF547X_8X
+		if(coldfire_debug)
+                	DPRINTF("%s encini: ses_klen %x,cri_klen %x,sizeof(ses->ses_iv) %x \n",
+				__FUNCTION__,ses->ses_klen,encini->cri_klen,
+				sizeof(ses->ses_iv));
+#endif
+		memcpy(ses->ses_key, encini->cri_key, ses->ses_klen);
+		if (macini) {
+			/* doing hash on top of cipher */
+			ses->ses_hmac_len = (macini->cri_klen + 7) / 8;
+			memcpy(ses->ses_hmac, macini->cri_key,
+				ses->ses_hmac_len);
+		}
+	} else 
+	if (macini) {
+		/* doing hash */
+		ses->ses_klen = (macini->cri_klen + 7) / 8;
+		memcpy(ses->ses_key, macini->cri_key, ses->ses_klen);
+	}
+	/* really should make up a template td here, 
+	 * and only fill things like i/o and direction in process() */
+
+	/* assign session ID */
+	*sidp = TALITOS_SID(sc->sc_num, sesn);
+	if(coldfire_debug)
+		DPRINTF("%s over: sc_num %x,sesn %x,*sip %x \n",
+			__FUNCTION__,sc->sc_num,sesn,*sidp);
+	return 0;
+}
+
+/*
+ * Deallocate a session.
+ */
+static int
+talitos_freesession(void *arg, u_int64_t tid)
+{
+	struct talitos_softc *sc = arg;
+	int session, ret;
+	u_int32_t sid = ((u_int32_t) tid) & 0xffffffff;
+
+	if (sc == NULL)
+		return EINVAL;
+	session = TALITOS_SESSION(sid);
+	if (session < sc->sc_nsessions) {
+		memset(&sc->sc_sessions[session], 0,
+			sizeof(sc->sc_sessions[session]));
+		ret = 0;
+	} else
+		ret = EINVAL;
+	return ret;
+}
+
+/*
+ * launch device processing - it will come back with done notification 
+ * in the form of an interrupt and/or HDR_DONE_BITS in header 
+ */
+static int 
+talitos_submit(
+	struct talitos_softc *sc,
+	struct talitos_desc *td,
+	int chsel)
+{
+	u_int32_t v;
+#ifdef FSL_SEC11_MCF547X_8X
+	/*printk("%s channel %x\n",__FUNCTION__,chsel);*/
+        v = dma_map_single(NULL, td, sizeof(*td), DMA_TO_DEVICE);
+        talitos_write(sc->sc_base_addr + 
+                chsel*TALITOS_CH_OFFSET + TALITOS_CH_FF, v);
+	if (coldfire_debug)
+		dump_talitos_status(sc);
+#else
+	v = dma_map_single(NULL, td, sizeof(*td), DMA_TO_DEVICE);
+	talitos_write(sc->sc_base_addr + 
+		chsel*TALITOS_CH_OFFSET + TALITOS_CH_FF, 0);
+	talitos_write(sc->sc_base_addr + 
+		chsel*TALITOS_CH_OFFSET + TALITOS_CH_FF_HI, v);
+#endif
+	return 0;
+}
+
+static int
+talitos_process(void *arg, struct cryptop *crp, int hint)
+{
+	int i,k, err = 0, ivsize;
+	struct talitos_softc *sc = arg;
+	struct cryptodesc *crd1, *crd2, *maccrd, *enccrd;
+	caddr_t iv;
+	struct talitos_session *ses;
+	struct talitos_desc *td;
+	int chsel; /* AK */
+	/* descriptor mappings */
+	int hmac_key, hmac_data, cipher_iv, cipher_key, 
+		in_fifo, out_fifo, cipher_iv_out;
+	unsigned long flags;
+	unsigned long r_flags;
+	int status; /* AK */
+	int rc;
+	u32 desc_header = 0 ; /* AK */
+
+	if (crp == NULL || crp->crp_callback == NULL || sc == NULL) {
+		return EINVAL;
+	}
+	crp->crp_etype = 0;
+	if (TALITOS_SESSION(crp->crp_sid) >= sc->sc_nsessions) {
+		return EINVAL;
+	}
+
+	ses = &sc->sc_sessions[TALITOS_SESSION(crp->crp_sid)];
+	
+  
+	#ifdef TALITOS_TASKLET
+	/* AK : obtain ch and fifo - TBD */
+    	/* enter the channel scheduler */ 
+	//spin_lock_irqsave(&sc->sc_chnfifolock[sc->sc_num_channels], flags);
+	/* 
+	 * Added by Vishnu
+	 * Makes the code compatible over different SEC Revisions
+	 * Get the Number of channels/FIFO for this SEC Revision
+	 */
+	chsel = chnum;
+	i = fifo_num;
+	//chsel = sc->sc_num_channels - 1;
+	//i = sc->sc_chfifo_len - 1;
+	fifo_num++;
+	if (fifo_num > i ){
+		fifo_num = 0;
+		chnum++;
+		if (chnum > chsel)
+			chnum = 0;
+	}
+	
+	/* release the channel scheduler lock */ 
+	//spin_unlock_irqrestore(&sc->sc_chnfifolock[sc->sc_num_channels], flags);
+
+	/*
+	 * now check whether the desc. is free. set the done
+	 * notification if free
+	 */
+	if (sc->sc_chnfifo[chsel][i].cf_desc.hdr == 0) {
+		/* TBD - do we really need to clear everything out*/
+		memset(&sc->sc_chnfifo[chsel][i].cf_desc,
+				0, sizeof(*td));
+
+	} else {
+		/* process all backlogs */
+		  for(;;) {
+			TALITOS_TASKLET_Q_LOCK();	
+ 			rc = talitos_inline_polling(r_flags);
+			TALITOS_TASKLET_Q_UNLOCK();
+			printk(KERN_INFO "%s %d times checking Q",__FUNCTION__, k);
+			if(rc) {
+			  printk(KERN_INFO "empty\n");
+				break;
+			}
+			printk("not empty processed\n");
+			chnum = fifo_num = i = chsel = 0;			
+
+		}
+		/* check the channel+fifo again */
+		if (sc->sc_chnfifo[chsel][i].cf_desc.hdr == 0) {
+			memset(&sc->sc_chnfifo[chsel][i].cf_desc,
+					0, sizeof(*td));
+			sc->sc_chnfifo[chsel][i].cf_desc.hdr |= 
+						TALITOS_DONE_NOTIFY;
+		} else {
+			printk(KERN_INFO "%s panic full - needs debug\n",__FUNCTION__);
+		}
+	}
+       
+	#endif /* TALITOS_TASKLET */			
+
+	td = &sc->sc_chnfifo[chsel][i].cf_desc;
+	sc->sc_chnfifo[chsel][i].cf_crp = crp;
+
+	crd1 = crp->crp_desc;
+	if (crd1 == NULL) {
+		err = EINVAL;
+		printk(KERN_INFO "%s crd1 null\n",__FUNCTION__);
+		goto errout;
+	}
+	crd2 = crd1->crd_next;
+	/*printk("crd1 %x , crd2 %x\n",crd1,crd2);*/
+	/* prevent compiler warning */
+	hmac_key = 0;
+	hmac_data = 0;
+	if (crd2 == NULL) {
+		if(coldfire_debug)
+			DPRINTF("%s crd2 = NULL, alg %x, desc_type %x\n",
+				__FUNCTION__,crd1->crd_alg,sc->sc_desc_types);
+		//td->hdr |= TD_TYPE_COMMON_NONSNOOP_NO_AFEU;
+		desc_header |= TD_TYPE_COMMON_NONSNOOP_NO_AFEU;
+		/* assign descriptor dword ptr mappings for this desc. type */
+		cipher_iv = 1;
+		cipher_key = 2;
+		in_fifo = 3;
+		cipher_iv_out = 5;
+		if (crd1->crd_alg == CRYPTO_MD5_HMAC ||
+		    crd1->crd_alg == CRYPTO_SHA1_HMAC ||
+		    crd1->crd_alg == CRYPTO_SHA1 ||
+		    crd1->crd_alg == CRYPTO_MD5) {
+			out_fifo = 5;
+			maccrd = crd1;
+			enccrd = NULL;
+		} else if (crd1->crd_alg == CRYPTO_DES_CBC ||
+		    crd1->crd_alg == CRYPTO_3DES_CBC ||
+		    crd1->crd_alg == CRYPTO_AES_CBC ||
+		    crd1->crd_alg == CRYPTO_ARC4) {
+			out_fifo = 4;
+			maccrd = NULL;
+			enccrd = crd1;
+		} else {
+			DPRINTF("UNKNOWN crd1->crd_alg %d\n", crd1->crd_alg);
+			err = EINVAL;
+			goto errout;
+		}
+	} else {
+		DPRINTF("%s crd2 != NULL,alg %x, desc_type %x\n",
+			__FUNCTION__,crd1->crd_alg,sc->sc_desc_types);
+		if (sc->sc_desc_types & TALITOS_HAS_DT_IPSEC_ESP) {
+			//td->hdr |= TD_TYPE_IPSEC_ESP;
+			desc_header |=  TD_TYPE_IPSEC_ESP;
+		} else {
+			DPRINTF("unimplemented: multiple descriptor ipsec\n");
+			err = EINVAL;
+			goto errout;
+		}
+		/* assign descriptor dword ptr mappings for this desc. type */
+		hmac_key = 0;
+		hmac_data = 1;
+		cipher_iv = 2;
+		cipher_key = 3;
+		in_fifo = 4;
+		out_fifo = 5;
+		cipher_iv_out = 6;
+		if ((crd1->crd_alg == CRYPTO_MD5_HMAC ||
+                     crd1->crd_alg == CRYPTO_SHA1_HMAC ||
+                     crd1->crd_alg == CRYPTO_MD5 ||
+                     crd1->crd_alg == CRYPTO_SHA1) &&
+		    (crd2->crd_alg == CRYPTO_DES_CBC ||
+		     crd2->crd_alg == CRYPTO_3DES_CBC ||
+		     crd2->crd_alg == CRYPTO_AES_CBC ||
+		     crd2->crd_alg == CRYPTO_ARC4) &&
+		    ((crd2->crd_flags & CRD_F_ENCRYPT) == 0)) {
+			maccrd = crd1;
+			enccrd = crd2;
+		} else if ((crd1->crd_alg == CRYPTO_DES_CBC ||
+		     crd1->crd_alg == CRYPTO_ARC4 ||
+		     crd1->crd_alg == CRYPTO_3DES_CBC ||
+		     crd1->crd_alg == CRYPTO_AES_CBC) &&
+		    (crd2->crd_alg == CRYPTO_MD5_HMAC ||
+                     crd2->crd_alg == CRYPTO_SHA1_HMAC ||
+                     crd2->crd_alg == CRYPTO_MD5 ||
+                     crd2->crd_alg == CRYPTO_SHA1) &&
+		    (crd1->crd_flags & CRD_F_ENCRYPT)) {
+			enccrd = crd1;
+			maccrd = crd2;
+		} else {
+			/* We cannot order the SEC as requested */
+			printk(DRV_NAME ": cannot do the order\n");
+			err = EINVAL;
+			goto errout;
+		}
+	}
+
+	/* assign in_fifo and out_fifo based on input/output struct type */
+	if (crp->crp_flags & CRYPTO_F_SKBUF) {
+		/* using SKB buffers */
+		struct sk_buff *skb = (struct sk_buff *)crp->crp_buf;
+		if (skb_shinfo(skb)->nr_frags) {
+			printk(DRV_NAME ": skb frags unimplemented\n");
+			err = EINVAL;
+			goto errout;
+		}
+		td->ptr[in_fifo].ptr = dma_map_single(NULL, skb->data, 
+			skb->len, DMA_TO_DEVICE);
+		td->ptr[in_fifo].len = skb->len;
+		td->ptr[out_fifo].ptr = dma_map_single(NULL, skb->data, 
+			skb->len, DMA_TO_DEVICE);
+		td->ptr[out_fifo].len = skb->len;
+		td->ptr[hmac_data].ptr = dma_map_single(NULL, skb->data,
+			skb->len, DMA_TO_DEVICE);
+	} else if (crp->crp_flags & CRYPTO_F_IOV) {
+		/* using IOV buffers */
+		struct ocf_uio *uiop = (struct uio *)crp->crp_buf;
+		if (uiop->uio_iovcnt > 1) {
+			printk(DRV_NAME ": iov frags unimplemented\n");
+			err = EINVAL;
+			goto errout;
+		}
+		td->ptr[in_fifo].ptr = dma_map_single(NULL,
+			uiop->uio_iov->iov_base, crp->crp_ilen, DMA_TO_DEVICE);
+		td->ptr[in_fifo].len = crp->crp_ilen;
+		if (crp->crp_mac) {
+			td->ptr[out_fifo].ptr = dma_map_single(NULL,
+				crp->crp_mac, ses->ses_klen, DMA_TO_DEVICE);
+			td->ptr[out_fifo].len = ses->ses_klen;
+		} else {
+			/* crp_olen is never set; always use crp_ilen */
+			td->ptr[out_fifo].ptr = dma_map_single(NULL,
+				uiop->uio_iov->iov_base,
+				crp->crp_ilen, DMA_TO_DEVICE);
+			td->ptr[out_fifo].len = crp->crp_ilen;
+		}
+	} else {
+		/* using contig buffers */
+		td->ptr[in_fifo].ptr = dma_map_single(NULL,
+			crp->crp_buf, crp->crp_ilen, DMA_TO_DEVICE);
+		//td->ptr[in_fifo].ptr =	virt_to_phys(crp->crp_buf);
+		td->ptr[in_fifo].len = crp->crp_ilen;
+		td->ptr[out_fifo].ptr = dma_map_single(NULL,
+			crp->crp_buf, crp->crp_ilen, DMA_TO_DEVICE);
+		//td->ptr[out_fifo].ptr =  virt_to_phys(crp->crp_buf);
+		td->ptr[out_fifo].len = crp->crp_ilen;
+	}
+
+	if (enccrd) {
+		switch (enccrd->crd_alg) {
+		case CRYPTO_3DES_CBC:
+		  	//td->hdr |= TALITOS_MODE0_DEU_3DES;
+			desc_header |= TALITOS_MODE0_DEU_3DES;
+			/* FALLTHROUGH */
+		case CRYPTO_DES_CBC:
+		  	//td->hdr |= TALITOS_SEL0_DEU
+		  	//		|  TALITOS_MODE0_DEU_CBC;
+			desc_header |= TALITOS_SEL0_DEU
+				|  TALITOS_MODE0_DEU_CBC;
+			if (enccrd->crd_flags & CRD_F_ENCRYPT)
+				//td->hdr |= TALITOS_MODE0_DEU_ENC;
+				desc_header |= TALITOS_MODE0_DEU_ENC;
+			ivsize = 2*sizeof(u_int32_t);
+			DPRINTF("%cDES ses %d ch %d len %d\n",
+				(/*td->hdr*/desc_header & TALITOS_MODE0_DEU_3DES)?'3':'1',
+				(u32)TALITOS_SESSION(crp->crp_sid),
+				chsel, td->ptr[in_fifo].len);
+			break;
+		case CRYPTO_AES_CBC:
+		  	//td->hdr |= TALITOS_SEL0_AESU
+		  	//		|  TALITOS_MODE0_AESU_CBC;
+			desc_header |= TALITOS_SEL0_AESU
+				|  TALITOS_MODE0_AESU_CBC;
+			if (enccrd->crd_flags & CRD_F_ENCRYPT)
+			  	//td->hdr |= TALITOS_MODE0_AESU_ENC;
+				desc_header |= TALITOS_MODE0_AESU_ENC;
+			ivsize = 4*sizeof(u_int32_t);
+			DPRINTF("AES  ses %d ch %d len %d\n",
+				(u32)TALITOS_SESSION(crp->crp_sid),
+				chsel, td->ptr[in_fifo].len);
+			break;
+		case CRYPTO_ARC4:
+			if(coldfire_debug)
+				printk("flags %x\n", enccrd->crd_flags);
+			if ((enccrd->crd_flags & CRD_ARC4_FIRST) == CRD_ARC4_FIRST) {
+				sc->sc_rc4_first = 1;
+				if(coldfire_debug)
+					printk("ARC4 first\n");
+			}
+			else {
+				sc->sc_rc4_first = 0;
+			}
+
+			if (sc->sc_rc4_first == 1) {
+				desc_header = SEC_ALG_AFEU_KEY ;
+			}
+			else if (sc->sc_rc4_first == 0) {
+				desc_header = SEC_ALG_AFEU_CONTEXT;
+			}
+			else {
+				printk("%s: the ARC4 error,first 1\n", __FUNCTION__);
+			}
+
+			ivsize = ARC4_SEC_CONTEXT_LEN;
+			if(coldfire_debug)
+                        	DPRINTF("ARC4  ses %d ch %d len %d ivsize %d\n",
+					(u32)TALITOS_SESSION(crp->crp_sid),
+					chsel, td->ptr[in_fifo].len,ivsize);
+			break;
+		default:
+			printk(DRV_NAME ": unimplemented enccrd->crd_alg %d\n",
+				enccrd->crd_alg);
+			err = EINVAL;
+			goto errout;
+		}
+		/*
+		 * Setup encrypt/decrypt state.  When using basic ops
+		 * we can't use an inline IV because hash/crypt offset
+		 * must be from the end of the IV to the start of the
+		 * crypt data and this leaves out the preceding header
+		 * from the hash calculation.  Instead we place the IV
+		 * in the state record and set the hash/crypt offset to
+		 * copy both the header+IV.
+		 */
+		if (enccrd->crd_flags & CRD_F_ENCRYPT) {
+		  	//td->hdr |= TALITOS_DIR_OUTBOUND; 
+		  	/*printk("enccrd->crd_flags & CRD_F_ENCRYPT \n");*/
+			desc_header |= TALITOS_DIR_OUTBOUND; 
+			if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
+				iv = enccrd->crd_iv;
+			else
+				iv = (caddr_t) ses->ses_iv;
+			if ((enccrd->crd_flags & CRD_F_IV_PRESENT) == 0) {
+				if (crp->crp_flags & CRYPTO_F_SKBUF)     {
+					skb_copy_bits_back(
+						(struct sk_buff *)
+						(crp->crp_buf),
+						enccrd->crd_inject, 
+						iv, ivsize);
+				}
+				else if (crp->crp_flags & CRYPTO_F_IOV)  {
+					cuio_copyback((struct uio *)
+						(crp->crp_buf),  
+						enccrd->crd_inject, 
+						ivsize, iv);
+				}
+			}
+		} else {
+			/*printk("enccrd->crd_flags ! CRD_F_ENCRYPT \n");*/
+			//td->hdr |= TALITOS_DIR_INBOUND; 
+			desc_header |= TALITOS_DIR_INBOUND; 
+			if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
+				iv = enccrd->crd_iv;
+			else
+				iv = (caddr_t) ses->ses_iv;
+			if ((enccrd->crd_flags & CRD_F_IV_PRESENT) == 0) {
+				if (crp->crp_flags & CRYPTO_F_SKBUF)     {
+					skb_copy_bits((struct sk_buff *)
+						(crp->crp_buf),
+						enccrd->crd_inject, 
+						iv, ivsize);
+				}
+				else if (crp->crp_flags & CRYPTO_F_IOV)  {
+					cuio_copyback((struct uio *)
+						(crp->crp_buf),
+						enccrd->crd_inject,
+						ivsize, iv);
+				}
+			}
+		}
+
+		if (enccrd->crd_alg == CRYPTO_ARC4) {
+			/*ivsize = ARC4_SEC_CONTEXT_LEN*/
+			if (sc->sc_rc4_first == 1) {
+                        	td->ptr[cipher_iv].ptr = NULL;
+                        	td->ptr[cipher_iv].len = 0;
+			}
+			else if (sc->sc_rc4_first == 0) {
+			        
+				td->ptr[cipher_iv].ptr = dma_map_single(NULL, iv, ivsize, 
+                                	DMA_TO_DEVICE);
+                        	//td->ptr[cipher_iv].ptr = virt_to_phys(iv);
+				td->ptr[cipher_iv].len = ivsize;
+			}
+			else {
+				printk("%s: the ARC4 error,first 2\n", __FUNCTION__);	
+			}
+                        td->ptr[cipher_iv_out].ptr = dma_map_single(NULL, iv, ivsize, 
+                        	DMA_TO_DEVICE);
+                        //td->ptr[cipher_iv_out].ptr = virt_to_phys(iv);
+                        td->ptr[cipher_iv_out].len = ivsize;
+		}
+		else {
+			td->ptr[cipher_iv].ptr = dma_map_single(NULL, iv, ivsize, 
+				DMA_TO_DEVICE);
+			//td->ptr[cipher_iv].ptr = virt_to_phys(iv);
+			td->ptr[cipher_iv].len = ivsize;
+			td->ptr[cipher_iv_out].ptr = dma_map_single(NULL, iv, ivsize, 
+				DMA_TO_DEVICE);
+			//td->ptr[cipher_iv_out].ptr = virt_to_phys(iv);
+			td->ptr[cipher_iv_out].len = ivsize;
+		}
+	}
+
+	if (enccrd && maccrd) {
+		//int bypass, coffset, oplen; /* AK commented out, not used */
+		/* this is ipsec only for now */
+		//td->hdr |= TALITOS_SEL1_MDEU
+		//	|  TALITOS_MODE1_MDEU_INIT
+		//	|  TALITOS_MODE1_MDEU_PAD;
+		desc_header |= TALITOS_SEL1_MDEU
+			|  TALITOS_MODE1_MDEU_INIT
+			|  TALITOS_MODE1_MDEU_PAD;
+		switch (maccrd->crd_alg) {
+			case	CRYPTO_MD5:	
+			  	//td->hdr |= TALITOS_MODE1_MDEU_MD5;
+				desc_header |= TALITOS_MODE1_MDEU_MD5;
+				break;
+			case	CRYPTO_MD5_HMAC:	
+			  	//td->hdr |= TALITOS_MODE1_MDEU_MD5_HMAC;
+				desc_header |= TALITOS_MODE1_MDEU_MD5_HMAC;
+				break;
+			case	CRYPTO_SHA1:	
+			  	//td->hdr |= TALITOS_MODE1_MDEU_SHA1;
+				desc_header |= TALITOS_MODE1_MDEU_SHA1;
+				break;
+			case	CRYPTO_SHA1_HMAC:	
+			  	//td->hdr |= TALITOS_MODE1_MDEU_SHA1_HMAC;
+				desc_header |= TALITOS_MODE1_MDEU_SHA1_HMAC;
+				break;
+			default:
+				/* We cannot order the SEC as requested */
+				printk(DRV_NAME ": cannot do the order\n");
+				err = EINVAL;
+				goto errout;
+		}
+		if ((maccrd->crd_alg == CRYPTO_MD5_HMAC) ||
+		   (maccrd->crd_alg == CRYPTO_SHA1_HMAC)) {
+			/*
+			 * The offset from hash data to the start of
+			 * crypt data is the difference in the skips.
+			 */
+			/* ipsec only for now */
+			td->ptr[hmac_key].ptr = dma_map_single(NULL, 
+				ses->ses_hmac, ses->ses_hmac_len, DMA_TO_DEVICE);
+			td->ptr[hmac_key].len = ses->ses_hmac_len;
+			td->ptr[in_fifo].ptr  += enccrd->crd_skip;
+			td->ptr[in_fifo].len  =  enccrd->crd_len;
+			td->ptr[out_fifo].ptr += enccrd->crd_skip;
+			td->ptr[out_fifo].len =  enccrd->crd_len;
+			/* bytes of HMAC to postpend to ciphertext */
+			//td->ptr[out_fifo].extent =  12;	/* ipsec */
+			td->ptr[hmac_data].ptr += maccrd->crd_skip; 
+			td->ptr[hmac_data].len = enccrd->crd_skip - maccrd->crd_skip;
+		}
+		if (enccrd->crd_flags & CRD_F_KEY_EXPLICIT) {
+			printk(DRV_NAME ": CRD_F_KEY_EXPLICIT unimplemented\n");
+		}
+	}
+
+	if (!enccrd && maccrd) {
+		/* single MD5 or SHA */
+		//td->hdr |= TALITOS_SEL0_MDEU
+		//		|  TALITOS_MODE0_MDEU_INIT
+		//		|  TALITOS_MODE0_MDEU_PAD;
+		desc_header |= TALITOS_SEL0_MDEU
+				|  TALITOS_MODE0_MDEU_INIT
+				|  TALITOS_MODE0_MDEU_PAD;
+		switch (maccrd->crd_alg) {
+			case	CRYPTO_MD5:	
+			  	//td->hdr |= TALITOS_MODE0_MDEU_MD5;
+				desc_header |= TALITOS_MODE0_MDEU_MD5;
+				DPRINTF("MD5  ses %d ch %d len %d\n",
+					(u32)TALITOS_SESSION(crp->crp_sid), 
+					chsel, td->ptr[in_fifo].len);
+				break;
+			case	CRYPTO_MD5_HMAC:	
+			  	//td->hdr |= TALITOS_MODE0_MDEU_MD5_HMAC;
+				desc_header |= TALITOS_MODE0_MDEU_MD5_HMAC;
+				break;
+			case	CRYPTO_SHA1:	
+			  	//td->hdr |= TALITOS_MODE0_MDEU_SHA1;
+			  	desc_header |= TALITOS_MODE0_MDEU_SHA1;
+				DPRINTF("SHA1 ses %d ch %d len %d\n",
+					(u32)TALITOS_SESSION(crp->crp_sid), 
+					chsel, td->ptr[in_fifo].len);
+				break;
+			case	CRYPTO_SHA1_HMAC:	
+				//td->hdr |= TALITOS_MODE0_MDEU_SHA1_HMAC;
+				desc_header |= TALITOS_MODE0_MDEU_SHA1_HMAC;
+				break;
+			default:
+				/* We cannot order the SEC as requested */
+				DPRINTF(DRV_NAME ": cannot do the order\n");
+				err = EINVAL;
+				goto errout;
+		}
+
+		if (crp->crp_flags & CRYPTO_F_IOV)
+			if (!crp->crp_mac)
+				td->ptr[out_fifo].ptr += maccrd->crd_inject;
+
+		if ((maccrd->crd_alg == CRYPTO_MD5_HMAC) ||
+		   (maccrd->crd_alg == CRYPTO_SHA1_HMAC)) {
+			td->ptr[hmac_key].ptr = dma_map_single(NULL, 
+				ses->ses_hmac, ses->ses_hmac_len, 
+				DMA_TO_DEVICE);
+			td->ptr[hmac_key].len = ses->ses_hmac_len;
+		}
+	} 
+	else {
+		/* using process key (session data has duplicate) */
+		if (enccrd->crd_alg == CRYPTO_ARC4) {
+                        if (sc->sc_rc4_first == 1) {
+				td->ptr[cipher_key].ptr = dma_map_single(NULL, 
+                                	enccrd->crd_key, (enccrd->crd_klen + 7) / 8, 
+                                	DMA_TO_DEVICE);
+				td->ptr[cipher_key].len = (enccrd->crd_klen + 7) / 8;
+                        }
+                        else if (sc->sc_rc4_first == 0) {
+				td->ptr[cipher_key].ptr = NULL;
+				td->ptr[cipher_key].len = 0;       
+                        }
+			else {
+				printk("%s: the ARC4 error,first 2\n", __FUNCTION__);   
+			}
+		}
+		else {
+			td->ptr[cipher_key].ptr = dma_map_single(NULL, 
+				enccrd->crd_key, (enccrd->crd_klen + 7) / 8, 
+				DMA_TO_DEVICE);
+			//td->ptr[cipher_key].ptr = virt_to_phys(enccrd->crd_key);
+			td->ptr[cipher_key].len = (enccrd->crd_klen + 7) / 8;
+		}
+	}	
+
+	
+	if (enccrd->crd_alg != CRYPTO_ARC4) {
+		desc_header |= TALITOS_DONE_NOTIFY;
+	}
+	/* Obtain spinlock */
+	spin_lock_irqsave(&sc->sc_chnfifo[chsel][i].desc_lock, flags);
+
+	/* write to header */					
+	td->hdr = desc_header;
+	/* release spinlock */
+	spin_unlock_irqrestore(&sc->sc_chnfifo[chsel][i].desc_lock, flags);
+
+
+	/* descriptor complete - GO! */
+	status = talitos_submit(sc, td, chsel);
+
+	/* AK tracing */
+	//trace_log_L1(34,0,0);
+	if (enccrd->crd_alg == CRYPTO_ARC4) {
+		if (sc->sc_rc4_first == 1) {
+			sc->sc_rc4_first = 0;
+			printk("%s: ARC4 SETkey over,then do context\n",
+				__FUNCTION__);
+		}
+	}
+	/* AK : add this job to the tasklet q */
+	#ifdef TALITOS_TASKLET	
+	TALITOS_TASKLET_Q_LOCK();	
+	list_add_tail(&sc->sc_chnfifo[chsel][i].desc_list , &talitos_tasklet_q);	
+	talitos_inline_polling(r_flags);
+	TALITOS_TASKLET_Q_UNLOCK();
+	#endif /* TALITOS_TASKLET */
+	if (coldfire_debug)
+		dump_talitos_status(sc);
+	
+	return status;
+
+
+errout:
+	if (err != ERESTART) {
+		crp->crp_etype = err;
+		crypto_done(crp);
+	} else {
+	        sc->sc_needwakeup |= CRYPTO_SYMQ;
+        }  
+	
+	return err;
+}
+
+
+#ifdef TALITOS_TASKLET
+/*
+ * Inline polling - from program context
+ */
+static inline int talitos_inline_polling (unsigned long lock_flags)
+{
+	int rc;
+	u32 v;
+	unsigned long r_flags = lock_flags;
+	unsigned long flags;
+	struct cryptop *crpt;
+	struct desc_cryptop_pair *descp;
+	rc = list_empty(&talitos_tasklet_q);
+	if (!rc) {
+			descp = list_entry(talitos_tasklet_q.next, typeof(*descp), 			     								desc_list);
+			/* check for done notification */
+			if ((descp->cf_desc.hdr & TALITOS_HDR_DONE_BITS) 
+			    == TALITOS_HDR_DONE_BITS) {
+			  //trace_log_L1(44,0,0);
+				crpt = descp->cf_crp;
+				if(coldfire_debug)
+					printk(KERN_INFO "%s 0x%08x,0x%08x\n",
+						__FUNCTION__,&descp->cf_desc.hdr,
+						descp->cf_desc.hdr);
+
+				/* every single pkt needs to be ack-ed to avoid
+			 	* stored done interrupt generation. maybe one
+			 	* write would do as we never unmask the cha 
+			 	* interrupts
+				*/
+ 				v = 0xffffffff;
+				talitos_write(sec_base_addr + TALITOS_ICR, v);
+				//talitos_write(sec_base_addr + TALITOS_ICR_HI, v);
+
+				spin_lock_irqsave(&descp->desc_lock, flags);
+				/* clear descriptor header */
+				descp->cf_desc.hdr = 0;
+				spin_unlock_irqrestore(&descp->desc_lock, flags);
+
+				/* remove element from list */
+				list_del(&descp->desc_list);
+
+				TALITOS_TASKLET_Q_UNLOCK();
+				/* complete post procesing */
+       				crypto_done(crpt);
+
+				TALITOS_TASKLET_Q_LOCK();
+			}
+			
+	}
+	return rc;
+}
+
+
+
+/*
+ * This routine is called by talitos tasklet
+ */
+static inline void talitos_poll (unsigned long lock_flags)
+{
+	struct cryptop *crpt;
+	struct desc_cryptop_pair *descp;
+	unsigned long r_flags = lock_flags;
+	unsigned long flags;
+	u32 num_of_times;
+	u32 v;
+	num_of_times = 0;
+	for(;;) {
+		descp = NULL;
+		if (!list_empty(&talitos_tasklet_q)) {
+			descp = list_entry(talitos_tasklet_q.next, typeof(*descp), 														desc_list);
+			crpt = descp->cf_crp;
+			/* check for done notification */
+			if ((descp->cf_desc.hdr & TALITOS_HDR_DONE_BITS) 
+			    == TALITOS_HDR_DONE_BITS) {
+
+				/* every single pkt needs to be ack-ed to avoid
+			 	* stored done interrupt generation. maybe one
+			 	* write would do as we never unmask the cha 
+			 	* interrupts
+				*/
+ 				v = 0xffffffff;
+				talitos_write(sec_base_addr + TALITOS_ICR, v);
+				//talitos_write(sec_base_addr + TALITOS_ICR_HI, v);
+
+				spin_lock_irqsave(&descp->desc_lock, flags);
+				/* clear descriptor header */
+				descp->cf_desc.hdr = 0;
+				spin_unlock_irqrestore(&descp->desc_lock, flags);
+
+				/* remove element from list */
+				list_del(&descp->desc_list);
+
+				TALITOS_TASKLET_Q_UNLOCK();
+				/* complete post procesing */
+				//trace_log_L1(41,0,0);
+       				crypto_done(crpt);
+				TALITOS_TASKLET_Q_LOCK();
+				num_of_times++;
+			} else {
+				//trace_log_L1(42,0,0);
+				/* reschedule tasklet - this may be costly*/
+				//tasklet_schedule(&isr_talitos_tasklet);
+				
+				v = talitos_read(sec_base_addr + TALITOS_IMR);
+				v |= TALITOS_IMR_ALL;
+				talitos_write(sec_base_addr + TALITOS_IMR, v);
+				break;
+			}
+		
+		} else {
+			/* since Q empty we need to unmask talitos interrupt
+			* so that tasklet can be scheduled again */
+		  	//trace_log_L1(43,0,0);			 	
+
+		  	/* before we unmask clear out talitos interrupt sources */
+			v = 0xffffffff;
+			talitos_write(sec_base_addr + TALITOS_ICR, v);
+			talitos_write(sec_base_addr + TALITOS_ICR_HI, v);
+		  	/* unmask talitos interrupt */
+			v = talitos_read(sec_base_addr + TALITOS_IMR);
+			v = 0;//|= TALITOS_IMR_ALL;
+			talitos_write(sec_base_addr + TALITOS_IMR, v);
+			break;
+		}
+	}
+
+}
+
+
+/*
+ * this is the bottom half for talitos interrupt
+ * processing
+ */
+static void talitos_tasklet (unsigned long data)
+{
+	unsigned long r_flags;
+	TALITOS_TASKLET_Q_LOCK();
+	talitos_poll(r_flags);
+	TALITOS_TASKLET_Q_UNLOCK();
+       
+}
+#endif /* TALITOS_TASKLET */
+
+
+
+/* go through all channels descriptors, notifying OCF what has 
+ * _and_hasn't_ successfully completed and reset the device 
+ * (otherwise it's up to decoding desc hdrs!)
+ */
+static void talitos_errorprocessing(struct talitos_softc *sc, unsigned long chnum)
+{
+	unsigned long flags;
+	int i=0, j=0;
+
+	//printk(KERN_INFO "%s ERROR! we will be scewed if we proceed \n",__FUNCTION__);
+	
+
+	/* disable further scheduling until under control */
+	//spin_lock_irqsave(&sc->sc_chnfifolock[sc->sc_num_channels], flags);
+
+	if (debug) dump_talitos_status(sc);
+	/* go through descriptors, try and salvage those successfully done, 
+	 * and EIO those that weren't
+	 */
+	/* 
+	 * Added by: Vishnu
+	 * For TALITOS_IS_SEC_2_2_0
+	 * Number of Channels is 1
+	 * We can avoid this loop
+	 */
+	/*
+	for (i = 0; i < sc->sc_num_channels; i++) {
+		//spin_lock_irqsave(&sc->sc_chnfifolock[i], flags);
+	*/
+		for (j = 0; j < sc->sc_chfifo_len; j++) {
+			if (sc->sc_chnfifo[i][j].cf_desc.hdr) {
+				if ((sc->sc_chnfifo[i][j].cf_desc.hdr 
+					& TALITOS_HDR_DONE_BITS) 
+					!= TALITOS_HDR_DONE_BITS) {
+					/* this one didn't finish */
+					/* signify in crp->etype */
+					sc->sc_chnfifo[i][j].cf_crp->crp_etype 
+						= EIO;
+				}
+			} else
+				continue; /* free entry */
+			/* either way, notify ocf */
+			crypto_done(sc->sc_chnfifo[i][j].cf_crp);
+			/* and tag it available again */
+			sc->sc_chnfifo[i][j].cf_desc.hdr = 0;
+		}
+	/*
+		//spin_unlock_irqrestore(&sc->sc_chnfifolock[i], flags);
+	}
+	*/
+	/* reset and initialize the SEC h/w device */
+	talitos_reset_device(sc);
+	talitos_init_device(sc);
+	if (sc->sc_exec_units & TALITOS_HAS_EU_RNG)
+		talitos_rng_init(sc);
+
+	/* Okay. Stand by. */
+	//spin_unlock_irqrestore(&sc->sc_chnfifolock[sc->sc_num_channels], flags);
+
+	return;
+}
+
+/* go through all channels descriptors, notifying OCF what's been done */
+static void talitos_doneprocessing(struct talitos_softc *sc, unsigned long chnum)
+{
+	unsigned long flags;
+	u32 v;
+
+      	/* enter the channel scheduler */ 
+	//spin_lock_irqsave(&sc->sc_chnfifolock[sc->sc_num_channels], flags);
+
+	#ifdef TALITOS_TASKLET
+
+	/* mask SEC interrupt */
+	v = talitos_read(sc->sc_base_addr + TALITOS_IMR);
+	v = 0;//&= ~TALITOS_IMR_ALL;
+	talitos_write(sc->sc_base_addr + TALITOS_IMR, v);
+
+	//trace_log_L1(40,0,0);
+
+	/* raise tasklet irq */
+	tasklet_schedule(&isr_talitos_tasklet);
+	#endif /* TALITOS_TASKLET */
+
+	/* release the channel scheduler lock */ 
+	//spin_unlock_irqrestore(&sc->sc_chnfifolock[sc->sc_num_channels], flags);
+	return;
+}
+
+
+static irqreturn_t 
+talitos_intr(int irq, void *arg)
+{
+	struct talitos_softc *sc = arg;
+	u_int32_t v, v_hi;
+	unsigned long chnum = 0;
+	
+	/* read the status register */
+	v = talitos_read(sc->sc_base_addr + TALITOS_ISR);
+	v_hi = talitos_read(sc->sc_base_addr + TALITOS_ISR_HI);
+
+	/* determine for which channel we got this interrupt */
+#if 0
+	if ( v & 0x00000003)	
+		chnum = 0;
+	else if ( v & 0x0000000c)	
+		chnum = 1;
+	else if ( v & 0x00000030)	
+		chnum = 2;
+	else if ( v & 0x000000c0)	
+		chnum = 3;
+	else
+		printk("panic, ISR_low = 0x%8.8x, ISR_hi = 0x%8.8x...\n", v, v_hi);
+#endif
+	chnum = 0;
+	
+	/* ack */
+	talitos_write(sc->sc_base_addr + TALITOS_ICR, v);
+	talitos_write(sc->sc_base_addr + TALITOS_ICR_HI, v_hi);
+
+	if (unlikely(v & TALITOS_ISR_ERROR)) {
+		/* Okay, Houston, we've had a problem here. */
+		printk(KERN_DEBUG DRV_NAME 
+			": got error interrupt - ISR 0x%08x_%08x\n", v, v_hi);
+		//trace_set_L1(g,3);
+		//trace_log_L1(40, trace_var(g), 300); 
+		printk("%s error ...\n", __FUNCTION__);
+		while(1){};
+		talitos_errorprocessing(sc, chnum);
+	} else
+	if (v & TALITOS_ISR_DONE) {
+		/* now do the done processing */
+		printk("%s Done ...\n", __FUNCTION__);
+		talitos_doneprocessing(sc, chnum);
+	}
+	else {
+		printk(KERN_INFO "%s Panic : talitos intr. reason unknown \n", __FUNCTION__);
+	}
+	
+	/* AK added */
+        if (sc->sc_needwakeup) {                /* XXX check high watermark */
+               int wakeup = sc->sc_needwakeup & (CRYPTO_SYMQ|CRYPTO_ASYMQ);
+               DPRINTF("%s: wakeup crypto %x\n", __func__,
+                        sc->sc_needwakeup);
+               sc->sc_needwakeup &= ~wakeup;
+               crypto_unblock(sc->sc_cid, wakeup);
+        }
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * set the master reset bit on the device.
+ */
+static void
+talitos_reset_device_master(struct talitos_softc *sc)
+{
+	u_int32_t v;
+#ifdef FSL_SEC11_MCF547X_8X
+        unsigned long time = jiffies;
+	if(coldfire_debug)
+		DPRINTF("%s()\n", __FUNCTION__);
+        v = 0;//talitos_read(sc->sc_base_addr + TALITOS_MCR);
+        talitos_write(sc->sc_base_addr + TALITOS_MCR, v | TALITOS_MCR_SWR);
+
+        while (talitos_read(sc->sc_base_addr + TALITOS_MCR) & TALITOS_MCR_SWR){
+                if (jiffies - time > SEC_INIT_TIMEOUT){
+                        printk("%s reset SEC1.1 Master timeout: %x\n",
+                                        __FUNCTION__,v);
+                        break;
+                }
+	}
+	if(coldfire_debug)
+		DPRINTF("%s ok\n", __FUNCTION__);
+#else
+	/* Reset the device by writing 1 to MCR:SWR and waiting 'til cleared */
+	v = talitos_read(sc->sc_base_addr + TALITOS_MCR);
+	talitos_write(sc->sc_base_addr + TALITOS_MCR, v | TALITOS_MCR_SWR);
+
+	while (talitos_read(sc->sc_base_addr + TALITOS_MCR) & TALITOS_MCR_SWR)
+		cpu_relax();
+#endif
+	return;
+}
+
+#ifdef FSL_SEC11_MCF547X_8X
+static void
+talitos_init_DESU(struct talitos_softc *sc)
+{
+        u_int32_t v;
+	if(coldfire_debug)
+		DPRINTF("%s()\n", __FUNCTION__);
+        /* init DESU */
+        v = talitos_read(sc->sc_base_addr + TALITOS_DEUICR);
+        v = TALITOS_DEUICR_MASK;
+        talitos_write(sc->sc_base_addr + TALITOS_DEUICR, v);
+      
+}
+
+static void
+talitos_init_AFEU(struct talitos_softc *sc)
+{
+        u_int32_t v;
+	if(coldfire_debug)
+		DPRINTF("%s()\n", __FUNCTION__);
+        /* init AFEU */
+        v = talitos_read(sc->sc_base_addr + TALITOS_AFEUICR);
+        v = TALITOS_AFEUICR_MASK;
+        talitos_write(sc->sc_base_addr + TALITOS_AFEUICR, v);
+      
+}
+
+static void
+talitos_init_AESU(struct talitos_softc *sc)
+{
+        u_int32_t v;
+	if(coldfire_debug)
+		DPRINTF("%s()\n", __FUNCTION__);
+        /* init AESU */
+        v = talitos_read(sc->sc_base_addr + TALITOS_AESUICR);
+        v = TALITOS_AESUICR_MASK;
+        talitos_write(sc->sc_base_addr + TALITOS_AESUICR, v);
+      
+}
+
+static void
+talitos_init_MDEU(struct talitos_softc *sc)
+{
+        u_int32_t v;
+	if(coldfire_debug)
+		DPRINTF("%s()\n", __FUNCTION__);
+        /* init MDEU */
+        v = talitos_read(sc->sc_base_addr + TALITOS_MDEUICR);
+        v = TALITOS_MDEUICR_MASK;
+        talitos_write(sc->sc_base_addr + TALITOS_MDEUICR, v);
+      
+}
+
+static void
+talitos_init_RNG(struct talitos_softc *sc)
+{
+        u_int32_t v;
+	if(coldfire_debug)
+		DPRINTF("%s()\n", __FUNCTION__);
+        /* init RNG */
+        v = talitos_read(sc->sc_base_addr + TALITOS_RNGICR);
+        v = TALITOS_RNGICR_MASK;
+        talitos_write(sc->sc_base_addr + TALITOS_RNGICR, v);
+      
+}
+
+static void
+talitos_reset_DESU(struct talitos_softc *sc)
+{
+        u_int32_t v;
+	unsigned long time = jiffies;
+	if(coldfire_debug)
+		DPRINTF("%s()\n", __FUNCTION__);
+        /*
+ 	* DESU reset
+ 	*/
+	v = talitos_read(sc->sc_base_addr + TALITOS_DEURCR);
+	talitos_write(sc->sc_base_addr + TALITOS_DEURCR, 
+			v | TALITOS_DEURCR_RESET);
+
+	while(!(talitos_read(sc->sc_base_addr + TALITOS_DEUSR) 
+		& TALITOS_DEUSR_RESET)){
+		if (jiffies - time > SEC_INIT_TIMEOUT){
+			printk("%s reset DES unit timeout: %x\n",
+                        		__FUNCTION__,v);
+                        break;
+		}
+	}
+	if(coldfire_debug)
+		DPRINTF("%s ok\n", __FUNCTION__);
+}
+
+static void
+talitos_reset_AFEU(struct talitos_softc *sc)
+{
+        u_int32_t v;
+        unsigned long time = jiffies;
+	if(coldfire_debug)
+		DPRINTF("%s()\n", __FUNCTION__);
+        /*
+ 	* AFEU reset
+	*/
+        v = talitos_read(sc->sc_base_addr + TALITOS_AFEURCR);
+        talitos_write(sc->sc_base_addr + TALITOS_AFEURCR, 
+                        v | TALITOS_AFEURCR_RESET);
+
+        while(!(talitos_read(sc->sc_base_addr + TALITOS_AFEUSR) & 
+		TALITOS_AFEUSR_RESET)){
+                if (jiffies - time > 10*SEC_INIT_TIMEOUT){
+                        printk("%s reset AFE unit timeout: %x should be %x\n",
+                                        __FUNCTION__,
+					talitos_read(sc->sc_base_addr + TALITOS_AFEUSR),
+					TALITOS_AFEUSR_RESET);
+                        return;
+                }
+        }
+	if(coldfire_debug)
+		DPRINTF("%s ok\n", __FUNCTION__);        
+}
+
+static void
+talitos_reset_AESU(struct talitos_softc *sc)
+{
+        u_int32_t v;
+        unsigned long time = jiffies;
+
+	if(coldfire_debug)
+		DPRINTF("%s()\n", __FUNCTION__);
+        /*
+	* AESU reset
+ 	*/
+        v = talitos_read(sc->sc_base_addr + TALITOS_AESURCR);
+        talitos_write(sc->sc_base_addr + TALITOS_AESURCR, 
+                        v | TALITOS_AESURCR_RESET);
+
+        while(!(talitos_read(sc->sc_base_addr + TALITOS_AESUSR) 
+		& TALITOS_AESUSR_RESET)){
+                if (jiffies - time > SEC_INIT_TIMEOUT){
+                        printk("%s reset AES unit timeout: %x\n",
+                                        __FUNCTION__,v);
+                        break;
+                }
+        }
+	if(coldfire_debug)
+		DPRINTF("%s ok\n", __FUNCTION__);
+}
+
+static void
+talitos_reset_MDEU(struct talitos_softc *sc)
+{
+        u_int32_t v;
+        unsigned long time = jiffies;
+
+	if(coldfire_debug)
+		DPRINTF("%s()\n", __FUNCTION__);
+        /*
+	* MDEU reset
+	*/
+        v = talitos_read(sc->sc_base_addr + TALITOS_MDEURCR);
+        talitos_write(sc->sc_base_addr + TALITOS_MDEURCR,
+                        v | TALITOS_MDEURCR_RESET);
+
+        while(!(talitos_read(sc->sc_base_addr + TALITOS_MDEUSR)  
+		& TALITOS_MDEUSR_RESET)){
+                if (jiffies - time > SEC_INIT_TIMEOUT){
+                        printk("%s reset MDE unit timeout: %x\n",
+                                        __FUNCTION__,v);
+                        break;
+                }
+        }
+	if(coldfire_debug)
+		DPRINTF("%s ok\n", __FUNCTION__);
+}
+
+static void
+talitos_reset_RNG(struct talitos_softc *sc)
+{
+        u_int32_t v;
+        unsigned long time = jiffies;
+	if(coldfire_debug)
+		DPRINTF("%s()\n", __FUNCTION__);
+        /*
+	* RNG reset
+	*/
+        v = talitos_read(sc->sc_base_addr + TALITOS_RNGRCR);
+        talitos_write(sc->sc_base_addr + TALITOS_RNGRCR,
+                        v | TALITOS_RNGRCR_SR);
+
+        while(!(talitos_read(sc->sc_base_addr + TALITOS_RNGSR) 
+		& TALITOS_RNGSR_RD)){
+                if (jiffies - time > SEC_INIT_TIMEOUT){
+                        printk("%s reset RNG unit timeout: %x\n",
+                                        __FUNCTION__,v);
+                        break;
+                }
+        }
+	if(coldfire_debug)
+		DPRINTF("%s ok\n", __FUNCTION__);
+
+}
+#endif
+
+/*
+ *  * Initialize registers we need to touch only once.
+ *   */
+static void
+talitos_init_device(struct talitos_softc *sc)
+{
+        u_int32_t v;
+        int i;
+
+	if(coldfire_debug)
+		DPRINTF("%s()\n", __FUNCTION__);
+#ifdef FSL_SEC11_MCF547X_8X
+        /* init controller */
+
+        v = talitos_read(sc->sc_base_addr + TALITOS_IMR);
+        v = 0;//|= TALITOS_IMR_ALL;
+        talitos_write(sc->sc_base_addr + TALITOS_IMR, v);
+        v = talitos_read(sc->sc_base_addr + TALITOS_IMR_HI);
+        v |= TALITOS_IMR_HI_ALL;
+        talitos_write(sc->sc_base_addr + TALITOS_IMR_HI, v);
+
+        /* init all channels */
+        for (i = 0; i < sc->sc_num_channels; i++) {
+                v = talitos_read(sc->sc_base_addr +
+                        i*TALITOS_CH_OFFSET + TALITOS_CH_CCCR);
+                v |= TALITOS_CH_CCCR_CDWE
+                  |  TALITOS_CH_CCCR_NE
+                  |  TALITOS_CH_CCCR_NT     /* Do selective notification */
+                  |  TALITOS_CH_CCCR_CDIE;  /* invoke interrupt if done */
+                  talitos_write(sc->sc_base_addr +
+                        i*TALITOS_CH_OFFSET + TALITOS_CH_CCCR, v);
+        }
+
+        talitos_init_DESU(sc);
+        talitos_init_AESU(sc);
+        talitos_init_AFEU(sc);
+        talitos_init_MDEU(sc);
+        talitos_init_RNG(sc);
+
+	MCF_ICR(ISC_SEC) = ILP_SEC;
+
+       /* Enable the  SEC interrupt */
+        //enable_irq(64 + ISC_SEC);	
+	if (coldfire_debug)
+		dump_talitos_status(sc);
+#else
+        /* init all channels */
+        for (i = 0; i < sc->sc_num_channels; i++) {
+                v = talitos_read(sc->sc_base_addr +
+                        i*TALITOS_CH_OFFSET + TALITOS_CH_CCCR_HI);
+                v |= TALITOS_CH_CCCR_HI_CDWE
+                  //#ifdef TALITOS_INTERRUPT_COALESCE
+                  //|  TALITOS_CH_CCCR_HI_NT     /* Do selective notification */
+                  //#endif
+                  |  TALITOS_CH_CCCR_HI_CDIE;  /* invoke interrupt if done */
+                talitos_write(sc->sc_base_addr +
+                	i*TALITOS_CH_OFFSET + TALITOS_CH_CCCR_HI, v);
+        }
+        /* enable all interrupts */
+        v = talitos_read(sc->sc_base_addr + TALITOS_IMR);
+        v |= TALITOS_IMR_ALL;
+        talitos_write(sc->sc_base_addr + TALITOS_IMR, v);                                                                                                            /* AK commented out: we don't want to take interrupt
+           or want to get notified when individual cha units
+           complete its job. This could really hurt performance
+           and we will take two interrupt per packet despite
+           the fact that we use one descriptor
+         */
+        #if 0
+        #ifdef TALITOS_BASELINE
+        v = talitos_read(sc->sc_base_addr + TALITOS_IMR_HI);
+        v |= TALITOS_IMR_HI_ALL;
+        talitos_write(sc->sc_base_addr + TALITOS_IMR_HI, v); 
+        #endif
+        #endif
+#endif
+	return;
+}
+/*
+ * Resets the device.  Values in the registers are left as is
+ * from the reset (i.e. initial values are assigned elsewhere).
+ */
+static void
+talitos_reset_device(struct talitos_softc *sc)
+{
+	u_int32_t v;
+	int i;
+
+	if(coldfire_debug)
+		DPRINTF("%s()\n", __FUNCTION__);
+
+	/*
+	 * Master reset
+	 * errata documentation: warning: certain SEC interrupts 
+	 * are not fully cleared by writing the MCR:SWR bit, 
+	 * set bit twice to completely reset 
+	 */
+#ifdef FSL_SEC11_MCF547X_8X
+	unsigned long time;
+	if (coldfire_debug)
+		dump_talitos_status(sc);
+	/*MCF_SECSACR = 1;*/
+        talitos_reset_device_master(sc); 
+#else
+	talitos_reset_device_master(sc);	/* once */
+	talitos_reset_device_master(sc);	/* and once again */
+#endif	
+	/* reset all channels */
+	for (i = 0; i < sc->sc_num_channels; i++) {
+		v = talitos_read(sc->sc_base_addr + i*TALITOS_CH_OFFSET +
+			TALITOS_CH_CCCR);
+		talitos_write(sc->sc_base_addr + i*TALITOS_CH_OFFSET +
+			TALITOS_CH_CCCR, v | TALITOS_CH_CCCR_RESET);
+#ifdef FSL_SEC11_MCF547X_8X
+			time = jiffies;	
+			while(talitos_read(sc->sc_base_addr + i*TALITOS_CH_OFFSET 
+				+TALITOS_CH_CCCR) & TALITOS_CH_CCCR_RESET){
+				if (jiffies - time > SEC_INIT_TIMEOUT){
+					printk("%s reset channel %x timeout: %x,Addr %x\n",
+						__FUNCTION__,i,
+						talitos_read(sc->sc_base_addr + 
+						i*TALITOS_CH_OFFSET +TALITOS_CH_CCCR),
+						(sc->sc_base_addr + i*TALITOS_CH_OFFSET +
+                                                        TALITOS_CH_CCCR));
+					break;
+				}
+		
+			}
+#endif
+	}
+
+#ifdef FSL_SEC11_MCF547X_8X
+	talitos_reset_AFEU(sc);
+        talitos_reset_DESU(sc);
+	talitos_reset_AESU(sc);
+	talitos_reset_MDEU(sc);
+	talitos_reset_RNG(sc);
+	if (coldfire_debug)
+		dump_talitos_status(sc);
+#endif
+
+}
+
+/* Set up the crypto device structure, private data,
+ * and anything else we need before we start */
+static int talitos_probe(struct platform_device *pdev)
+{
+	struct talitos_softc *sc;
+	struct resource *r;
+	static int num_chips = 0;
+	int rc = 0;
+	int i;
+	int j;
+
+	if(coldfire_debug)
+		DPRINTF("%s()\n", __FUNCTION__);
+
+	sc = (struct talitos_softc *) kmalloc(sizeof(*sc), GFP_KERNEL);
+	if (!sc){
+		printk("%s kmalloc talitos_softc fail\n",__FUNCTION__);
+		return -ENOMEM;
+	}
+	memset(sc, 0, sizeof(*sc));
+
+	sc->sc_irq = -1;
+	sc->sc_cid = -1;
+	sc->sc_dev = pdev;
+	sc->sc_num = num_chips++;
+
+	platform_set_drvdata(sc->sc_dev, sc);
+
+	/* get the irq line */
+	//sc->sc_irq = 64 + platform_get_irq(pdev, 0);
+        sc->sc_irq = 64 + platform_get_irq(pdev, 0);
+	rc = request_irq(sc->sc_irq, talitos_intr, IRQF_DISABLED, DRV_NAME, sc);
+	if (rc) {
+		printk(KERN_ERR DRV_NAME ": failed to hook irq %d\n", 
+			sc->sc_irq);
+		sc->sc_irq = -1;
+		goto out;
+	}
+
+	/* get a pointer to the register memory */
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+#ifdef FSL_SEC11_MCF547X_8X
+	sc->sc_base_addr = (ocf_iomem_t) r->start;
+	if(coldfire_debug)
+		DPRINTF("BaseAddr %x %x %x\n",sc->sc_base_addr,r->start,r->end);
+#else
+        sc->sc_base_addr = (ocf_iomem_t) ioremap(r->start, (r->end - r->start));
+#endif
+	#ifdef TALITOS_TASKLET 
+	sec_base_addr = sc->sc_base_addr;
+	#endif
+
+	if (!sc->sc_base_addr) {
+		printk(KERN_ERR DRV_NAME ": failed to ioremap\n");
+		goto out;
+	}
+	
+	/* figure out our SEC's properties and capabilities */
+#ifdef FSL_SEC11_MCF547X_8X
+        sc->sc_chiprev = (u64)talitos_read(sc->sc_base_addr + TALITOS_ID)
+                 | talitos_read(sc->sc_base_addr + TALITOS_ID_HI) << 32;
+	if(coldfire_debug)
+		DPRINTF("sec id %x %x %x\n", talitos_read(sc->sc_base_addr + TALITOS_ID),
+                                    talitos_read(sc->sc_base_addr + TALITOS_ID_HI),
+                                    SEC_SID);
+#else
+	sc->sc_chiprev = (u64)talitos_read(sc->sc_base_addr + TALITOS_ID) << 32
+		 | talitos_read(sc->sc_base_addr + TALITOS_ID_HI);
+#endif
+	if(coldfire_debug)
+		DPRINTF("sec id 0x%llx\n", sc->sc_chiprev);
+	/* bulk should go away with openfirmware flat device tree support */
+	if (sc->sc_chiprev & TALITOS_ID_SEC_2_0) {
+		sc->sc_num_channels = TALITOS_NCHANNELS_SEC_2_0;
+		sc->sc_chfifo_len = TALITOS_CHFIFOLEN_SEC_2_0;
+		sc->sc_exec_units = TALITOS_HAS_EUS_SEC_2_0;
+		sc->sc_desc_types = TALITOS_HAS_DESCTYPES_SEC_2_0;
+	}  
+	else if (sc->sc_chiprev & TALITOS_ID_SEC_2_1_2) { /* AK generates compiler warning? */
+		sc->sc_num_channels = TALITOS_NCHANNELS_SEC_2_0;
+		sc->sc_chfifo_len = TALITOS_CHFIFOLEN_SEC_2_0;
+		sc->sc_exec_units = TALITOS_HAS_EUS_SEC_2_0;
+		sc->sc_desc_types = TALITOS_HAS_DESCTYPES_SEC_2_0;
+	}
+	else if (sc->sc_chiprev & TALITOS_ID_SEC_2_2_0) { /* Vishnu */
+		sc->sc_num_channels = TALITOS_NCHANNELS_SEC_2_2;
+		sc->sc_chfifo_len = TALITOS_CHFIFOLEN_SEC_2_2;
+		sc->sc_exec_units = TALITOS_HAS_EUS_SEC_2_2;
+		sc->sc_desc_types = TALITOS_HAS_DESCTYPES_SEC_2_2;
+	}
+#ifdef FSL_SEC11_MCF547X_8X
+        else if (sc->sc_chiprev & TALITOS_ID_SEC_1_1) {
+                sc->sc_num_channels = TALITOS_NCHANNELS_SEC_1_1;
+                sc->sc_chfifo_len = TALITOS_CHFIFOLEN_SEC_1_1;
+                sc->sc_exec_units = TALITOS_HAS_EUS_SEC_1_1;
+                sc->sc_desc_types = TALITOS_HAS_DESCTYPES_SEC_1_1;
+        }
+#endif
+	else {
+		printk(KERN_ERR DRV_NAME ": failed to id device\n");
+		goto out;
+	}
+
+
+	#ifdef TALITOS_TASKLET
+		spin_lock_init(&talitos_tasklet_q_lock);
+	#endif /* TALITOS_TASKLET */
+
+	sc->sc_chnlastalg = (int *) kmalloc(
+		sc->sc_num_channels * sizeof(int), GFP_KERNEL);
+	if (!sc->sc_chnlastalg)
+		goto out;
+	memset(sc->sc_chnlastalg, 0, sc->sc_num_channels * sizeof(int));
+	sc->sc_chnfifo = (struct desc_cryptop_pair **) kmalloc(
+		sc->sc_num_channels * sizeof(struct desc_cryptop_pair *), 
+		GFP_KERNEL);
+	if (!sc->sc_chnfifo)
+		goto out;
+
+	for (i = 0; i < sc->sc_num_channels; i++) {
+		sc->sc_chnfifo[i] = (struct desc_cryptop_pair *) kmalloc(
+			sc->sc_chfifo_len * sizeof(struct desc_cryptop_pair), 
+			GFP_KERNEL);
+		if (!sc->sc_chnfifo[i])
+			goto out;
+		memset(sc->sc_chnfifo[i], 0, 
+			sc->sc_chfifo_len * sizeof(struct desc_cryptop_pair));
+	}
+
+	/* Initialize header locks */
+	for (i = 0; i < sc->sc_num_channels; i++) {
+	  for(j = 0; j < sc->sc_chfifo_len; j++) {
+		spin_lock_init(&sc->sc_chnfifo[i][j].desc_lock);
+	  }
+	}
+
+
+	#ifdef TALITOS_TASKLET
+	for (i = 0; i < sc->sc_num_channels; i++) {
+		for (j = 0; j < sc->sc_chfifo_len; j++){
+			INIT_LIST_HEAD(&sc->sc_chnfifo[i][j].desc_list);
+	  	}
+	}
+
+	#endif /* TALITOS_TASKLET */
+
+	/* reset and initialize the SEC h/w device */
+	talitos_reset_device(sc);
+	talitos_init_device(sc);
+
+	sc->sc_cid = crypto_get_driverid(0, "talitos");
+	if (sc->sc_cid < 0) {
+		printk(KERN_ERR DRV_NAME ": could not get crypto driver id\n");
+		goto out;
+	}
+
+	/* register algorithms with the framework */
+	printk(DRV_NAME ":");
+
+	if (sc->sc_exec_units & TALITOS_HAS_EU_RNG)  {
+		printk(" rng");
+		//talitos_rng_init(sc);
+		crypto_rregister(sc->sc_cid, talitos_read_random, sc);
+	}
+	if (sc->sc_exec_units & TALITOS_HAS_EU_DEU) {
+		printk(" des/3des");
+		crypto_register(sc->sc_cid, CRYPTO_3DES_CBC, 0, 0,
+			talitos_newsession, talitos_freesession,
+			talitos_process, sc);
+		crypto_register(sc->sc_cid, CRYPTO_DES_CBC, 0, 0,
+			talitos_newsession, talitos_freesession,
+			talitos_process, sc);
+	}
+	if (sc->sc_exec_units & TALITOS_HAS_EU_AESU) {
+		printk(" aes");
+		crypto_register(sc->sc_cid, CRYPTO_AES_CBC, 0, 0,
+			talitos_newsession, talitos_freesession,
+			talitos_process, sc);
+	}
+        if (sc->sc_exec_units & TALITOS_HAS_EU_AFEU) {
+                printk(" rc4");
+		sc->sc_rc4_first = 0;
+                crypto_register(sc->sc_cid, CRYPTO_ARC4, 0, 0,
+                        talitos_newsession, talitos_freesession,
+                        talitos_process, sc);
+        }
+	if (sc->sc_exec_units & TALITOS_HAS_EU_MDEU) {
+		printk(" md5");
+		crypto_register(sc->sc_cid, CRYPTO_MD5, 0, 0,
+			talitos_newsession, talitos_freesession,
+			talitos_process, sc);
+		/* HMAC support only with IPsec for now */
+		crypto_register(sc->sc_cid, CRYPTO_MD5_HMAC, 0, 0,
+			talitos_newsession, talitos_freesession,
+			talitos_process, sc);
+		printk(" sha1");
+		crypto_register(sc->sc_cid, CRYPTO_SHA1, 0, 0,
+			talitos_newsession, talitos_freesession,
+			talitos_process, sc);
+		/* HMAC support only with IPsec for now */
+		crypto_register(sc->sc_cid, CRYPTO_SHA1_HMAC, 0, 0,
+			talitos_newsession, talitos_freesession,
+			talitos_process, sc);
+	}
+	printk(" \n");
+	return 0;
+
+out:
+	talitos_remove(pdev);
+	return -ENOMEM;
+}
+
+
+
+static int talitos_remove(struct platform_device *pdev)
+{
+	struct talitos_softc *sc = platform_get_drvdata(pdev);
+	int i;
+
+	DPRINTF("%s()\n", __FUNCTION__);
+	if (sc->sc_chnfifo) {
+		for (i = 0; i < sc->sc_num_channels; i++)
+			if (sc->sc_chnfifo[i])
+				kfree(sc->sc_chnfifo[i]);
+		kfree(sc->sc_chnfifo);
+	}
+	if (sc->sc_chnlastalg)
+		kfree(sc->sc_chnlastalg);
+	//if (sc->sc_chnfifolock)
+	//	kfree(sc->sc_chnfifolock);
+	if (sc->sc_cid >= 0)
+		crypto_unregister_all(sc->sc_cid);
+	if (sc->sc_irq != -1)
+		free_irq( sc->sc_irq, sc);
+	if (sc->sc_base_addr)
+		iounmap((void *) sc->sc_base_addr);
+	kfree(sc);
+	return 0;
+}
+
+/* Structure for a platform device driver */
+static struct platform_driver talitos_driver = {
+	.probe = talitos_probe,
+	.remove = talitos_remove,
+	.driver = {
+#ifdef FSL_SEC11_MCF547X_8X
+		.name = "fsl-sec1",
+#else
+		.name = "fsl-sec2"
+#endif
+	}
+};
+
+static int __init talitos_init(void)
+{
+	return platform_driver_register(&talitos_driver);
+}
+
+static void __exit talitos_exit(void)
+{
+	platform_driver_unregister(&talitos_driver);
+}
+
+module_init(talitos_init);
+module_exit(talitos_exit);
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("kim.phillips@freescale.com");
+MODULE_DESCRIPTION("OCF driver for Freescale SEC (talitos)");
diff --git a/crypto/ocf/talitos/talitos_dev.h b/crypto/ocf/talitos/talitos_dev.h
new file mode 100644
index 0000000..b38eb1d
--- /dev/null
+++ b/crypto/ocf/talitos/talitos_dev.h
@@ -0,0 +1,437 @@
+/*
+ * Freescale SEC (talitos) device dependent data structures
+ *
+ * Copyright 2006-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#define FSL_SEC11_MCF547X_8X 1
+/* device ID register values */
+#define TALITOS_ID_SEC_1_1                     (0x09000000)  /* MCF547x and MCF548x */
+#define TALITOS_ID_SEC_2_0	                      0x40
+#define TALITOS_ID_SEC_2_1	                      0x40   /* cross ref with IP block revision reg */
+#define TALITOS_ID_SEC_2_0_1                   (0x00000041)  /* low word  - MPC8349E */
+#define TALITOS_ID_SEC_2_1_0                   (0x00000080)  /* low word  - original MPC8548 */
+#define TALITOS_ID_SEC_2_1_1           (0x0030010100000000)  /* high word - MPC8548 */
+#define TALITOS_ID_SEC_2_1_2           (0x0030010200000000)  /* high word - MPC8548 */
+#define TALITOS_ID_SEC_2_2_0                   (0x000100a0)  /* low word  - future use */
+#define TALITOS_ID_SEC_2_2_1           (0x0030020000000000)  /* high word - future use */
+#define TALITOS_ID_SEC_2_5_0           (0x0030050100000000)  /* high word - future use */
+#define TALITOS
+
+/*
+ * following num_channels, channel-fifo-depth, exec-unit-mask, and 
+ * descriptor-types-mask are for forward-compatibility with openfirmware
+ * flat device trees
+ */
+
+/*
+ *  num_channels : the number of channels available in each SEC version.
+ */
+
+/* n.b. this driver requires these values be a power of 2 */
+#define TALITOS_NCHANNELS_SEC_1_0	4
+#define TALITOS_NCHANNELS_SEC_1_1       2
+#define TALITOS_NCHANNELS_SEC_1_2	1
+#define TALITOS_NCHANNELS_SEC_2_0	4
+#define TALITOS_NCHANNELS_SEC_2_01	4
+#define TALITOS_NCHANNELS_SEC_2_1	4
+#define TALITOS_NCHANNELS_SEC_2_2	1
+#define TALITOS_NCHANNELS_SEC_2_4	4
+
+/*
+ *  channel-fifo-depth : The number of descriptor
+ *  pointers a channel fetch fifo can hold.
+ */
+#define TALITOS_CHFIFOLEN_SEC_1_0	1
+#define TALITOS_CHFIFOLEN_SEC_1_1       1
+#define TALITOS_CHFIFOLEN_SEC_1_2	1
+#define TALITOS_CHFIFOLEN_SEC_2_0	24
+#define TALITOS_CHFIFOLEN_SEC_2_01	24
+#define TALITOS_CHFIFOLEN_SEC_2_1	24
+#define TALITOS_CHFIFOLEN_SEC_2_2	24
+#define TALITOS_CHFIFOLEN_SEC_2_4	24
+
+/* 
+ *  exec-unit-mask : The bitmask representing what Execution Units (EUs)
+ *  are available. EU information should be encoded following the SEC's 
+ *  EU_SEL0 bitfield documentation, i.e. as follows:
+ * 
+ *    bit 31 = set if SEC permits no-EU selection (should be always set)
+ *    bit 30 = set if SEC has the ARC4 EU (AFEU)
+ *    bit 29 = set if SEC has the des/3des EU (DEU)
+ *    bit 28 = set if SEC has the message digest EU (MDEU)
+ *    bit 27 = set if SEC has the random number generator EU (RNG)
+ *    bit 26 = set if SEC has the public key EU (PKEU)
+ *    bit 25 = set if SEC has the aes EU (AESU)
+ *    bit 24 = set if SEC has the Kasumi EU (KEU)
+ * 
+ */
+#define TALITOS_HAS_EU_NONE		(1<<0)
+#define TALITOS_HAS_EU_AFEU		(1<<1)
+#define TALITOS_HAS_EU_DEU		(1<<2)
+#define TALITOS_HAS_EU_MDEU		(1<<3)
+#define TALITOS_HAS_EU_RNG		(1<<4)
+#define TALITOS_HAS_EU_PKEU		(1<<5)
+#define TALITOS_HAS_EU_AESU		(1<<6)
+#define TALITOS_HAS_EU_KEU		(1<<7)
+
+/* the corresponding masks for each SEC version */
+#define TALITOS_HAS_EUS_SEC_1_0		0x7f
+#define TALITOS_HAS_EUS_SEC_1_1		0x5e
+#define TALITOS_HAS_EUS_SEC_1_2         0x4d
+#define TALITOS_HAS_EUS_SEC_2_0		0x7f
+#define TALITOS_HAS_EUS_SEC_2_01	0x7f
+#define TALITOS_HAS_EUS_SEC_2_1		0xff
+#define TALITOS_HAS_EUS_SEC_2_2		0x4c
+#define TALITOS_HAS_EUS_SEC_2_4		0x7f
+
+/*
+ *  descriptor-types-mask : The bitmask representing what descriptors
+ *  are available. Descriptor type information should be encoded 
+ *  following the SEC's Descriptor Header Dword DESC_TYPE field 
+ *  documentation, i.e. as follows:
+ *
+ *    bit 0  = set if SEC supports the aesu_ctr_nonsnoop desc. type
+ *    bit 1  = set if SEC supports the ipsec_esp descriptor type
+ *    bit 2  = set if SEC supports the common_nonsnoop desc. type
+ *    bit 3  = set if SEC supports the 802.11i AES ccmp desc. type
+ *    bit 4  = set if SEC supports the hmac_snoop_no_afeu desc. type
+ *    bit 5  = set if SEC supports the srtp descriptor type
+ *    bit 6  = set if SEC supports the non_hmac_snoop_no_afeu desc.type
+ *    bit 7  = set if SEC supports the pkeu_assemble descriptor type
+ *    bit 8  = set if SEC supports the aesu_key_expand_output desc.type
+ *    bit 9  = set if SEC supports the pkeu_ptmul descriptor type
+ *    bit 10 = set if SEC supports the common_nonsnoop_afeu desc. type
+ *    bit 11 = set if SEC supports the pkeu_ptadd_dbl descriptor type
+ *
+ *  ..and so on and so forth.
+ */
+#define TALITOS_HAS_DT_AESU_CTR_NONSNOOP	(1<<0)
+#define TALITOS_HAS_DT_IPSEC_ESP		(1<<1)
+#define TALITOS_HAS_DT_COMMON_NONSNOOP		(1<<2)
+
+/* the corresponding masks for each SEC version */
+#define TALITOS_HAS_DESCTYPES_SEC_1_1   0x33003334
+#define TALITOS_HAS_DESCTYPES_SEC_2_0	0x01010ebf
+#define TALITOS_HAS_DESCTYPES_SEC_2_1	0x012b0ebf
+#define TALITOS_HAS_DESCTYPES_SEC_2_2	0x0122003f
+
+/* 
+ * a TALITOS_xxx_HI address points to the low data bits (32-63) of the register
+ */
+#ifdef FSL_SEC11_MCF547X_8X
+/* global register offset addresses */
+#define TALITOS_EUACR           0x1000          /* EU Assaginment controller register is useless*/
+#define TALITOS_EUACR_HI        0x1004		/* EU Assaginment controller register is useless*/
+
+#define TALITOS_IMR		0x1008		/* interrupt mask register */
+#define TALITOS_IMR_ALL		0xf8000000	/* enable all interrupts mask */
+#define TALITOS_IMR_ERRONLY	0xa8000000	/* enable error interrupts */
+#define TALITOS_IMR_DONEONLY    0x50000000      /* enable done interrupts */
+#define TALITOS_IMR_HI		0x100C		/* interrupt mask register */
+#define TALITOS_IMR_HI_ALL	0x03333340	/* enable all channel interrupts mask */
+#define TALITOS_IMR_HI_ERRONLY	0x00222240	/* enable error interrupts */
+#define TALITOS_IMR_HI_DONEONLY 0x00111100      /* enable done interrupts */
+
+#define TALITOS_ISR		0x1010		/* interrupt status register */
+#define TALITOS_ISR_ERROR	0xa8000000	/* errors mask */
+#define TALITOS_ISR_DONE	0x50000000	/* channel(s) done mask */
+#define TALITOS_ISR_HI		0x1014		/* interrupt status register */
+
+#define TALITOS_ICR		0x1018		/* interrupt clear register */
+#define TALITOS_ICR_HI		0x101C		/* interrupt clear register */
+
+#define TALITOS_ID              0x1020
+#define TALITOS_ID_HI           0x1024
+
+#define TALITOS_EUASR           0x1028          /* EU Assaginment status register is useless*/
+#define TALITOS_EUASR_HI        0x102C          /* EU Assaginment status register is useless*/
+
+#define TALITOS_MCR             0x1030          /* master control register */
+#define TALITOS_MCR_HI          0x1038          /* master control register */
+#define TALITOS_MCR_SWR         0x01000000
+#else
+/* global register offset addresses */
+#define TALITOS_EUACR           0x1000          /* EU Assaginment controller register*/
+#define TALITOS_EUACR_HI        0x1004          /* EU Assaginment controller register*/
+#define TALITOS_IMR             0x1008          /* interrupt mask register */
+#define TALITOS_IMR_ALL         0x00010fff      /* enable all interrupts mask */
+#define TALITOS_IMR_ERRONLY     0x00010aaa      /* enable error interrupts */
+#define TALITOS_IMR_HI          0x100C          /* interrupt mask register */
+#define TALITOS_IMR_HI_ALL      0x00020000      /* enable all channel interrupts mask */
+#define TALITOS_IMR_HI_ERRONLY  0x00222222      /* enable error interrupts */
+#define TALITOS_ISR             0x1010          /* interrupt status register */
+#define TALITOS_ISR_ERROR       0x00010faa      /* errors mask */
+#define TALITOS_ISR_DONE        0x00000055      /* channel(s) done mask */
+#define TALITOS_ISR_HI          0x1014          /* interrupt status register */
+#define TALITOS_ICR             0x1018          /* interrupt clear register */
+#define TALITOS_ICR_HI          0x101C          /* interrupt clear register */
+#define TALITOS_ID              0x1020
+#define TALITOS_ID_HI           0x1024
+#define TALITOS_EUASR           0x1028          /* EU Assaginment status register*/
+#define TALITOS_EUASR_HI        0x102C          /* EU Assaginment status register*/
+#define TALITOS_MCR             0x1030          /* master control register */
+#define TALITOS_MCR_HI          0x1038          /* master control register */
+#define TALITOS_MCR_SWR         0x1
+#endif
+/*
+ * In fact, both ocf sec2 driver and sec1.1 driver of 2.6.10-mcf547x do not static assignment any EU to any channel
+ * so the TALITOS_EUACR and TALITOS_EUASR are not used in driver.
+ */
+#ifdef FSL_SEC11_MCF547X_8X
+/* channel register address stride */
+#define TALITOS_CH_OFFSET       0x1000
+
+/* channel register offset addresses and bits */
+#define TALITOS_CH_CCCR         0x200c  /* Crypto-Channel Config Register */
+#define TALITOS_CH_CCCR_RESET   0x1     /* Channel Reset bit */
+#define TALITOS_CH_CCCR_CDWE    0x10    /* Channel done writeback enable bit */
+#define TALITOS_CH_CCCR_NE      0x8     /* Fetch Next Descriptor Enable bit */
+#define TALITOS_CH_CCCR_NT      0x4     /* Notification type bit */
+#define TALITOS_CH_CCCR_CDIE    0x2     /* Channel Done Interrupt Enable bit */
+
+#define TALITOS_CH_CCPSR        0x2014  /* Crypto-Channel Pointer Status Reg */
+#define TALITOS_CH_CCPSR_HI     0x2010  /* Crypto-Channel Pointer Status Reg */
+
+#define TALITOS_CH_FF           0x204c  /* Fetch FIFO */
+#define TALITOS_CH_FF_HI        0x2048  /* Fetch FIFO is useless in MCF547X and MCF548X*/
+
+#define TALITOS_CH_CDPR         0x2044  /* Crypto-Channel Pointer Status Reg */
+#define TALITOS_CH_CDPR_HI      0x2044  /* Crypto-Channel Pointer Status Reg ?????????????????*/
+
+#define TALITOS_CH_DESCBUF      0x2080  /* (thru 11bf) Crypto-Channel 
+                                         * Descriptor Buffer (debug) 0x2080-0x20BF*/
+#else
+/* channel register address stride */
+#define TALITOS_CH_OFFSET	0x100
+
+/* channel register offset addresses and bits */
+#define TALITOS_CH_CCCR		0x1108	/* Crypto-Channel Config Register */
+#define TALITOS_CH_CCCR_RESET	0x1	/* Channel Reset bit */
+#define TALITOS_CH_CCCR_HI	0x110c	/* Crypto-Channel Config Register */
+#define TALITOS_CH_CCCR_HI_CDWE	0x10	/* Channel done writeback enable bit */
+#define TALITOS_CH_CCCR_HI_NT	0x4	/* Notification type bit */
+#define TALITOS_CH_CCCR_HI_CDIE	0x2	/* Channel Done Interrupt Enable bit */
+#define TALITOS_CH_CCPSR	0x1110	/* Crypto-Channel Pointer Status Reg */
+#define TALITOS_CH_CCPSR_HI	0x1114	/* Crypto-Channel Pointer Status Reg */
+#define TALITOS_CH_FF		0x1148	/* Fetch FIFO */
+#define TALITOS_CH_FF_HI	0x114c	/* Fetch FIFO's FETCH_ADRS */
+#define TALITOS_CH_CDPR		0x1140	/* Crypto-Channel Pointer Status Reg */
+#define TALITOS_CH_CDPR_HI	0x1144	/* Crypto-Channel Pointer Status Reg */
+#define TALITOS_CH_DESCBUF	0x1180	/* (thru 11bf) Crypto-Channel 
+					 * Descriptor Buffer (debug) */
+#endif
+
+/* execution unit register offset addresses and bits */
+#ifdef FSL_SEC11_MCF547X_8X
+#define TALITOS_DEURCR          0xa018  /* DEU reset control register */
+#define TALITOS_DEURCR_RESET    0x01000000  /* DEU reset bit */
+#define TALITOS_DEUSR		0xa028	/* DEU status register */
+#define TALITOS_DEUSR_RESET     0x01000000  /* DEU Reset status bit */
+#define TALITOS_DEUSR_HI	0xa02c	/* DEU status register is useless in MCF547X_548X*/
+#define TALITOS_DEUISR		0xa030	/* DEU interrupt status register */
+#define TALITOS_DEUISR_HI	0xa034	/* DEU interrupt status register is useless in MCF547X_548X**/
+#define TALITOS_DEUICR		0xa038	/* DEU interrupt control register */
+#define TALITOS_DEUICR_MASK     0xf63f0000  /* DEU interrupt control mask*/
+#define TALITOS_DEUICR_HI	0xa03c	/* DEU interrupt control register is useless in MCF547X_548X**/
+
+#define TALITOS_AESURCR         0x12018  /* AESU reset control register */
+#define TALITOS_AESURCR_RESET   0x01000000  /* AESU reset bit */
+#define TALITOS_AESUSR          0x12028  /* AESU status register */
+#define TALITOS_AESUSR_RESET    0x01000000  /* AESU Reset status bit */
+#define TALITOS_AESUSR_HI       0x1202c  /* AESU status register is useless in MCF547X_548X*/
+#define TALITOS_AESUISR         0x12030  /* AESU interrupt status register */
+#define TALITOS_AESUISR_HI      0x12034  /* AESU interrupt status register is useless in MCF547X_548X**/
+#define TALITOS_AESUICR         0x12038  /* AESU interrupt control register */
+#define TALITOS_AESUICR_MASK    0xf61f0000  /* AESU interrupt control mask*/
+#define TALITOS_AESUICR_HI      0x1203c  /* AESU interrupt control register is useless in MCF547X_548X**/
+
+#define TALITOS_MDEURCR         0xc018  /* MDEU reset control register */
+#define TALITOS_MDEURCR_RESET   0x01000000  /* MDEU reset bit */
+#define TALITOS_MDEUSR          0xc028  /* MDEU status register */
+#define TALITOS_MDEUSR_RESET    0x01000000  /* MDEU Reset status bit */
+#define TALITOS_MDEUSR_HI       0xc02c  /* MDEU status register is useless in MCF547X_548X*/
+#define TALITOS_MDEUISR         0xc030  /* MDEU interrupt status register */
+#define TALITOS_MDEUISR_HI      0xc034  /* MDEU interrupt status register is useless in MCF547X_548X**/
+#define TALITOS_MDEUICR         0xc038  /* MDEU interrupt control register */
+#define TALITOS_MDEUICR_MASK    0xc41f0000  /* MDEU interrupt control mask*/
+#define TALITOS_MDEUICR_HI      0xc03c  /* MDEU interrupt control register is useless in MCF547X_548X**/
+
+#define TALITOS_AFEURCR         0x8018  /* AFEU reset control register */
+#define TALITOS_AFEURCR_RESET   0x01000000  /* AFEU reset bit */
+#define TALITOS_AFEUSR          0x8028  /* AFEU status register */
+#define TALITOS_AFEUSR_RESET    0x01000000  /* AFEU Reset status bit */
+#define TALITOS_AFEUSR_HI       0x802c  /* AFEU status register is useless in MCF547X_548X*/
+#define TALITOS_AFEUISR         0x8030  /* AFEU interrupt status register */
+#define TALITOS_AFEUISR_HI      0x8034  /* AFEU interrupt status register is useless in MCF547X_548X**/
+#define TALITOS_AFEUICR         0x8038  /* AFEU interrupt control register */
+#define TALITOS_AFEUICR_MASK    0xf61f0000  /* AFEU interrupt control mask*/
+#define TALITOS_AFEUICR_HI      0x803c  /* AFEU interrupt control register is useless in MCF547X_548X**/
+
+#define TALITOS_RNGRCR          0xe018  /* RNG Reset control register */
+#define TALITOS_RNGRCR_HI       0xe01c  /* RNG Reset control register is useless in MCF547X_548X*/
+#define TALITOS_RNGRCR_SR       0x01000000      /* RNG RNGRCR:Software Reset */
+#define TALITOS_RNGSR		0xe028	/* RNG status register */
+#define TALITOS_RNGSR_HI	0xe02c	/* RNG status register is useless in MCF547X_548X*/
+#define TALITOS_RNGSR_RD	0x01000000	/* RNG Reset done */
+#define TALITOS_RNGSR_HI_OFL	0xff0000/* number of dwords in RNG output FIFO*/
+#define TALITOS_RNGDSR		0xe010	/* RNG data size register */
+#define TALITOS_RNGDSR_HI	0xe014	/* RNG data size register is useless in MCF547X_548X*/
+#define TALITOS_RNG_FIFO	0xe800	/* RNG FIFO - pool of random numbers */
+#define TALITOS_RNGISR		0xe030	/* RNG Interrupt status register */
+#define TALITOS_RNGISR_HI	0xe034	/* RNG Interrupt status register is useless in MCF547X_548X */
+#define TALITOS_RNGICR          0xe038  /* RNG interrupt control register */
+#define TALITOS_RNGICR_MASK     0xc2100000  /* RNG interrupt control mask*/
+#define TALITOS_RNGICR_HI       0xe03c  /* RNG interrupt control register is useless in MCF547X_548X**/
+#else
+#define TALITOS_DEUSR           0x2028  /* DEU status register */
+#define TALITOS_DEUSR_HI        0x202c  /* DEU status register */
+#define TALITOS_DEUISR          0x2030  /* DEU interrupt status register */
+#define TALITOS_DEUISR_HI       0x2034  /* DEU interrupt status register */
+#define TALITOS_DEUICR          0x2038  /* DEU interrupt control register */
+#define TALITOS_DEUICR_HI       0x203c  /* DEU interrupt control register */
+#define TALITOS_AESUISR         0x4030  /* AESU interrupt status register */
+#define TALITOS_AESUISR_HI      0x4034  /* AESU interrupt status register */
+#define TALITOS_AESUICR         0x4038  /* AESU interrupt control register */
+#define TALITOS_AESUICR_HI      0x403c  /* AESU interrupt control register */
+#define TALITOS_MDEUISR         0x6030  /* MDEU interrupt status register */
+#define TALITOS_MDEUISR_HI      0x6034  /* MDEU interrupt status register */
+#define TALITOS_RNGSR           0xa028  /* RNG status register */
+#define TALITOS_RNGSR_HI        0xa02c  /* RNG status register */
+#define TALITOS_RNGSR_HI_RD     0x1     /* RNG Reset done */
+#define TALITOS_RNGSR_HI_OFL    0xff0000/* number of dwords in RNG output FIFO*/
+#define TALITOS_RNGDSR          0xa010  /* RNG data size register */
+#define TALITOS_RNGDSR_HI       0xa014  /* RNG data size register */
+#define TALITOS_RNG_FIFO        0xa800  /* RNG FIFO - pool of random numbers */
+#define TALITOS_RNGISR          0xa030  /* RNG Interrupt status register */
+#define TALITOS_RNGISR_HI       0xa034  /* RNG Interrupt status register */
+#define TALITOS_RNGRCR          0xa018  /* RNG Reset control register */
+#define TALITOS_RNGRCR_HI       0xa01c  /* RNG Reset control register */
+#define TALITOS_RNGRCR_HI_SR    0x1     /* RNG RNGRCR:Software Reset */
+#endif
+
+#ifdef FSL_SEC11_MCF547X_8X
+/* descriptor pointer entry */
+struct talitos_desc_ptr {
+        u32     len;
+        u32     ptr;            /* pointer */
+
+};
+
+/* descriptor */
+struct talitos_desc {
+	u32	hdr;				/* header */
+	struct talitos_desc_ptr		ptr[7];	/* ptr/len pair array */
+	u32     next_hdr;
+};
+#else
+/* descriptor pointer entry */
+struct talitos_desc_ptr {
+        u16     len;            /* length */
+        u8      extent;         /* jump (to s/g link table) and extent */
+        u8      res;            /* reserved */
+        u32     ptr;            /* pointer */
+};
+
+/* descriptor */
+struct talitos_desc {
+        u32     hdr;                            /* header */
+        u32     res;                            /* reserved */
+        struct talitos_desc_ptr         ptr[7]; /* ptr/len pair array */
+};
+#endif
+
+/***************************RC4*******************/
+#define ARC4_SEC_MIN_KEY_SIZE   5
+#define ARC4_SEC_MAX_KEY_SIZE   16
+#define ARC4_SEC_CONTEXT_LEN    259
+#define   SEC_ALG_AFEU_KEY              0x10200050
+#define   SEC_ALG_AFEU_CONTEXT          0x10700050
+
+/* talitos descriptor header (hdr) bits */
+
+/* primary execution unit select */
+#define	TALITOS_SEL0_AFEU	0x10000000
+#define	TALITOS_SEL0_DEU	0x20000000
+#define	TALITOS_SEL0_MDEU	0x30000000
+#define	TALITOS_SEL0_RNG	0x40000000
+#define	TALITOS_SEL0_PKEU	0x50000000
+#define	TALITOS_SEL0_AESU	0x60000000
+
+/* primary execution unit mode (MODE0) and derivatives */
+#define	TALITOS_MODE0_AESU_CBC		0x00200000
+#define	TALITOS_MODE0_AESU_ENC		0x00100000
+#define	TALITOS_MODE0_DEU_CBC		0x00400000
+#define	TALITOS_MODE0_DEU_3DES		0x00200000
+#define	TALITOS_MODE0_DEU_ENC		0x00100000
+#define	TALITOS_MODE0_MDEU_INIT		0x01000000	/* init starting regs */
+#define	TALITOS_MODE0_MDEU_HMAC		0x00800000
+#define	TALITOS_MODE0_MDEU_PAD		0x00400000	/* PD */
+#define	TALITOS_MODE0_MDEU_MD5		0x00200000
+#define	TALITOS_MODE0_MDEU_SHA256	0x00100000
+#define	TALITOS_MODE0_MDEU_SHA1		0x00000000	/* SHA-160 */
+#define	TALITOS_MODE0_MDEU_MD5_HMAC	\
+		(TALITOS_MODE0_MDEU_MD5 | TALITOS_MODE0_MDEU_HMAC)
+#define	TALITOS_MODE0_MDEU_SHA256_HMAC	\
+		(TALITOS_MODE0_MDEU_SHA256 | TALITOS_MODE0_MDEU_HMAC)
+#define	TALITOS_MODE0_MDEU_SHA1_HMAC	\
+		(TALITOS_MODE0_MDEU_SHA1 | TALITOS_MODE0_MDEU_HMAC)
+
+/* secondary execution unit select (SEL1) */
+/* it's MDEU or nothing */
+#define	TALITOS_SEL1_MDEU	0x00030000
+
+/* secondary execution unit mode (MODE1) and derivatives */
+#define	TALITOS_MODE1_MDEU_INIT		0x00001000	/* init starting regs */
+#define	TALITOS_MODE1_MDEU_HMAC		0x00000800
+#define	TALITOS_MODE1_MDEU_PAD		0x00000400	/* PD */
+#define	TALITOS_MODE1_MDEU_MD5		0x00000200
+#define	TALITOS_MODE1_MDEU_SHA256	0x00000100
+#define	TALITOS_MODE1_MDEU_SHA1		0x00000000	/* SHA-160 */
+#define	TALITOS_MODE1_MDEU_MD5_HMAC	\
+	(TALITOS_MODE1_MDEU_MD5 | TALITOS_MODE1_MDEU_HMAC)
+#define	TALITOS_MODE1_MDEU_SHA256_HMAC	\
+	(TALITOS_MODE1_MDEU_SHA256 | TALITOS_MODE1_MDEU_HMAC)
+#define	TALITOS_MODE1_MDEU_SHA1_HMAC	\
+	(TALITOS_MODE1_MDEU_SHA1 | TALITOS_MODE1_MDEU_HMAC)
+
+/* direction of overall data flow (DIR) */
+#define	TALITOS_DIR_OUTBOUND	0x00000000
+#define	TALITOS_DIR_INBOUND	0x00000002
+
+/* done notification (DN) */
+#define	TALITOS_DONE_NOTIFY	0x00000001
+
+/* descriptor types */
+/* odd numbers here are valid on SEC2 and greater only (e.g. ipsec_esp) */
+#define TD_TYPE_AESU_CTR_NONSNOOP	(0 << 3)
+#define TD_TYPE_IPSEC_ESP		(1 << 3)
+#define TD_TYPE_COMMON_NONSNOOP_NO_AFEU	(2 << 3)
+#define TD_TYPE_HMAC_SNOOP_NO_AFEU	(4 << 3)
+
+#define TALITOS_HDR_DONE_BITS	0xff000000
+
+#define	DPRINTF(a...)	if (debug) { printk(DRV_NAME ": " a); }
diff --git a/crypto/ocf/talitos/talitos_soft.h b/crypto/ocf/talitos/talitos_soft.h
new file mode 100644
index 0000000..e08e806
--- /dev/null
+++ b/crypto/ocf/talitos/talitos_soft.h
@@ -0,0 +1,83 @@
+/*
+ * Freescale SEC data structures for integration with ocf-linux
+ *
+ * Copyright 2006-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * paired descriptor and associated crypto operation
+ */
+struct desc_cryptop_pair {
+	struct list_head 	desc_list;      /* AK for tasklet design */
+	spinlock_t  		desc_lock;      /* AK for protecting header */
+	struct talitos_desc	cf_desc;	/* descriptor ptr */
+	struct cryptop		*cf_crp;	/* cryptop ptr */
+};
+
+/*
+ * Holds data specific to a single talitos device.
+ */
+struct talitos_softc {
+	struct platform_device	*sc_dev;	/* device backpointer */
+	/*ocf_iomem_t*/void __iomem		*sc_base_addr;
+	int			sc_irq;
+	int			sc_num;		/* if we have multiple chips */
+	int32_t			sc_cid;		/* crypto tag */
+	u64			sc_chiprev;	/* major/minor chip revision */
+	int			sc_nsessions;
+	struct talitos_session	*sc_sessions;
+	int			sc_num_channels;/* number of crypto channels */
+	int			sc_chfifo_len;	/* channel fetch fifo len */
+	int			sc_exec_units;	/* execution units mask */
+	int			sc_desc_types;	/* descriptor types mask */
+	int			sc_needwakeup;  /* AK added */
+	int			sc_rc4_first;   /*Shrek added*/
+	/* sc_chnlastalgo contains last algorithm for that channel */
+	int			*sc_chnlastalg;
+	/* sc_chnfifo holds pending descriptor--crypto operation pairs */
+	struct desc_cryptop_pair	**sc_chnfifo;
+};
+
+struct talitos_session {
+	u_int32_t	ses_used;
+	u_int32_t	ses_klen;		/* key length in bits */
+	u_int32_t	ses_key[8];		/* DES/3DES/AES key */
+	u_int32_t	ses_hmac[5];		/* hmac inner state */
+	u_int32_t	ses_hmac_len;		/* hmac length */
+	u_int32_t	ses_iv[4];		/* DES/3DES/AES iv */
+};
+
+#define	TALITOS_SESSION(sid)	((sid) & 0x0fffffff)
+#define	TALITOS_SID(crd, sesn)	(((crd) << 28) | ((sesn) & 0x0fffffff))
+
+/* AK added the following */
+//#define  TALITOS_SMALL_PACKET_IMPROVE
+//#define  TALITOS_SMALL_PACKET_IMPROVE_NEW
+//#define  TALITOS_INTERRUPT_COALESCE
+//#define  TALITOS_KERNEL_TIMER
+//#define TALITOS_BASELINE
+#define TALITOS_TASKLET
+
diff --git a/drivers/char/random.c b/drivers/char/random.c
index 7c13581..f3bbfc2 100644
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@ -1,6 +1,8 @@
 /*
  * random.c -- A strong random number generator
  *
+ * Copyright 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
  * Copyright Matt Mackall <mpm@selenic.com>, 2003, 2004, 2005
  *
  * Copyright Theodore Ts'o, 1994, 1995, 1996, 1997, 1998, 1999.  All
@@ -128,6 +130,8 @@
  * 	void add_input_randomness(unsigned int type, unsigned int code,
  *                                unsigned int value);
  * 	void add_interrupt_randomness(int irq);
+ * void random_input_words(__u32 *buf, size_t wordcount, int ent_count)
+ * int random_input_wait(void);
  *
  * add_input_randomness() uses the input layer interrupt timing, as well as
  * the event type information from the hardware.
@@ -140,6 +144,13 @@
  * a better measure, since the timing of the disk interrupts are more
  * unpredictable.
  *
+ * random_input_words() just provides a raw block of entropy to the input
+ * pool, such as from a hardware entropy generator.
+ *
+ * random_input_wait() suspends the caller until such time as the
+ * entropy pool falls below the write threshold, and returns a count of how
+ * much entropy (in bits) is needed to sustain the pool.
+ *
  * All of these routines try to estimate how many bits of randomness a
  * particular randomness source.  They do this by keeping track of the
  * first and second order deltas of the event timings.
@@ -707,7 +718,60 @@ void add_disk_randomness(struct gendisk *disk)
 	add_timer_randomness(disk->random, 0x100 + disk_devt(disk));
 }
 #endif
+/*
+ *  random_input_words - add bulk entropy to pool
+ *
+ *  @buf: buffer to add
+ *  @wordcount: number of __u32 words to add
+ *  @ent_count: total amount of entropy (in bits) to credit
+ *  
+ *  this provides bulk input of entropy to the input pool
+ *
+ */
+void random_input_words(__u32 *buf, size_t wordcount, int ent_count)
+{
+	mix_pool_bytes(&input_pool, buf, wordcount);
+
+	credit_entropy_bits(&input_pool, ent_count);
+
+	DEBUG_ENT("crediting %d bits from OCF => %d\n",
+		ent_count, input_pool.entropy_count);
+	/*
+	* Wake up waiting processes if we have enough
+	* entropy.
+	*/
+	if (input_pool.entropy_count >= random_read_wakeup_thresh)
+		wake_up_interruptible(&random_read_wait);
+}
+EXPORT_SYMBOL(random_input_words);
+
+/*
+ *  random_input_wait - wait until random needs entropy
+ *
+ *  this function sleeps until the /dev/random subsystem actually
+ *  needs more entropy, and then return the amount of entropy
+ *  that it would be nice to have added to the system.
+ */
+int random_input_wait(void)
+{
+	int count;
+
+	wait_event_interruptible(random_write_wait,
+		input_pool.entropy_count < random_write_wakeup_thresh);
+
+	count = random_write_wakeup_thresh - input_pool.entropy_count;
 
+	/* likely we got woken up due to a signal */
+	if (count < 0)
+		count = random_read_wakeup_thresh;
+
+		DEBUG_ENT("requesting %d bits from input_wait()er %d<%d\n",
+			count, input_pool.entropy_count,
+			random_write_wakeup_thresh);
+
+	return count;
+}
+EXPORT_SYMBOL(random_input_wait);
 #define EXTRACT_SIZE 10
 
 /*********************************************************************
diff --git a/drivers/crypto/geode-aes.c b/drivers/crypto/geode-aes.c
index 4801162..deace6e 100644
--- a/drivers/crypto/geode-aes.c
+++ b/drivers/crypto/geode-aes.c
@@ -13,7 +13,7 @@
 #include <linux/crypto.h>
 #include <linux/spinlock.h>
 #include <crypto/algapi.h>
-#include <crypto/aes.h>
+#include <crypto/aes_generic.h>
 
 #include <asm/io.h>
 #include <asm/delay.h>
diff --git a/drivers/crypto/hifn_795x.c b/drivers/crypto/hifn_795x.c
index 0c79fe7..9fe746c 100644
--- a/drivers/crypto/hifn_795x.c
+++ b/drivers/crypto/hifn_795x.c
@@ -34,7 +34,7 @@
 #include <linux/ktime.h>
 
 #include <crypto/algapi.h>
-#include <crypto/des.h>
+#include <crypto/des_generic.h>
 
 #include <asm/kmap_types.h>
 
diff --git a/drivers/crypto/padlock-aes.c b/drivers/crypto/padlock-aes.c
index 3f0fdd1..5b4e5c3 100644
--- a/drivers/crypto/padlock-aes.c
+++ b/drivers/crypto/padlock-aes.c
@@ -8,7 +8,7 @@
  */
 
 #include <crypto/algapi.h>
-#include <crypto/aes.h>
+#include <crypto/aes_generic.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/types.h>
diff --git a/include/crypto/aes.h b/include/crypto/aes.h
index 656a4c6..5dba360 100644
--- a/include/crypto/aes.h
+++ b/include/crypto/aes.h
@@ -7,7 +7,9 @@
 
 #include <linux/types.h>
 #include <linux/crypto.h>
-
+#ifdef CONFIG_OCF_OCF
+#include "ocf_aes.h"
+#endif
 #define AES_MIN_KEY_SIZE	16
 #define AES_MAX_KEY_SIZE	32
 #define AES_KEYSIZE_128		16
diff --git a/include/crypto/des.h b/include/crypto/des.h
index 2971c63..d9275fb 100644
--- a/include/crypto/des.h
+++ b/include/crypto/des.h
@@ -4,16 +4,7 @@
 
 #ifndef __CRYPTO_DES_H
 #define __CRYPTO_DES_H
-
-#define DES_KEY_SIZE		8
-#define DES_EXPKEY_WORDS	32
-#define DES_BLOCK_SIZE		8
-
-#define DES3_EDE_KEY_SIZE	(3 * DES_KEY_SIZE)
-#define DES3_EDE_EXPKEY_WORDS	(3 * DES_EXPKEY_WORDS)
-#define DES3_EDE_BLOCK_SIZE	DES_BLOCK_SIZE
-
-
-extern unsigned long des_ekey(u32 *pe, const u8 *k);
-
+#ifdef CONFIG_OCF_OCF
+#include "ocf_des.h"
+#endif
 #endif /* __CRYPTO_DES_H */
diff --git a/include/linux/miscdevice.h b/include/linux/miscdevice.h
index a820f81..8d3a555 100644
--- a/include/linux/miscdevice.h
+++ b/include/linux/miscdevice.h
@@ -12,6 +12,7 @@
 #define APOLLO_MOUSE_MINOR	7
 #define PC110PAD_MINOR		9
 /*#define ADB_MOUSE_MINOR	10	FIXME OBSOLETE */
+#define CRYPTODEV_MINOR          70     /* OCF async crypto */
 #define WATCHDOG_MINOR		130	/* Watchdog timer     */
 #define TEMP_MINOR		131	/* Temperature Sensor */
 #define RTC_MINOR		135
diff --git a/include/linux/pid.h b/include/linux/pid.h
index 49f1c2f..ac6346e 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -111,7 +111,9 @@ extern struct pid_namespace init_pid_ns;
  */
 extern struct pid *find_pid_ns(int nr, struct pid_namespace *ns);
 extern struct pid *find_vpid(int nr);
-
+#if defined(CONFIG_OCF_OCF)
+extern struct pid *find_pid(int nr);
+#endif
 /*
  * Lookup a PID in the hash table, and return with it's count elevated.
  */
diff --git a/include/linux/random.h b/include/linux/random.h
index 25d02fe..1128e84 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -50,6 +50,12 @@ extern void add_input_randomness(unsigned int type, unsigned int code,
 				 unsigned int value);
 extern void add_interrupt_randomness(int irq);
 
+#ifdef CONFIG_OCF_OCF
+extern void random_input_words(__u32 *buf,
+	size_t wordcount, int ent_count);
+extern int random_input_wait(void);
+#endif
+
 extern void get_random_bytes(void *buf, int nbytes);
 void generate_random_uuid(unsigned char uuid_out[16]);
 
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 011db2f..2002229 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1888,6 +1888,9 @@ extern int kill_pid_info_as_uid(int, struct siginfo *, struct pid *, uid_t, uid_
 extern int kill_pgrp(struct pid *pid, int sig, int priv);
 extern int kill_pid(struct pid *pid, int sig, int priv);
 extern int kill_proc_info(int, struct siginfo *, pid_t);
+#if defined(CONFIG_OCF_OCF)
+extern int kill_proc(pid_t, int, int);
+#endif
 extern int do_notify_parent(struct task_struct *, int);
 extern void force_sig(int, struct task_struct *);
 extern void force_sig_specific(int, struct task_struct *);
diff --git a/kernel/pid.c b/kernel/pid.c
index 1b3586f..2e293ee 100644
--- a/kernel/pid.c
+++ b/kernel/pid.c
@@ -308,7 +308,13 @@ struct pid *find_vpid(int nr)
 	return find_pid_ns(nr, current->nsproxy->pid_ns);
 }
 EXPORT_SYMBOL_GPL(find_vpid);
-
+#if defined(CONFIG_OCF_OCF)
+struct pid *find_pid(int nr)
+{
+	        return find_pid_ns(nr, &init_pid_ns);
+}
+EXPORT_SYMBOL_GPL(find_pid);
+#endif
 /*
  * attach_pid() must be called with the tasklist_lock write-held.
  */
diff --git a/kernel/signal.c b/kernel/signal.c
index 1c88144..1aca9ca 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -1261,7 +1261,19 @@ int kill_pid(struct pid *pid, int sig, int priv)
 	return kill_pid_info(sig, __si_special(priv), pid);
 }
 EXPORT_SYMBOL(kill_pid);
+#if defined(CONFIG_OCF_OCF)
+int
+kill_proc(pid_t pid, int sig, int priv)
+{
+	int ret;
 
+	rcu_read_lock();
+	ret = kill_pid_info(sig, __si_special(priv), find_pid(pid));
+	rcu_read_unlock();
+	return ret;
+}
+EXPORT_SYMBOL(kill_proc);
+#endif
 /*
  * These functions support sending signals using preallocated sigqueue
  * structures.  This is needed "because realtime applications cannot
diff --git a/net/Kconfig b/net/Kconfig
index cdb8fde..41e2b62 100644
--- a/net/Kconfig
+++ b/net/Kconfig
@@ -251,4 +251,8 @@ source "net/wimax/Kconfig"
 source "net/rfkill/Kconfig"
 source "net/9p/Kconfig"
 
+if INET
+source "net/ipsec/Kconfig"
+endif
+
 endif   # if NET
diff --git a/net/Makefile b/net/Makefile
index 0fcce89..4723df1 100644
--- a/net/Makefile
+++ b/net/Makefile
@@ -64,3 +64,4 @@ ifeq ($(CONFIG_NET),y)
 obj-$(CONFIG_SYSCTL)		+= sysctl_net.o
 endif
 obj-$(CONFIG_WIMAX)		+= wimax/
+obj-$(CONFIG_KLIPS)             += ipsec/
diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c
index 743f554..0caa5d8 100644
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -1599,6 +1599,16 @@ static int __init inet_init(void)
 	if (ip_mr_init())
 		printk(KERN_CRIT "inet_init: Cannot init ipv4 mroute\n");
 #endif
+#if defined(CONFIG_KLIPS)
+	{
+		extern int ipsec_klips_init(void);
+		/*
+		* Initialize AF_INET ESP and AH protocol support including
+		* e-routing and SA tables
+		*/
+		ipsec_klips_init();
+	}
+	#endif /* CONFIG_KLIPS */
 	/*
 	 *	Initialise per-cpu ipv4 mibs
 	 */
-- 
1.6.4

