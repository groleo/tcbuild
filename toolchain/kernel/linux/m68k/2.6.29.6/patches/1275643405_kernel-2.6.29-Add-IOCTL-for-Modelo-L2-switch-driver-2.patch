From d7f9120a4d5ba825a1640095387b9d388f1319ac Mon Sep 17 00:00:00 2001
From: Shrek Wu <b16972@freescale.com>
Date: Fri, 4 Jun 2010 17:23:25 +0800
Subject: [PATCH] Add IOCTL for Modelo L2 switch driver

This patch add some ioctrl to l2 switch driver for the l2
switch function usage and testing.

Signed-off-by: Shrek Wu <b16972@freescale.com>
---
 arch/m68k/coldfire/m5441x/l2switch.c |    4 -
 drivers/net/modelo_switch.c          | 1207 ++++++++++++++++++++++++++++++----
 drivers/net/modelo_switch.h          |  105 +++-
 net/core/dev.c                       |    9 +-
 4 files changed, 1171 insertions(+), 154 deletions(-)

diff --git a/arch/m68k/coldfire/m5441x/l2switch.c b/arch/m68k/coldfire/m5441x/l2switch.c
index 14303dc..0a11994 100644
--- a/arch/m68k/coldfire/m5441x/l2switch.c
+++ b/arch/m68k/coldfire/m5441x/l2switch.c
@@ -75,10 +75,6 @@ static void switch_request_intrs(struct net_device *dev,
 			idp->name, irq_privatedata) != 0)
 			printk(KERN_ERR "FEC: Could not alloc %s IRQ(%d)!\n",
 				idp->name, b+idp->irq);
-		else {
-			printk(KERN_ERR "%s: MCF_INTC2_ICR(%d) %x\n",
-				__func__, idp->irq, MCF_INTC2_ICR(idp->irq));
-		}
 	}
 
 	/* Configure RMII */
diff --git a/drivers/net/modelo_switch.c b/drivers/net/modelo_switch.c
index d783bb8..000a36b 100644
--- a/drivers/net/modelo_switch.c
+++ b/drivers/net/modelo_switch.c
@@ -767,20 +767,7 @@ void esw_basic_switching(struct switch_enet_private *fep)
 	unsigned long tmp;
 
 	fecp = fep->hwp;
-	fecp->ESW_DBCR = MCF_ESW_DBCR_P1;
-
-	/* transmit packet
-	tx_packet.length = sizeof(ping_packet);
-	tx_packet.data = (uint8*)ping_packet;
-	transmit_packet(&tx_packet);
-
-	if(!wait_for_frame_receive(10000)) {
-		printk("%s: Timeout while waiting for packet\n", __func__);
-		return;
-	}
-	Get packet pointer and length
-	get_received_packet(&rx_packet);
-	Compare packet*/
+	fecp->ESW_DBCR = MCF_ESW_DBCR_P1 | MCF_ESW_DBCR_P2;
 }
 
 /*
@@ -790,17 +777,14 @@ void esw_basic_switching(struct switch_enet_private *fep)
  * all other filtering(eg.VLAN verification) act as normal
  */
 int esw_forced_forward(struct switch_enet_private *fep,
-	int port1, int port2)
+	int port1, int port2, int enable)
 {
-	unsigned long tmp = 0;
+	unsigned long tmp = 0, tmp1 = 0;
 	volatile switch_t  *fecp;
 
 	fecp = fep->hwp;
-	/* Enable Deafault broadcast for port 0 */
-	MCF_ESW_DBCR = MCF_ESW_DBCR_P0;
 
 	/* Enable Forced forwarding for port num */
-	tmp = MCF_ESW_P0FFEN_FEN;
 	if ((port1 == 1) && (port2 == 1))
 		tmp |= MCF_ESW_P0FFEN_FD(3);
 	else if (port1 == 1)
@@ -817,10 +801,47 @@ int esw_forced_forward(struct switch_enet_private *fep,
 		return -1;
 	}
 
+	if (enable == 1)
+		tmp |= MCF_ESW_P0FFEN_FEN;
+	else if (enable == 0)
+		tmp &= ~MCF_ESW_P0FFEN_FEN;
+	else {
+		printk(KERN_ERR "%s: the enable %x is error\n",
+			__func__, enable);
+		return -2;
+	}
+
 	fecp->ESW_P0FFEN = tmp;
 	return 0;
 }
 
+int esw_get_forced_forward(
+	struct switch_enet_private *fep,
+	unsigned long *ulForceForward)
+{
+	volatile switch_t  *fecp;
+
+	fecp = fep->hwp;
+	*ulForceForward = fecp->ESW_P0FFEN;
+#ifdef debug_forced_forward
+	printk(KERN_INFO "%s  ESW_P0FFEN %x\n",
+		__func__, fecp->ESW_P0FFEN);
+#endif
+}
+
+void esw_get_port_enable(
+	struct switch_enet_private *fep,
+	unsigned long *ulPortEnable)
+{
+	volatile switch_t  *fecp;
+
+	fecp = fep->hwp;
+	*ulPortEnable = fecp->ESW_PER;
+#ifdef debug_port_enable
+	printk(KERN_INFO "%s  fecp->ESW_PER %x\n",
+		__func__, fecp->ESW_PER);
+#endif
+}
 /*
  * enable or disable port n tx or rx
  * tx_en 0 disable port n tx
@@ -837,11 +858,11 @@ int esw_port_enable_config(struct switch_enet_private *fep,
 	fecp = fep->hwp;
 	tmp = fecp->ESW_PER;
 	if (tx_en == 1) {
-		if (port == 1)
+		if (port == 0)
 			tmp |= MCF_ESW_PER_TE0;
-		else if (port == 2)
+		else if (port == 1)
 			tmp |= MCF_ESW_PER_TE1;
-		else if (port == 3)
+		else if (port == 2)
 			tmp |= MCF_ESW_PER_TE2;
 		else {
 			printk(KERN_ERR "%s:do not support the"
@@ -850,11 +871,11 @@ int esw_port_enable_config(struct switch_enet_private *fep,
 			return -1;
 		}
 	} else if (tx_en == 0) {
-		if (port == 1)
+		if (port == 0)
 			tmp &= (~MCF_ESW_PER_TE0);
-		else if (port == 2)
+		else if (port == 1)
 			tmp &= (~MCF_ESW_PER_TE1);
-		else if (port == 3)
+		else if (port == 2)
 			tmp &= (~MCF_ESW_PER_TE2);
 		else {
 			printk(KERN_ERR "%s:do not support "
@@ -870,11 +891,11 @@ int esw_port_enable_config(struct switch_enet_private *fep,
 	}
 
 	if (rx_en == 1) {
-		if (port == 1)
+		if (port == 0)
 			tmp |= MCF_ESW_PER_RE0;
-		else if (port == 2)
+		else if (port == 1)
 			tmp |= MCF_ESW_PER_RE1;
-		else if (port == 3)
+		else if (port == 2)
 			tmp |= MCF_ESW_PER_RE2;
 		else {
 			printk(KERN_ERR "%s:do not support the "
@@ -883,11 +904,11 @@ int esw_port_enable_config(struct switch_enet_private *fep,
 			return -4;
 		}
 	} else if (rx_en == 0) {
-		if (port == 1)
+		if (port == 0)
 			tmp &= (~MCF_ESW_PER_RE0);
-		else if (port == 2)
+		else if (port == 1)
 			tmp &= (~MCF_ESW_PER_RE1);
-		else if (port == 3)
+		else if (port == 2)
 			tmp &= (~MCF_ESW_PER_RE2);
 		else {
 			printk(KERN_ERR "%s:do not support the "
@@ -903,9 +924,25 @@ int esw_port_enable_config(struct switch_enet_private *fep,
 	}
 
 	fecp->ESW_PER = tmp;
+	printk(KERN_INFO "%s : ESW_PER %x\n", __func__, fecp->ESW_PER);
 	return 0;
 }
 
+
+void esw_get_port_broadcast(
+	struct switch_enet_private *fep,
+	unsigned long *ulPortBroadcast)
+{
+	volatile switch_t  *fecp;
+
+	fecp = fep->hwp;
+	*ulPortBroadcast = fecp->ESW_DBCR;
+#ifdef debug_port_broadcast
+	printk(KERN_INFO "%s  fecp->ESW_DBCR %x\n",
+		__func__, fecp->ESW_DBCR);
+#endif
+}
+
 int esw_port_broadcast_config(
 	struct switch_enet_private *fep,
 	int port, int enable)
@@ -943,6 +980,21 @@ int esw_port_broadcast_config(
 	return 0;
 }
 
+
+void esw_get_port_multicast(
+	struct switch_enet_private *fep,
+	unsigned long *ulPortMulticast)
+{
+	volatile switch_t  *fecp;
+
+	fecp = fep->hwp;
+	ulPortMulticast = fecp->ESW_DMCR;
+#ifdef debug_port_multicast
+	printk(KERN_INFO "%s  fecp->ESW_DMCR %x\n",
+		__func__, fecp->ESW_DMCR);
+#endif
+}
+
 int esw_port_multicast_config(
 	struct switch_enet_private *fep,
 	int port, int enable)
@@ -980,6 +1032,21 @@ int esw_port_multicast_config(
 	return 0;
 }
 
+
+void esw_get_port_blocking(
+	struct switch_enet_private *fep,
+	unsigned long *ulPortBlocking)
+{
+	volatile switch_t  *fecp;
+
+	fecp = fep->hwp;
+	*ulPortBlocking = (fecp->ESW_BKLR & 0x00ff);
+#ifdef debug_port_blocking
+	printk(KERN_INFO "%s  fecp->ESW_BKLR %x\n",
+		__func__, fecp->ESW_BKLR);
+#endif
+}
+
 int esw_port_blocking_config(
 	struct switch_enet_private *fep,
 	int port, int enable)
@@ -1017,6 +1084,21 @@ int esw_port_blocking_config(
 	return 0;
 }
 
+
+void esw_get_port_learning(
+	struct switch_enet_private *fep,
+	unsigned long *ulPortLearning)
+{
+	volatile switch_t  *fecp;
+
+	fecp = fep->hwp;
+	*ulPortLearning = (fecp->ESW_BKLR & 0xff00) >> 16;
+#ifdef debug_port_learning
+	printk(KERN_INFO "%s  fecp->ESW_BKLR %x\n",
+		__func__, fecp->ESW_BKLR);
+#endif
+}
+
 int esw_port_learning_config(
 	struct switch_enet_private *fep,
 	int port, int disable)
@@ -1035,6 +1117,7 @@ int esw_port_learning_config(
 
 	tmp = fecp->ESW_BKLR;
 	if (disable == 1) {
+		fep->learning_irqhandle_enable = 0;
 		if (port == 0)
 			tmp |= MCF_ESW_BKLR_LD0;
 		else if (port == 1)
@@ -1042,6 +1125,8 @@ int esw_port_learning_config(
 		else if (port == 2)
 			tmp |= MCF_ESW_BKLR_LD2;
 	} else if (disable == 0) {
+		fep->learning_irqhandle_enable = 1;
+		fecp->switch_imask |= MCF_ESW_IMR_LRN;
 		if (port == 0)
 			tmp &= ~MCF_ESW_BKLR_LD0;
 		else if (port == 1)
@@ -1051,6 +1136,10 @@ int esw_port_learning_config(
 	}
 
 	fecp->ESW_BKLR = tmp;
+#ifdef debug_port_learning
+	printk(KERN_INFO "%s  ESW_BKLR %x, switch_imask %x\n",
+		__func__, fecp->ESW_BKLR, fecp->switch_imask);
+#endif
 	return 0;
 }
 /*********************************************************************/
@@ -1086,7 +1175,7 @@ void esw_mac_lookup_table_range(struct switch_enet_private *fep)
  * mode 1 : The snooped frame is copy to management port and
  *              normal forwarding is checked.
  * mode 2 : The snooped frame is discarded.
- *
+ * mode 3 : Disable the ip snoop function
  * ip_header_protocol : the IP header protocol field
  */
 int esw_ip_snoop_config(struct switch_enet_private *fep,
@@ -1094,22 +1183,28 @@ int esw_ip_snoop_config(struct switch_enet_private *fep,
 {
 	unsigned long timeout, i;
 	volatile switch_t  *fecp;
-	unsigned long tmp, protocol_type;
+	unsigned long tmp = 0, protocol_type = 0;
 
 	fecp = fep->hwp;
-	/*Enable transmit/receive on all ports*/
-	fecp->ESW_PER = 0x50003;
-	fecp->ESW_P0FFEN = (MCF_ESW_P0FFEN_FD(1) | MCF_ESW_P0FFEN_FEN);
-
-	/* Enable IP Snooping */
-	tmp = MCF_ESW_IPSNP_EN;
-	if (mode == 0)
+	/* Config IP Snooping */
+	if (mode == 0) {
+		/* Enable IP Snooping */
+		tmp = MCF_ESW_IPSNP_EN;
 		tmp |= MCF_ESW_IPSNP_MODE(0);/*For Forward*/
-	else if (mode == 1)/*For Forward and copy_to_mangmnt_port*/
+	} else if (mode == 1) {
+		/* Enable IP Snooping */
+		tmp = MCF_ESW_IPSNP_EN;
+		/*For Forward and copy_to_mangmnt_port*/
 		tmp |= MCF_ESW_IPSNP_MODE(1);
-	else if (mode == 2)
+	} else if (mode == 2) {
+		/* Enable IP Snooping */
+		tmp = MCF_ESW_IPSNP_EN;
 		tmp |= MCF_ESW_IPSNP_MODE(2);/*discard*/
-	else {
+	} else if (mode == 3) {
+		/* disable IP Snooping */
+		tmp = MCF_ESW_IPSNP_EN;
+		tmp &= ~MCF_ESW_IPSNP_EN;
+	} else {
 		printk(KERN_ERR "%s: the mode %x "
 			"we do not support\n", __func__);
 		return -1;
@@ -1118,10 +1213,29 @@ int esw_ip_snoop_config(struct switch_enet_private *fep,
 	protocol_type = ip_header_protocol;
 	fecp->ESW_IPSNP[num] =
 		tmp | MCF_ESW_IPSNP_PROTOCOL(protocol_type);
-
+	printk(KERN_INFO "%s : ESW_IPSNP[%d] %x\n",
+		__func__, num, fecp->ESW_IPSNP[num]);
 	return 0;
 }
 
+void esw_get_ip_snoop_config(
+	struct switch_enet_private *fep,
+	unsigned long *ulpESW_IPSNP)
+{
+	int i;
+	volatile switch_t  *fecp;
+
+	fecp = fep->hwp;
+	for (i = 0; i < 8; i++)
+		*(ulpESW_IPSNP + i) = fecp->ESW_IPSNP[i];
+#ifdef debug_ip_snoop
+	printk(KERN_INFO "%s  ", __func__);
+	for (i = 0; i < 8; i++)
+		printk(KERN_INFO " reg(%d) %x", fecp->ESW_IPSNP[i]);
+	printk(KERN_INFO "\n");
+#endif
+
+}
 /*
  * Checks TCP/UDP Port Snoop options of handling the snooped frame.
  * mode 0 : The snooped frame is forward only to management port
@@ -1141,19 +1255,17 @@ int esw_tcpudp_port_snoop_config(struct switch_enet_private *fep,
 	unsigned long tmp, protocol_type;
 
 	fecp = fep->hwp;
-	/*Enable transmit/receive on all ports*/
-	fecp->ESW_PER = 0x50003;
-	fecp->ESW_P0FFEN = (MCF_ESW_P0FFEN_FD(1) | MCF_ESW_P0FFEN_FEN);
 
 	/* Enable TCP/UDP port Snooping */
-	tmp = MCF_ESW_PSNP_EN |
-		MCF_ESW_PSNP_PORT_COMPARE(compare_port);
+	tmp = MCF_ESW_PSNP_EN;
 	if (mode == 0)
 		tmp |= MCF_ESW_PSNP_MODE(0);/*For Forward*/
 	else if (mode == 1)/*For Forward and copy_to_mangmnt_port*/
 		tmp |= MCF_ESW_PSNP_MODE(1);
 	else if (mode == 2)
 		tmp |= MCF_ESW_PSNP_MODE(2);/*discard*/
+	else if (mode == 3) /*disable the port function*/
+		tmp &= (~MCF_ESW_PSNP_EN);
 	else {
 		printk(KERN_ERR "%s: the mode %x we do not support\n",
 			__func__, mode);
@@ -1175,12 +1287,64 @@ int esw_tcpudp_port_snoop_config(struct switch_enet_private *fep,
 
 	fecp->ESW_PSNP[num] = tmp |
 		MCF_ESW_PSNP_PORT_COMPARE(compare_port);
-
+	printk(KERN_INFO "ESW_PSNP[%d] %x\n",
+			num, fecp->ESW_PSNP[num]);
 	return 0;
 }
 
+void esw_get_tcpudp_port_snoop_config(
+	struct switch_enet_private *fep,
+	unsigned long *ulpESW_PSNP)
+{
+	int i;
+	volatile switch_t  *fecp;
+
+	fecp = fep->hwp;
+	for (i = 0; i < 8; i++)
+		*(ulpESW_PSNP + i) = fecp->ESW_PSNP[i];
+#ifdef debug_tcpudp_port_snoop
+	 printk(KERN_INFO "%s  ", __func__);
+	 for (i = 0; i < 8; i++)
+		printk(KERN_INFO " reg(%d) %x", fecp->ESW_PSNP[i]);
+	 printk(KERN_INFO "\n");
+#endif
+
+}
+/*-----------------mirror----------------------------------------*/
+void esw_get_port_mirroring(
+	struct switch_enet_private *fep,
+	eswIoctlPortMirrorStatus *pPortMirrorStatus)
+{
+	volatile switch_t  *fecp;
+
+	fecp = fep->hwp;
+	pPortMirrorStatus->ESW_MCR    = fecp->ESW_MCR;
+	pPortMirrorStatus->ESW_EGMAP  = fecp->ESW_EGMAP;
+	pPortMirrorStatus->ESW_INGMAP = fecp->ESW_INGMAP;
+	pPortMirrorStatus->ESW_INGSAL = fecp->ESW_INGSAL;
+	pPortMirrorStatus->ESW_INGSAH = fecp->ESW_INGSAH;
+	pPortMirrorStatus->ESW_INGDAL = fecp->ESW_INGDAL;
+	pPortMirrorStatus->ESW_INGDAH = fecp->ESW_INGDAH;
+	pPortMirrorStatus->ESW_ENGSAL = fecp->ESW_ENGSAL;
+	pPortMirrorStatus->ESW_ENGSAH = fecp->ESW_ENGSAH;
+	pPortMirrorStatus->ESW_ENGDAL = fecp->ESW_ENGDAL;
+	pPortMirrorStatus->ESW_ENGDAH = fecp->ESW_ENGDAH;
+	pPortMirrorStatus->ESW_MCVAL  = fecp->ESW_MCVAL;
+#ifdef debug_port_mirror
+	printk(KERN_INFO "%s : ESW_MCR %x, ESW_EGMAP %x\n"
+		"ESW_INGMAP %x, ESW_INGSAL %x, "
+		"ESW_INGSAH %x ESW_INGDAL %x, ESW_INGDAH %x\n"
+		"ESW_ENGSAL %x, ESW_ENGSAH%x, ESW_ENGDAL %x,"
+		"ESW_ENGDAH %x, ESW_MCVAL %x\n",
+		__func__, fecp->ESW_MCR, fecp->ESW_EGMAP, fecp->ESW_INGMAP,
+		fecp->ESW_INGSAL, fecp->ESW_INGSAH, fecp->ESW_INGDAL,
+		fecp->ESW_INGDAH, fecp->ESW_ENGSAL, fecp->ESW_ENGSAH,
+		fecp->ESW_ENGDAL, fecp->ESW_ENGDAH, fecp->ESW_MCVAL);
+#endif
+}
+
 int esw_port_mirroring_config(struct switch_enet_private *fep,
-	int mirror_port, int port,
+	int mirror_port, int port, int mirror_enable,
 	unsigned char *src_mac, unsigned char *des_mac,
 	int egress_en, int ingress_en,
 	int egress_mac_src_en, int egress_mac_des_en,
@@ -1191,15 +1355,9 @@ int esw_port_mirroring_config(struct switch_enet_private *fep,
 	unsigned long tmp, protocol_type;
 
 	fecp = fep->hwp;
-	/*Enable transmit/receive on all ports*/
-	fecp->ESW_PER = 0x50003;
-	MCF_ESW_DBCR = 0;
-	fecp->ESW_P0FFEN = (MCF_ESW_P0FFEN_FD(1) | MCF_ESW_P0FFEN_FEN);
-
-	/* Enable TCP/UDP port Snooping */
 
 	/*mirroring config*/
-	tmp = MCF_ESW_MCR_MEN | MCF_ESW_MCR_PORT(mirror_port);
+	tmp = 0;
 	if (egress_en == 1) {
 		tmp |= MCF_ESW_MCR_EGMAP;
 		if (port == 0)
@@ -1213,7 +1371,9 @@ int esw_port_mirroring_config(struct switch_enet_private *fep,
 					__func__, port);
 			return -1;
 		}
-	} else if (egress_en != 0) {
+	} else if (egress_en == 0) {
+		tmp &= (~MCF_ESW_MCR_EGMAP);
+	} else {
 		printk(KERN_ERR "%s: egress_en %x we do not support\n",
 			__func__, egress_en);
 		return -1;
@@ -1232,7 +1392,9 @@ int esw_port_mirroring_config(struct switch_enet_private *fep,
 				__func__, port);
 			return -1;
 		}
-	} else if (ingress_en != 0) {
+	} else if (ingress_en == 0) {
+		tmp &= ~MCF_ESW_MCR_INGMAP;
+	} else{
 		printk(KERN_ERR "%s: ingress_en %x we do not support\n",
 				__func__, ingress_en);
 		return -1;
@@ -1245,7 +1407,9 @@ int esw_port_mirroring_config(struct switch_enet_private *fep,
 					(src_mac[2] << 16) |
 					(src_mac[1] << 8) |
 					src_mac[0]);
-	} else if (egress_mac_src_en != 0) {
+	} else if (egress_mac_src_en == 0) {
+		tmp &= ~MCF_ESW_MCR_EGSA;
+	} else {
 		printk(KERN_ERR "%s: egress_mac_src_en  %x we do not support\n",
 			__func__, egress_mac_src_en);
 		return -1;
@@ -1258,7 +1422,9 @@ int esw_port_mirroring_config(struct switch_enet_private *fep,
 					(des_mac[2] << 16) |
 					(des_mac[1] << 8) |
 					des_mac[0]);
-	} else if (egress_mac_des_en != 0) {
+	} else if (egress_mac_des_en == 0) {
+		tmp &= ~MCF_ESW_MCR_EGDA;
+	} else {
 		printk(KERN_ERR "%s: egress_mac_des_en  %x we do not support\n",
 			__func__, egress_mac_des_en);
 		return -1;
@@ -1271,7 +1437,9 @@ int esw_port_mirroring_config(struct switch_enet_private *fep,
 					(src_mac[2] << 16) |
 					(src_mac[1] << 8) |
 					src_mac[0]);
-	} else if (ingress_mac_src_en != 0) {
+	} else if (ingress_mac_src_en == 0) {
+		tmp &= ~MCF_ESW_MCR_INGSA;
+	} else {
 		printk(KERN_ERR "%s: ingress_mac_src_en  %x we do not support\n",
 			__func__, ingress_mac_src_en);
 		return -1;
@@ -1279,21 +1447,199 @@ int esw_port_mirroring_config(struct switch_enet_private *fep,
 
 	if (ingress_mac_des_en == 1) {
 		tmp |= MCF_ESW_MCR_INGDA;
-		fecp->ESW_INGSAH = (des_mac[5] << 8) | (des_mac[4]);
-		fecp->ESW_INGSAL = (unsigned long)((des_mac[3] << 24) |
+		fecp->ESW_INGDAH = (des_mac[5] << 8) | (des_mac[4]);
+		fecp->ESW_INGDAL = (unsigned long)((des_mac[3] << 24) |
 					(des_mac[2] << 16) |
 					(des_mac[1] << 8) |
 					des_mac[0]);
-	} else if (ingress_mac_des_en != 0) {
+	} else if (ingress_mac_des_en == 0) {
+		tmp &= ~MCF_ESW_MCR_INGDA;
+	} else {
 		printk(KERN_ERR "%s: ingress_mac_des_en  %x we do not support\n",
 			__func__, ingress_mac_des_en);
 		return -1;
 	}
 
+	/*------------------------------------------------------------------*/
+	if (mirror_enable == 1)
+		tmp |= MCF_ESW_MCR_MEN | MCF_ESW_MCR_PORT(mirror_port);
+	else if (mirror_enable == 0)
+		tmp &= ~MCF_ESW_MCR_MEN;
+	else
+		printk(KERN_ERR "%s: the mirror enable %x is error\n",
+			__func__, mirror_enable);
+
+
 	fecp->ESW_MCR = tmp;
-	fecp->ESW_MCVAL = MCF_ESW_MCVAL_COUNT(0);
+	printk(KERN_INFO "%s : MCR %x, EGMAP %x, INGMAP %x;\n"
+		"ENGSAH %x, ENGSAL %x ;ENGDAH %x, ENGDAL %x;\n"
+		"INGSAH %x, INGSAL %x\n;INGDAH %x, INGDAL %x;\n",
+		__func__, fecp->ESW_MCR, fecp->ESW_EGMAP, fecp->ESW_INGMAP,
+		fecp->ESW_ENGSAH, fecp->ESW_ENGSAL,
+		fecp->ESW_ENGDAH, fecp->ESW_ENGDAL,
+		fecp->ESW_INGSAH, fecp->ESW_INGSAL,
+		fecp->ESW_INGDAH, fecp->ESW_INGDAL);
+
+	return 0;
+}
+
+void esw_get_vlan_verification(
+	struct switch_enet_private *fep,
+	unsigned long *ulValue)
+{
+	volatile switch_t  *fecp;
+	fecp = fep->hwp;
+	*ulValue = fecp->ESW_VLANV;
+
+#ifdef debug_vlan_verification_config
+	printk(KERN_INFO "%s: ESW_VLANV %x\n",
+		__func__, fecp->ESW_VLANV);
+#endif
+}
+
+int esw_set_vlan_verification(
+	struct switch_enet_private *fep, int port,
+	int vlan_domain_verify_en,
+	int vlan_discard_unknown_en)
+{
+	volatile switch_t  *fecp;
+
+	fecp = fep->hwp;
+	if ((port < 0) || (port > 2)) {
+		printk(KERN_ERR "%s: do not support the port %d\n",
+			__func__, port);
+		return -1;
+	}
+
+	if (vlan_domain_verify_en == 1) {
+		if (port == 0)
+			fecp->ESW_VLANV |= MCF_ESW_VLANV_VV0;
+		else if (port == 1)
+			fecp->ESW_VLANV |= MCF_ESW_VLANV_VV1;
+		else if (port == 2)
+			fecp->ESW_VLANV |= MCF_ESW_VLANV_VV2;
+	} else if (vlan_domain_verify_en == 0) {
+		if (port == 0)
+			fecp->ESW_VLANV &= ~MCF_ESW_VLANV_VV0;
+		else if (port == 1)
+			fecp->ESW_VLANV &= ~MCF_ESW_VLANV_VV1;
+		else if (port == 2)
+			fecp->ESW_VLANV &= ~MCF_ESW_VLANV_VV2;
+	} else {
+		printk(KERN_INFO "%s: donot support "
+			"vlan_domain_verify %x\n",
+			__func__, vlan_domain_verify_en);
+		return -2;
+	}
+
+	if (vlan_discard_unknown_en == 1) {
+		if (port == 0)
+			fecp->ESW_VLANV |= MCF_ESW_VLANV_DU0;
+		else if (port == 1)
+			fecp->ESW_VLANV |= MCF_ESW_VLANV_DU1;
+		else if (port == 2)
+			fecp->ESW_VLANV |= MCF_ESW_VLANV_DU2;
+	} else if (vlan_discard_unknown_en == 0) {
+		if (port == 0)
+			fecp->ESW_VLANV &= ~MCF_ESW_VLANV_DU0;
+		else if (port == 1)
+			fecp->ESW_VLANV &= ~MCF_ESW_VLANV_DU1;
+		else if (port == 2)
+			fecp->ESW_VLANV &= ~MCF_ESW_VLANV_DU2;
+	} else {
+		printk(KERN_INFO "%s: donot support "
+			"vlan_discard_unknown %x\n",
+			__func__, vlan_discard_unknown_en);
+		return -3;
+	}
+
+#ifdef debug_vlan_verification_config
+	printk(KERN_INFO "%s: ESW_VLANV %x\n",
+		__func__, fecp->ESW_VLANV);
+#endif
+}
+
+void esw_get_vlan_resolution_table(
+	struct switch_enet_private *fep,
+	int vlan_domain_num,
+	unsigned long *ulValue)
+{
+	volatile switch_t  *fecp;
+	fecp = fep->hwp;
+
+	*ulValue = fecp->ESW_VRES[vlan_domain_num];
+
+#ifdef debug_vlan_domain_table
+	printk(KERN_INFO "%s: ESW_VRES[%d] = %x\n",
+		__func__, vlan_domain_num,
+		fecp->ESW_VRES[vlan_domain_num]);
+#endif
 }
 
+int esw_set_vlan_resolution_table(
+	struct switch_enet_private *fep,
+	unsigned short port_vlanid,
+	int vlan_domain_num,
+	int vlan_domain_port)
+{
+	volatile switch_t  *fecp;
+	int i;
+
+	fecp = fep->hwp;
+	if ((vlan_domain_num < 0)
+		|| (vlan_domain_num > 31)) {
+		printk(KERN_ERR "%s: do not support the "
+			"vlan_domain_num %d\n",
+		__func__, vlan_domain_num);
+		return -1;
+	}
+
+	if ((vlan_domain_port < 0)
+		|| (vlan_domain_port > 7)) {
+		printk(KERN_ERR "%s: do not support the "
+			"vlan_domain_port %d\n",
+			__func__, vlan_domain_port);
+		return -2;
+	}
+
+	fecp->ESW_VRES[vlan_domain_num] =
+		MCF_ESW_VRES_VLANID(port_vlanid)
+		| vlan_domain_port;
+
+#ifdef debug_vlan_domain_table
+	printk(KERN_INFO "%s: ESW_VRES[%d] = %x\n",
+		__func__, vlan_domain_num,
+		fecp->ESW_VRES[vlan_domain_num]);
+#endif
+}
+
+void esw_get_vlan_input_config(
+	struct switch_enet_private *fep,
+	eswIoctlVlanInputStatus *pVlanInputConfig)
+{
+	volatile switch_t  *fecp;
+	int i;
+
+	fecp = fep->hwp;
+	for (i = 0; i < 3; i++)
+		pVlanInputConfig->ESW_PID[i] = fecp->ESW_PID[i];
+
+	pVlanInputConfig->ESW_VLANV  = fecp->ESW_VLANV;
+	pVlanInputConfig->ESW_VIMSEL = fecp->ESW_VIMSEL;
+	pVlanInputConfig->ESW_VIMEN  = fecp->ESW_VIMEN;
+
+	for (i = 0; i < 32; i++)
+		pVlanInputConfig->ESW_VRES[i] = fecp->ESW_VRES[i];
+#ifdef debug_vlan_intput_config
+	printk(KERN_INFO "%s: ESW_VLANV %x, ESW_VIMSEL %x, "
+		"ESW_VIMEN %x, ESW_PID[0], ESW_PID[1] %x, "
+		"ESW_PID[2] %x", __func__,
+		fecp->ESW_VLANV, fecp->ESW_VIMSEL, fecp->ESW_VIMEN,
+		fecp->ESW_PID[0], fecp->ESW_PID[1], fecp->ESW_PID[2]);
+#endif
+}
+
+
 int esw_vlan_input_process(struct switch_enet_private *fep,
 	int port, int mode, unsigned short port_vlanid,
 	int vlan_verify_en, int vlan_domain_num,
@@ -1304,14 +1650,9 @@ int esw_vlan_input_process(struct switch_enet_private *fep,
 	unsigned long tmp, protocol_type;
 
 	fecp = fep->hwp;
-	/*Enable transmit/receive on all ports*/
-	fecp->ESW_PER = 0x70007;
-	fecp->ESW_DBCR = 0;
-	/*transmit packet*/
-	/*fecp->ESW_P0FFEN = (MCF_ESW_P0FFEN_FD(1) | MCF_ESW_P0FFEN_FEN);*/
 
 	/*we only support mode1 mode2 mode3 mode4*/
-	if ((mode < 1) || (mode > 4)) {
+	if ((mode < 0) || (mode > 3)) {
 		printk(KERN_ERR "%s: do not support the"
 			" VLAN input processing mode %d\n",
 			__func__, mode);
@@ -1339,7 +1680,7 @@ int esw_vlan_input_process(struct switch_enet_private *fep,
 				| MCF_ESW_VRES_P0;
 
 		fecp->ESW_VIMEN |= MCF_ESW_VIMEN_EN0;
-		fecp->ESW_VIMSEL |= MCF_ESW_VIMSEL_IM0(mode - 1);
+		fecp->ESW_VIMSEL |= MCF_ESW_VIMSEL_IM0(mode);
 	} else if (port == 1) {
 		if (vlan_verify_en == 1)
 			fecp->ESW_VRES[vlan_domain_num] =
@@ -1347,7 +1688,7 @@ int esw_vlan_input_process(struct switch_enet_private *fep,
 				| MCF_ESW_VRES_P1;
 
 		fecp->ESW_VIMEN |= MCF_ESW_VIMEN_EN1;
-		fecp->ESW_VIMSEL |= MCF_ESW_VIMSEL_IM1(mode - 1);
+		fecp->ESW_VIMSEL |= MCF_ESW_VIMSEL_IM1(mode);
 	} else if (port == 2) {
 		if (vlan_verify_en == 1)
 			fecp->ESW_VRES[vlan_domain_num] =
@@ -1355,7 +1696,7 @@ int esw_vlan_input_process(struct switch_enet_private *fep,
 				| MCF_ESW_VRES_P2;
 
 		fecp->ESW_VIMEN |= MCF_ESW_VIMEN_EN2;
-		fecp->ESW_VIMSEL |= MCF_ESW_VIMSEL_IM2(mode - 1);
+		fecp->ESW_VIMSEL |= MCF_ESW_VIMSEL_IM2(mode);
 	} else {
 		printk(KERN_ERR "%s: do not support the port %d\n",
 			__func__, port);
@@ -1365,6 +1706,20 @@ int esw_vlan_input_process(struct switch_enet_private *fep,
 
 }
 
+void esw_get_vlan_output_config(struct switch_enet_private *fep,
+	unsigned long *ulVlanOutputConfig)
+{
+	volatile switch_t  *fecp;
+
+	fecp = fep->hwp;
+
+	*ulVlanOutputConfig = fecp->ESW_VOMSEL;
+#ifdef debug_vlan_output_config
+	printk(KERN_INFO "%s: ESW_VOMSEL %x", __func__,
+			fecp->ESW_VOMSEL);
+#endif
+}
+
 int esw_vlan_output_process(struct switch_enet_private *fep,
 	int port, int mode)
 {
@@ -1373,22 +1728,19 @@ int esw_vlan_output_process(struct switch_enet_private *fep,
 	unsigned long tmp, protocol_type;
 
 	fecp = fep->hwp;
-	/*Enable transmit/receive on all ports*/
-	fecp->ESW_PER = 0x70007;
-	fecp->ESW_DBCR = 0;
 
-	if ((port < 0) || (port > 3)) {
+	if ((port < 0) || (port > 2)) {
 		printk(KERN_ERR "%s: do not support the port %d\n",
 			__func__, mode);
 		return -1;
 	}
 
 	if (port == 0) {
-		fecp->ESW_VOMSEL |= MCF_ESW_VOMSEL_OM0(mode - 1);
+		fecp->ESW_VOMSEL |= MCF_ESW_VOMSEL_OM0(mode);
 	} else if (port == 1) {
-		fecp->ESW_VOMSEL |= MCF_ESW_VOMSEL_OM1(mode - 1);
+		fecp->ESW_VOMSEL |= MCF_ESW_VOMSEL_OM1(mode);
 	} else if (port == 2) {
-		fecp->ESW_VOMSEL |= MCF_ESW_VOMSEL_OM2(mode - 1);
+		fecp->ESW_VOMSEL |= MCF_ESW_VOMSEL_OM2(mode);
 	} else {
 		printk(KERN_ERR "%s: do not support the port %d\n",
 			__func__, port);
@@ -1410,11 +1762,6 @@ int esw_framecalssify_vlan_priority_lookup(
 	unsigned long tmp, protocol_type;
 
 	fecp = fep->hwp;
-	/* Enable transmit/receive on all ports */
-	fecp->ESW_PER = 0x70007;
-	/* Broadcast configure*/
-	fecp->ESW_DBCR = 0;
-
 
 	if ((port < 0) || (port > 3)) {
 		printk(KERN_ERR "%s: do not support the port %d\n",
@@ -1453,10 +1800,6 @@ int esw_framecalssify_ip_priority_lookup(
 	unsigned long tmp = 0, tmp_prio = 0;
 
 	fecp = fep->hwp;
-	/* Enable transmit/receive on all ports */
-	fecp->ESW_PER = 0x70007;
-	/* Broadcast configure*/
-	fecp->ESW_DBCR = 0;
 
 	if ((port < 0) || (port > 3)) {
 		printk(KERN_ERR "%s: do not support the port %d\n",
@@ -1530,7 +1873,7 @@ int esw_framecalssify_mac_priority_lookup(
 	}
 
 	fecp = fep->hwp;
-	fecp->ESW_PRES[port] |= MCF_ESW_PRES_IP;
+	fecp->ESW_PRES[port] |= MCF_ESW_PRES_MAC;
 
 	return 0;
 }
@@ -1555,6 +1898,7 @@ int esw_frame_calssify_priority_init(
 	fecp->ESW_PRES[port] = MCF_ESW_PRES_DFLT_PRI(priority_value & 0x7);
 }
 
+/*---------------------------------------------------------------------------*/
 int esw_get_statistics_status(
 	struct switch_enet_private *fep,
 	esw_statistics_status *pStatistics)
@@ -1609,7 +1953,7 @@ int esw_get_port_statistics_status(
 #endif
 	return 0;
 }
-
+/*----------------------------------------------------------------------*/
 int esw_get_output_queue_status(
 	struct switch_enet_private *fep,
 	esw_output_queue_status *pOutputQueue)
@@ -1634,6 +1978,193 @@ int esw_get_output_queue_status(
 #endif
 	return 0;
 }
+
+/* set output queue memory status and configure*/
+int esw_set_output_queue_memory(
+	struct switch_enet_private *fep,
+	int fun_num,
+	esw_output_queue_status *pOutputQueue)
+{
+	volatile switch_t  *fecp;
+
+	fecp = fep->hwp;
+
+	if (fun_num == 1) {
+		/* memory manager status*/
+		fecp->ESW_MMSR = pOutputQueue->ESW_MMSR;
+	} else if (fun_num == 2) {
+		/*low memory threshold*/
+		fecp->ESW_LMT = pOutputQueue->ESW_LMT;
+	} else if (fun_num == 3) {
+		/*lowest number of free cells*/
+		fecp->ESW_LFC = pOutputQueue->ESW_LFC;
+	} else if (fun_num == 4) {
+		/*queue weights*/
+		fecp->ESW_QWT = pOutputQueue->ESW_QWT;
+	} else if (fun_num == 5) {
+		/*port 0 backpressure congenstion thresled*/
+		fecp->ESW_P0BCT = pOutputQueue->ESW_P0BCT;
+	} else {
+		printk(KERN_ERR "%s: do not support the cmd %x\n",
+			__func__, fun_num);
+		return -1;
+	}
+#ifdef debug_output_queue
+	printk(KERN_ERR "%s:ESW_MMSR %x, ESW_LMT %x, ESW_LFC %x, "
+		"ESW_IOSR %x, ESW_PCSR %x, ESW_QWT %x, ESW_P0BCT %x\n",
+		__func__, fecp->ESW_MMSR,
+		fecp->ESW_LMT, fecp->ESW_LFC,
+		fecp->ESW_IOSR,  fecp->ESW_PCSR,
+		fecp->ESW_QWT, fecp->ESW_P0BCT);
+#endif
+	return 0;
+}
+/*--------------------------------------------------------------------*/
+int esw_get_irq_status(
+	struct switch_enet_private *fep,
+	eswIoctlIrqStatus *pIrqStatus)
+{
+	volatile switch_t  *fecp;
+
+	fecp = fep->hwp;
+	pIrqStatus->isr             = fecp->switch_ievent;
+	pIrqStatus->imr             = fecp->switch_imask;
+	pIrqStatus->rx_buf_pointer  = fecp->fec_r_des_start;
+	pIrqStatus->tx_buf_pointer  = fecp->fec_x_des_start;
+	pIrqStatus->rx_max_size     = fecp->fec_r_buff_size;
+	pIrqStatus->rx_buf_active   = fecp->fec_r_des_active;
+	pIrqStatus->tx_buf_active   = fecp->fec_x_des_active;
+#ifdef debug_irq
+	printk(KERN_ERR "%s: irq event %x, irq mask %x, "
+		"rx_des_start %x, tx_des_start %x, "
+		"rx_buff_size %x, rx_des_active %x, "
+		"tx_des_active %x\n",
+		__func__, fecp->switch_ievent, fecp->switch_imask,
+		fecp->fec_r_des_start, fecp->fec_x_des_start,
+		fecp->fec_r_buff_size, fecp->fec_r_des_active,
+		fecp->fec_x_des_active);
+#endif
+	return 0;
+}
+
+int esw_set_irq_mask(
+	struct switch_enet_private *fep,
+	unsigned long mask, int enable)
+{
+	volatile switch_t  *fecp;
+
+	fecp = fep->hwp;
+#ifdef debug_irq
+	printk(KERN_INFO "%s: irq event %x, irq mask %x "
+		" mask %x, enable %x\n",
+		__func__, fecp->switch_ievent,
+		fecp->switch_imask, mask, enable);
+#endif
+	if (enable == 1)
+		fecp->switch_imask |= mask;
+	else if (enable == 1)
+		fecp->switch_imask &= (~mask);
+	else {
+		printk(KERN_INFO "%s: enable %x is error value\n",
+			__func__, enable, mask);
+		return -1;
+	}
+#ifdef debug_irq
+	printk(KERN_INFO "%s: irq event %x, irq mask %x, "
+		"rx_des_start %x, tx_des_start %x, "
+		"rx_buff_size %x, rx_des_active %x, "
+		"tx_des_active %x\n",
+		__func__, fecp->switch_ievent, fecp->switch_imask,
+		fecp->fec_r_des_start, fecp->fec_x_des_start,
+		fecp->fec_r_buff_size, fecp->fec_r_des_active,
+		fecp->fec_x_des_active);
+#endif
+	return 0;
+}
+
+int esw_clear_irq_event(
+	struct switch_enet_private *fep,
+	unsigned long mask)
+{
+	volatile switch_t  *fecp;
+
+	fecp = fep->hwp;
+#ifdef debug_irq
+	printk(KERN_INFO "%s: irq event %x, irq mask %x"
+		" clear %x\n",
+		__func__, fecp->switch_ievent,
+		fecp->switch_imask, mask);
+#endif
+	fecp->switch_ievent |= mask;
+#ifdef debug_irq
+	printk(KERN_INFO "%s: irq event %x, irq mask %x, "
+		"rx_des_start %x, tx_des_start %x, "
+		"rx_buff_size %x, rx_des_active %x, "
+		"tx_des_active %x\n",
+		__func__, fecp->switch_ievent, fecp->switch_imask,
+		fecp->fec_r_des_start, fecp->fec_x_des_start,
+		fecp->fec_r_buff_size, fecp->fec_r_des_active,
+		fecp->fec_x_des_active);
+#endif
+}
+
+void esw_get_switch_mode(
+	struct switch_enet_private *fep,
+	unsigned long *ulModeConfig)
+{
+	volatile switch_t  *fecp;
+
+	fecp = fep->hwp;
+	*ulModeConfig = fecp->ESW_MODE;
+#ifdef debug_switch_mode
+	printk(KERN_INFO "%s: mode %x \n"
+		__func__, fecp->ESW_MODE);
+#endif
+}
+
+void esw_switch_mode_configure(
+	struct switch_enet_private *fep,
+	unsigned long configure)
+{
+	volatile switch_t  *fecp;
+
+	fecp = fep->hwp;
+	fecp->ESW_MODE |= configure;
+#ifdef debug_switch_mode
+	printk(KERN_INFO "%s: mode %x \n"
+		__func__, fecp->ESW_MODE);
+#endif
+}
+
+
+void esw_get_bridge_port(
+	struct switch_enet_private *fep,
+	unsigned long *ulBMPConfig)
+{
+	volatile switch_t  *fecp;
+
+	fecp = fep->hwp;
+	*ulBMPConfig = fecp->ESW_BMPC;
+#ifdef debug_bridge_port
+	printk(KERN_INFO "%s: bridge management port %x \n"
+		__func__, fecp->ESW_BMPC);
+#endif
+}
+
+void  esw_bridge_port_configure(
+	struct switch_enet_private *fep,
+	unsigned long configure)
+{
+	volatile switch_t  *fecp;
+
+	fecp = fep->hwp;
+	fecp->ESW_BMPC |= configure;
+#ifdef debug_bridge_port
+	printk(KERN_INFO "%s: bridge management port %x \n"
+		__func__, fecp->ESW_BMPC);
+#endif
+}
+
 /*----------------------------------------------------------------------------*/
 /* The timer should create an interrupt every 4 seconds*/
 static void l2switch_aging_timer(unsigned long data)
@@ -1686,22 +2217,23 @@ void esw_basic_switching_test(struct switch_enet_private *fep)
 
 	fecp->ESW_DBCR = MCF_ESW_DBCR_P1;
 
-	esw_update_atable_static(mac_addr, 7, 7, fep);
+	/*esw_update_atable_static(mac_addr, 7, 7, fep);*/
 	/*port0 MAC is forwared to port1 and port2*/
 	esw_update_atable_static(mac_addr0, 7, 7, fep);
-	esw_update_atable_static(mac_addr1, 7, 7, fep);
+	/*esw_update_atable_static(mac_addr1, 7, 7, fep);*/
 	/*port2 MAC is forwared to port0 and port1*/
-	esw_update_atable_static(mac_addr2, 7, 7, fep);
-
+	/*esw_update_atable_static(mac_addr2, 7, 7, fep);*/
+#ifdef switch_debug
 	printk(KERN_ERR "%s: MCF_ESW_ISR %x, MCF_ESW_IMR %x\n",
 		__func__, MCF_ESW_ISR, MCF_ESW_IMR);
+#endif
 }
 
 void esw_test_main(struct switch_enet_private *fep)
 {
 	volatile switch_t  *fecp;
 	fecp = fep->hwp;
-	printk(KERN_ERR "%s: start\n", __func__);
+
 	esw_basic_switching_test(fep);
 	/*test case 1*/
 	/*fecp->ESW_IPSNP[0] = (MCF_ESW_IPSNP_PROTOCOL(0x01) |
@@ -1737,8 +2269,7 @@ void esw_test_main(struct switch_enet_private *fep)
 	fecp->ESW_MCVAL = MCF_ESW_MCVAL_COUNT(0);
 	*/
 	/*test case 5*/
-	fecp->ESW_DBCR = MCF_ESW_DBCR_P1;/*0 P0 P2*/
-	printk(KERN_ERR "%s: over\n", __func__);
+	fecp->ESW_DBCR = MCF_ESW_DBCR_P1 | MCF_ESW_DBCR_P2;/*0 P0 P2*/
 }
 /*----------------------------------------------------------------*/
 static void switch_enet_dump(struct switch_enet_private *fep)
@@ -1807,11 +2338,12 @@ static int switch_enet_ioctl(
 	unsigned long flags;
 	int ret = 0;
 
-	printk(KERN_ERR "%s\n", __func__);
+	printk(KERN_INFO "%s cmd %x\n", __func__, cmd);
 	fep = netdev_priv(dev);
 	fecp = (volatile switch_t *)dev->base_addr;
 
 	switch (cmd) {
+	/*------------------------------------------------------------*/
 	case ESW_SET_PORTENABLE_CONF:
 	{
 		eswIoctlPortEnableConfig configData;
@@ -1870,12 +2402,13 @@ static int switch_enet_ioctl(
 	case ESW_SET_LEARNING_CONF:
 	{
 		eswIoctlPortConfig configData;
-
+		printk(KERN_INFO "ESW_SET_LEARNING_CONF\n");
 		ret = copy_from_user(&configData,
 			ifr->ifr_data, sizeof(eswIoctlPortConfig));
 		if (ret)
 			return -EFAULT;
-
+		printk(KERN_INFO "ESW_SET_LEARNING_CONF: %x %x\n",
+				configData.port, configData.enable);
 		ret = esw_port_learning_config(fep,
 			configData.port, configData.enable);
 	}
@@ -1889,7 +2422,9 @@ static int switch_enet_ioctl(
 			ifr->ifr_data, sizeof(eswIoctlIpsnoopConfig));
 		if (ret)
 			return -EFAULT;
-
+		printk(KERN_INFO "ESW_SET_IP_SNOOP_CONF:: %x %x %x\n",
+				configData.num, configData.mode,
+				configData.ip_header_protocol);
 		ret = esw_ip_snoop_config(fep,
 			configData.num, configData.mode,
 			configData.ip_header_protocol);
@@ -1904,7 +2439,9 @@ static int switch_enet_ioctl(
 			ifr->ifr_data, sizeof(eswIoctlPortsnoopConfig));
 		if (ret)
 			return -EFAULT;
-
+		printk(KERN_INFO "ESW_SET_PORT_SNOOP_CONF:: %x %x %x %x\n",
+			configData.num, configData.mode,
+			configData.compare_port, configData.compare_num);
 		ret = esw_tcpudp_port_snoop_config(fep,
 			configData.num, configData.mode,
 			configData.compare_port,
@@ -1920,9 +2457,19 @@ static int switch_enet_ioctl(
 			ifr->ifr_data, sizeof(eswIoctlPortMirrorConfig));
 		if (ret)
 			return -EFAULT;
-
+		printk(KERN_INFO "ESW_SET_PORT_MIRROR_CONF:: %x %x %x "
+			"%s %s\n %x %x %x %x %x %x\n",
+			configData.mirror_port, configData.port,
+			configData.mirror_enable,
+			configData.src_mac, configData.des_mac,
+			configData.egress_en, configData.ingress_en,
+			configData.egress_mac_src_en,
+			configData.egress_mac_des_en,
+			configData.ingress_mac_src_en,
+			configData.ingress_mac_des_en);
 		ret = esw_port_mirroring_config(fep,
 			configData.mirror_port, configData.port,
+			configData.mirror_enable,
 			configData.src_mac, configData.des_mac,
 			configData.egress_en, configData.ingress_en,
 			configData.egress_mac_src_en,
@@ -1991,6 +2538,186 @@ static int switch_enet_ioctl(
 			configData.port, configData.priority_value);
 	}
 		break;
+
+	case ESW_SET_P0_FORCED_FORWARD:
+	{
+		eswIoctlP0ForcedForwardConfig configData;
+
+		ret = copy_from_user(&configData,
+			ifr->ifr_data, sizeof(eswIoctlP0ForcedForwardConfig));
+		if (ret)
+			return -EFAULT;
+
+		ret = esw_forced_forward(fep, configData.port1,
+			configData.port2, configData.enable);
+	}
+		break;
+
+	case ESW_SET_BRIDGE_CONFIG:
+	{
+		unsigned long configData;
+
+		ret = copy_from_user(&configData,
+			ifr->ifr_data, sizeof(unsigned long));
+		if (ret)
+			return -EFAULT;
+
+		esw_bridge_port_configure(fep, configData);
+	}
+		break;
+
+	case ESW_SET_SWITCH_MODE:
+	{
+		unsigned long configData;
+
+		ret = copy_from_user(&configData,
+			ifr->ifr_data, sizeof(unsigned long));
+		if (ret)
+			return -EFAULT;
+
+		esw_switch_mode_configure(fep, configData);
+	}
+		break;
+
+	case ESW_SET_OUTPUT_QUEUE_MEMORY:
+	{
+		eswIoctlOutputQueue configData;
+
+		ret = copy_from_user(&configData,
+			ifr->ifr_data, sizeof(eswIoctlOutputQueue));
+		if (ret)
+			return -EFAULT;
+
+		printk(KERN_INFO "ESW_SET_OUTPUT_QUEUE_MEMORY:: %x \n"
+			"%x %x %x %x\n"
+			"%x %x %x\n",
+			configData.fun_num,
+			configData.sOutputQueue.ESW_MMSR,
+			configData.sOutputQueue.ESW_LMT,
+			configData.sOutputQueue.ESW_LFC,
+			configData.sOutputQueue.ESW_PCSR,
+			configData.sOutputQueue.ESW_IOSR,
+			configData.sOutputQueue.ESW_QWT,
+			configData.sOutputQueue.ESW_P0BCT);
+		ret = esw_set_output_queue_memory(fep,
+			configData.fun_num, &configData.sOutputQueue);
+	}
+		break;
+
+	case ESW_SET_VLAN_OUTPUT_PROCESS:
+	{
+		eswIoctlVlanOutputConfig configData;
+
+		ret = copy_from_user(&configData,
+			ifr->ifr_data, sizeof(eswIoctlVlanOutputConfig));
+		if (ret)
+			return -EFAULT;
+
+		printk(KERN_INFO "ESW_SET_VLAN_OUTPUT_PROCESS: %x %x\n",
+			configData.port, configData.mode);
+		ret = esw_vlan_output_process(fep,
+			configData.port, configData.mode);
+	}
+		break;
+
+	case ESW_SET_VLAN_INPUT_PROCESS:
+	{
+		eswIoctlVlanInputConfig configData;
+
+		ret = copy_from_user(&configData,
+			ifr->ifr_data,
+			sizeof(eswIoctlVlanInputConfig));
+		if (ret)
+			return -EFAULT;
+
+		printk(KERN_INFO "ESW_SET_VLAN_INPUT_PROCESS: %x %x"
+				"%x %x %x %x\n",
+			configData.port, configData.mode,
+			configData.port_vlanid,
+			configData.vlan_verify_en,
+			configData.vlan_domain_num,
+			configData.vlan_domain_port);
+		ret = esw_vlan_input_process(fep, configData.port,
+				configData.mode, configData.port_vlanid,
+				configData.vlan_verify_en,
+				configData.vlan_domain_num,
+				configData.vlan_domain_port);
+	}
+		break;
+
+	case ESW_SET_VLAN_DOMAIN_VERIFICATION:
+	{
+		eswIoctlVlanVerificationConfig configData;
+
+		ret = copy_from_user(&configData,
+			ifr->ifr_data,
+			sizeof(eswIoctlVlanVerificationConfig));
+		if (ret)
+			return -EFAULT;
+
+		printk(KERN_INFO "ESW_SET_VLAN_DOMAIN_VERIFICATION: "
+			"%x %x %x\n",
+			configData.port,
+			configData.vlan_domain_verify_en,
+			configData.vlan_discard_unknown_en);
+		ret = esw_set_vlan_verification(
+			fep, configData.port,
+			configData.vlan_domain_verify_en,
+			configData.vlan_discard_unknown_en);
+	}
+		break;
+
+	case ESW_SET_VLAN_RESOLUTION_TABLE:
+	{
+		eswIoctlVlanResoultionTable configData;
+
+		ret = copy_from_user(&configData,
+			ifr->ifr_data,
+			sizeof(eswIoctlVlanResoultionTable));
+		if (ret)
+			return -EFAULT;
+
+		printk(KERN_INFO "ESW_SET_VLAN_RESOLUTION_TABLE: "
+			"%x %x %x\n",
+			configData.port_vlanid,
+			configData.vlan_domain_num,
+			configData.vlan_domain_port);
+
+		ret = esw_set_vlan_resolution_table(
+			fep, configData.port_vlanid,
+			configData.vlan_domain_num,
+			configData.vlan_domain_port);
+
+	}
+		break;
+	/*--------------------------------------------------------------------*/
+	case ESW_UPDATE_STATIC_MACTABLE:
+	{
+		eswIoctlUpdateStaticMACtable configData;
+
+		ret = copy_from_user(&configData,
+			ifr->ifr_data, sizeof(eswIoctlUpdateStaticMACtable));
+		if (ret)
+			return -EFAULT;
+
+		printk(KERN_INFO "%s: ESW_UPDATE_STATIC_MACTABLE: mac %s, "
+			"port %x, priority %x\n", __func__,
+			configData.mac_addr,
+			configData.port,
+			configData.priority);
+		ret = esw_update_atable_static(configData.mac_addr,
+				configData.port, configData.priority, fep);
+	}
+		break;
+
+	case ESW_CLEAR_ALL_MACTABLE:
+	{
+		eswIoctlUpdateStaticMACtable configData;
+
+		esw_clear_atable(fep);
+	}
+		break;
+
 	/*-------------------get----------------------------------------------*/
 	case ESW_GET_STATISTICS_STATUS:
 	{
@@ -2066,9 +2793,213 @@ static int switch_enet_ioctl(
 	}
 		break;
 
+	case ESW_GET_LEARNING_CONF:
+	{
+		unsigned long PortLearning;
+
+		esw_get_port_learning(fep, &PortLearning);
+		ret = copy_to_user(ifr->ifr_data, &PortLearning,
+			sizeof(unsigned long));
+		if (ret)
+			return -EFAULT;
+	}
+		break;
+
+	case ESW_GET_BLOCKING_CONF:
+	{
+		unsigned long PortBlocking;
+
+		esw_get_port_blocking(fep, &PortBlocking);
+		ret = copy_to_user(ifr->ifr_data, &PortBlocking,
+			sizeof(unsigned long));
+		if (ret)
+			return -EFAULT;
+	}
+		break;
+
+	case ESW_GET_MULTICAST_CONF:
+	{
+		unsigned long PortMulticast;
+
+		esw_get_port_multicast(fep, &PortMulticast);
+		ret = copy_to_user(ifr->ifr_data, &PortMulticast,
+			sizeof(unsigned long));
+		if (ret)
+			return -EFAULT;
+	}
+		break;
+
+	case ESW_GET_BROADCAST_CONF:
+	{
+		unsigned long PortBroadcast;
+
+		esw_get_port_broadcast(fep, &PortBroadcast);
+		ret = copy_to_user(ifr->ifr_data, &PortBroadcast,
+		sizeof(unsigned long));
+		if (ret)
+			return -EFAULT;
+	}
+		break;
+
+	case ESW_GET_PORTENABLE_CONF:
+	{
+		unsigned long PortEnable;
+
+		esw_get_port_enable(fep, &PortEnable);
+		ret = copy_to_user(ifr->ifr_data, &PortEnable,
+			sizeof(unsigned long));
+		if (ret)
+			return -EFAULT;
+	}
+		break;
+
+	case ESW_GET_IP_SNOOP_CONF:
+	{
+		unsigned long ESW_IPSNP[8];
+
+		esw_get_ip_snoop_config(fep, (unsigned long *)ESW_IPSNP);
+		ret = copy_to_user(ifr->ifr_data, ESW_IPSNP,
+			(8 * sizeof(unsigned long)));
+		if (ret)
+			return -EFAULT;
+	}
+		break;
+
+	case ESW_GET_PORT_SNOOP_CONF:
+	{
+		unsigned long ESW_PSNP[8];
+
+		esw_get_tcpudp_port_snoop_config(fep,
+				(unsigned long *)ESW_PSNP);
+		ret = copy_to_user(ifr->ifr_data, ESW_PSNP,
+			(8 * sizeof(unsigned long)));
+		if (ret)
+			return -EFAULT;
+	}
+		break;
+
+	case ESW_GET_PORT_MIRROR_CONF:
+	{
+		eswIoctlPortMirrorStatus PortMirrorStatus;
+
+		esw_get_port_mirroring(fep, &PortMirrorStatus);
+		ret = copy_to_user(ifr->ifr_data, &PortMirrorStatus,
+			sizeof(eswIoctlPortMirrorStatus));
+		if (ret)
+			return -EFAULT;
+	}
+		break;
+
+	case ESW_GET_P0_FORCED_FORWARD:
+	{
+		unsigned long ForceForward;
+
+		esw_get_forced_forward(fep, &ForceForward);
+		ret = copy_to_user(ifr->ifr_data, &ForceForward,
+			sizeof(unsigned long));
+		if (ret)
+			return -EFAULT;
+	}
+		break;
+
+	case ESW_GET_SWITCH_MODE:
+	{
+		unsigned long Config;
+
+		esw_get_switch_mode(fep, &Config);
+		ret = copy_to_user(ifr->ifr_data, &Config,
+			sizeof(unsigned long));
+		if (ret)
+			return -EFAULT;
+	}
+		break;
+
+	case ESW_GET_BRIDGE_CONFIG:
+	{
+		unsigned long Config;
+
+		esw_get_bridge_port(fep, &Config);
+		ret = copy_to_user(ifr->ifr_data, &Config,
+			sizeof(unsigned long));
+		if (ret)
+			return -EFAULT;
+	}
+		break;
+	case ESW_GET_OUTPUT_QUEUE_STATUS:
+	{
+		esw_output_queue_status Config;
+		esw_get_output_queue_status(fep,
+			&Config);
+		ret = copy_to_user(ifr->ifr_data, &Config,
+			sizeof(esw_output_queue_status));
+		if (ret)
+			return -EFAULT;
+	}
+		break;
+
+	case ESW_GET_VLAN_OUTPUT_PROCESS:
+	{
+		unsigned long Config;
+
+		esw_get_vlan_output_config(fep, &Config);
+		ret = copy_to_user(ifr->ifr_data, &Config,
+			sizeof(unsigned long));
+		if (ret)
+			return -EFAULT;
+	}
+		break;
+
+	case ESW_GET_VLAN_INPUT_PROCESS:
+	{
+		eswIoctlVlanInputStatus Config;
+
+		esw_get_vlan_input_config(fep, &Config);
+		ret = copy_to_user(ifr->ifr_data, &Config,
+			sizeof(eswIoctlVlanInputStatus));
+		if (ret)
+			return -EFAULT;
+	}
+		break;
+
+	case ESW_GET_VLAN_RESOLUTION_TABLE:
+	{
+		unsigned long Config;
+		unsigned char ConfigData;
+		ret = copy_from_user(&ConfigData,
+			ifr->ifr_data,
+			sizeof(unsigned char));
+		if (ret)
+			return -EFAULT;
+
+		printk(KERN_INFO "ESW_GET_VLAN_RESOLUTION_TABLE: %x \n",
+			ConfigData);
+
+		esw_get_vlan_resolution_table(fep, ConfigData, &Config);
+
+		ret = copy_to_user(ifr->ifr_data, &Config,
+			sizeof(unsigned long));
+		if (ret)
+			return -EFAULT;
+	}
+		break;
+
+	case ESW_GET_VLAN_DOMAIN_VERIFICATION:
+	{
+		unsigned long Config;
+
+		esw_get_vlan_verification(fep, &Config);
+		ret = copy_to_user(ifr->ifr_data, &Config,
+			sizeof(unsigned long));
+		if (ret)
+			return -EFAULT;
+	}
+		break;
+	/*------------------------------------------------------------------*/
 	default:
 		return -EOPNOTSUPP;
 	}
+
+
 	return ret;
 }
 
@@ -2108,16 +3039,17 @@ switch_enet_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	*/
 	bdp->cbd_bufaddr = __pa(skb->data);
 	bdp->cbd_datlen = skb->len;
+#ifdef enet_start_xmit_debug
 	printk(KERN_ERR "%s: skb->len %x, dev->stats.tx_bytes %x,"
 		" bdp->cbd_bufaddr %x skb->data %x\n",
 		__func__, skb->len, dev->stats.tx_bytes,
 		bdp->cbd_bufaddr, skb->data);
-#if 1
+
 	{
 	int index;
 	for (index = 0; index < bdp->cbd_datlen; index++)
-		printk("%x ", *(skb->data+index));
-	printk("  \n");
+		printk(KERN_INFO "%x ", *(skb->data+index));
+	printk(KERN_INFO "  \n");
 	}
 #endif
 	/*
@@ -2128,8 +3060,10 @@ switch_enet_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	if (bdp->cbd_bufaddr & 0x3) {
 		unsigned int index1;
 		index1 = bdp - fep->tx_bd_base;
+#ifdef enet_start_xmit_debug
 		printk(KERN_ERR "%s: bdp->cbd_bufaddr %x\n",
 			__func__, bdp->cbd_bufaddr);
+#endif
 		memcpy(fep->tx_bounce[index1],
 		       (void *)skb->data, bdp->cbd_datlen);
 		bdp->cbd_bufaddr = __pa(fep->tx_bounce[index1]);
@@ -2252,12 +3186,14 @@ switch_enet_interrupt(int irq, void *dev_id)
 		/* Handle receive event in its own function. */
 
 		/* Transmit OK, or non-fatal error. Update the buffer
-		   descriptors. FEC handles all errors, we just discover
+		   descriptors. Switch handles all errors, we just discover
 		   them as part of the transmit process.
 		*/
 		if (int_events & MCF_ESW_ISR_LRN) {
+			if (fep->learning_irqhandle_enable)
+				esw_atable_dynamicms_learn_migration(
+					fep, fep->currTime);
 			ret = IRQ_HANDLED;
-			printk(KERN_INFO "\n");
 		}
 
 		if (int_events & MCF_ESW_ISR_OD0)
@@ -2299,7 +3235,6 @@ switch_enet_tx(struct net_device *dev)
 	unsigned short status;
 	struct	sk_buff	*skb;
 
-	printk(KERN_ERR "%s\n", __func__);
 	fep = netdev_priv(dev);
 	spin_lock_irq(&fep->hw_lock);
 	bdp = fep->dirty_tx;
@@ -2502,7 +3437,7 @@ rx_processing_done:
 	 * incoming frames.  On a heavily loaded network, we should be
 	 * able to keep up at the expense of system resources.
 	 */
-	/*fecp->fec_r_des_active = MCF_ESW_RDAR_R_DES_ACTIVE;*/
+	fecp->fec_r_des_active = MCF_ESW_RDAR_R_DES_ACTIVE;
 #endif
    } /* while (!((status = bdp->cbd_sc) & BD_ENET_RX_EMPTY)) */
 	fep->cur_rx = (cbd_t *)bdp;
@@ -2702,7 +3637,10 @@ static int
 switch_enet_open(struct net_device *dev)
 {
 	struct switch_enet_private *fep = netdev_priv(dev);
-	printk(KERN_ERR "%s\n", __func__);
+	volatile switch_t *fecp;
+
+	fecp = (volatile switch_t *)fep->hwp;
+	printk(KERN_INFO "%s\n", __func__);
 	/* I should reset the ring buffers here, but I don't yet know
 	 * a simple way to do that.
 	 */
@@ -2736,6 +3674,7 @@ switch_enet_open(struct net_device *dev)
 
 	/*-----------------------------------*/
 	fep->currTime = 0;
+	fep->learning_irqhandle_enable = 0;
 	/* enable timer for Learning Aging Function*/
 	/*add_timer(&fep->timer_aging);*/
 
@@ -2744,7 +3683,7 @@ switch_enet_open(struct net_device *dev)
 
 	netif_start_queue(dev);
 	fep->opened = 1;
-
+#ifdef switch_debug
 	printk(KERN_ERR "%s:MCF_GPIO_PAR_FEC %x \n"
 		"MCF_FEC_RCR0 %x MCF_FEC_RCR1 %x \n"
 		"MCF_FEC_TCR0 %x MCF_FEC_TCR1 %x \n"
@@ -2756,6 +3695,7 @@ switch_enet_open(struct net_device *dev)
 		MCF_FEC_RCR0, MCF_FEC_RCR1, MCF_FEC_TCR0, MCF_FEC_TCR1,
 		MCF_FEC_ECR0, MCF_FEC_ECR1, MCF_FEC_EIMR0, MCF_FEC_EIMR1,
 		MCF_FEC_EIR0, MCF_FEC_EIR1, MCF_PPMHR0);
+#endif
 	return 0;		/* Success */
 }
 
@@ -2764,7 +3704,7 @@ switch_enet_close(struct net_device *dev)
 {
 	struct switch_enet_private *fep = netdev_priv(dev);
 
-	printk(KERN_ERR "%s\n", __func__);
+	printk(KERN_INFO "%s\n", __func__);
 	/* Don't know what to do yet.*/
 	fep->opened = 0;
 	netif_stop_queue(dev);
@@ -2855,11 +3795,12 @@ switch_set_mac_address(struct net_device *dev)
 	volatile switch_t *fecp;
 
 	fecp = ((struct switch_enet_private *)netdev_priv(dev))->hwp;
+#ifdef switch_debug
 	printk(KERN_ERR "%s dev max %x:%x\n", __func__,
 		dev->dev_addr[3] | (dev->dev_addr[2] << 8) |
 		(dev->dev_addr[1] << 16) | (dev->dev_addr[0] << 24),
 		(dev->dev_addr[5] << 16) | (dev->dev_addr[4] << 24));
-
+#endif
 }
 
 static void
@@ -2963,27 +3904,16 @@ int __init switch_enet_init(struct net_device *dev,
 	fecp->ESW_MODE = MCF_ESW_MODE_STATRST;
 	fecp->ESW_MODE = MCF_ESW_MODE_SW_EN;
 
-	printk(KERN_ERR "%s: MCF_ESW_MODE %x %x %x\n",
-		__func__, MCF_ESW_MODE, fecp->ESW_MODE, &fecp->ESW_MODE);
 	/* Enable transmit/receive on all ports */
 	fecp->ESW_PER = 0xffffffff;
-	printk(KERN_ERR "%s: MCF_ESW_PER %x\n",
-		__func__, MCF_ESW_PER);
+
 	/* Management port configuration,
 	 * make port 0 as management port */
 	fecp->ESW_BMPC = 0;
-	printk(KERN_ERR "%s: MCF_ESW_BMPC %x\n",
-		__func__, MCF_ESW_BMPC);
 
 	/* clear all switch irq*/
 	fecp->switch_ievent = 0xffffffff;
 	fecp->switch_imask  = 0;
-	printk(KERN_ERR "%s: mode %x per %x bmpc %x isr %x mask %x"
-		"LMT %x MMSR %x IOSR %x P0BCT %x PCSR %x\n",
-		__func__, fecp->ESW_MODE, fecp->ESW_PER,
-		fecp->ESW_BMPC, fecp->switch_ievent, fecp->switch_imask,
-		fecp->ESW_LMT, fecp->ESW_MMSR, fecp->ESW_IOSR,
-		fecp->ESW_P0BCT, fecp->ESW_PCSR);
 
 	udelay(10);
 
@@ -3013,9 +3943,7 @@ int __init switch_enet_init(struct net_device *dev,
 
 	/* Initialize the receive buffer descriptors. */
 	bdp = fep->rx_bd_base;
-	printk(KERN_ERR "%s: bdp %x, %x %x\n",
-		__func__, bdp, SWITCH_ENET_RX_PAGES,
-		SWITCH_ENET_RX_FRPPG);
+
 	for (i = 0; i < SWITCH_ENET_RX_PAGES; i++) {
 
 		/* Allocate a page.
@@ -3030,8 +3958,6 @@ int __init switch_enet_init(struct net_device *dev,
 		for (j = 0; j < SWITCH_ENET_RX_FRPPG; j++) {
 			bdp->cbd_sc = BD_ENET_RX_EMPTY;
 			bdp->cbd_bufaddr = __pa(mem_addr);
-			printk(KERN_ERR "%s: %x %x\n",
-				__func__, mem_addr, bdp->cbd_bufaddr);
 #ifdef MODELO_BUFFER
 			bdp->bdu = 0x00000000;
 			bdp->ebd_status = RX_BD_INT;
@@ -3148,7 +4074,6 @@ switch_restart(struct net_device *dev, int duplex)
 	int i;
 	struct coldfire_switch_platform_data *plat;
 
-	printk(KERN_ERR "%s\n", __func__);
 	fep = netdev_priv(dev);
 	fecp = fep->hwp;
 	plat = fep->pdev->dev.platform_data;
@@ -3160,21 +4085,13 @@ switch_restart(struct net_device *dev, int duplex)
 	fecp->ESW_MODE = MCF_ESW_MODE_STATRST;
 	fecp->ESW_MODE = MCF_ESW_MODE_SW_EN;
 
-	printk(KERN_ERR "%s: MCF_ESW_MODE %x %x %x\n",
-		__func__, MCF_ESW_MODE, fecp->ESW_MODE, &fecp->ESW_MODE);
 	/* Enable transmit/receive on all ports */
 	fecp->ESW_PER = 0xffffffff;
-	printk(KERN_ERR "%s: MCF_ESW_PER %x\n", __func__, MCF_ESW_PER);
+
 	/* Management port configuration,
 	 * make port 0 as management port */
 	fecp->ESW_BMPC = 0;
 
-	printk(KERN_ERR "%s: MCF_ESW_BMPC %x LMT %x MMSR %x "
-		"IOSR %x p0BCT %x PCSR %x\n",
-		__func__, MCF_ESW_BMPC, fecp->ESW_LMT,
-		fecp->ESW_MMSR, fecp->ESW_IOSR,
-		fecp->ESW_P0BCT, fecp->ESW_PCSR);
-
 	/* Clear any outstanding interrupt.
 	*/
 	fecp->switch_ievent = 0xffffffff;
diff --git a/drivers/net/modelo_switch.h b/drivers/net/modelo_switch.h
index e2c90ce..d9b1ea7 100644
--- a/drivers/net/modelo_switch.h
+++ b/drivers/net/modelo_switch.h
@@ -303,12 +303,30 @@ typedef struct l2switchaddrtable {
 #define ESW_GET_PIRORITY_MAC                0x920B
 #define ESW_SET_PIRORITY_DEFAULT            0x910C
 #define ESW_GET_PIRORITY_DEFAULT            0x920C
+#define ESW_SET_P0_FORCED_FORWARD           0x910D
+#define ESW_GET_P0_FORCED_FORWARD           0x920D
+#define ESW_SET_SWITCH_MODE                 0x910E
+#define ESW_GET_SWITCH_MODE                 0x920E
+#define ESW_SET_BRIDGE_CONFIG               0x910F
+#define ESW_GET_BRIDGE_CONFIG               0x920F
+#define ESW_SET_VLAN_OUTPUT_PROCESS         0x9110
+#define ESW_GET_VLAN_OUTPUT_PROCESS         0x9210
+#define ESW_SET_VLAN_INPUT_PROCESS          0x9111
+#define ESW_GET_VLAN_INPUT_PROCESS          0x9211
+#define ESW_SET_VLAN_DOMAIN_VERIFICATION    0x9112
+#define ESW_GET_VLAN_DOMAIN_VERIFICATION    0x9212
+#define ESW_SET_VLAN_RESOLUTION_TABLE       0x9113
+#define ESW_GET_VLAN_RESOLUTION_TABLE       0x9213
+
 
 #define ESW_GET_STATISTICS_STATUS           0x9221
 #define ESW_GET_PORT0_STATISTICS_STATUS     0x9222
 #define ESW_GET_PORT1_STATISTICS_STATUS     0x9223
 #define ESW_GET_PORT2_STATISTICS_STATUS     0x9224
+#define ESW_SET_OUTPUT_QUEUE_MEMORY         0x9125
 #define ESW_GET_OUTPUT_QUEUE_STATUS         0x9225
+#define ESW_UPDATE_STATIC_MACTABLE          0x9226
+#define ESW_CLEAR_ALL_MACTABLE              0x9227
 
 typedef struct _eswIOCTL_PORT_CONF {
 	int port;
@@ -324,27 +342,34 @@ typedef struct _eswIOCTL_PORT_EN_CONF {
 typedef struct _eswIOCTL_IP_SNOOP_CONF {
 	int num;
 	int mode;
-	unsigned long ip_header_protocol;
+	unsigned char ip_header_protocol;
 } eswIoctlIpsnoopConfig;
 
+typedef struct _eswIOCTL_P0_FORCED_FORWARD_CONF {
+	int port1;
+	int port2;
+	int enable;
+} eswIoctlP0ForcedForwardConfig;
+
 typedef struct _eswIOCTL_PORT_SNOOP_CONF {
      int num;
      int mode;
-     int compare_port;
+     unsigned short compare_port;
      int compare_num;
 } eswIoctlPortsnoopConfig;
 
 typedef struct _eswIOCTL_PORT_Mirror_CONF {
 	int mirror_port;
 	int port;
-	unsigned char *src_mac;
-	unsigned char *des_mac;
 	int egress_en;
 	int ingress_en;
 	int egress_mac_src_en;
 	int egress_mac_des_en;
 	int ingress_mac_src_en;
 	int ingress_mac_des_en;
+	unsigned char *src_mac;
+	unsigned char *des_mac;
+	int mirror_enable;
 } eswIoctlPortMirrorConfig;
 
 typedef struct _eswIOCTL_PRIORITY_VLAN_CONF {
@@ -371,6 +396,77 @@ typedef struct _eswIOCTL_PRIORITY_DEFAULT_CONF {
 	unsigned char priority_value;
 } eswIoctlPriorityDefaultConfig;
 
+typedef struct _eswIOCTL_IRQ_STATUS {
+	unsigned long isr;
+	unsigned long imr;
+	unsigned long rx_buf_pointer;
+	unsigned long tx_buf_pointer;
+	unsigned long rx_max_size;
+	unsigned long rx_buf_active;
+	unsigned long tx_buf_active;
+} eswIoctlIrqStatus;
+
+typedef struct _eswIOCTL_PORT_Mirror_STATUS {
+	unsigned long ESW_MCR;
+	unsigned long ESW_EGMAP;
+	unsigned long ESW_INGMAP;
+	unsigned long ESW_INGSAL;
+	unsigned long ESW_INGSAH;
+	unsigned long ESW_INGDAL;
+	unsigned long ESW_INGDAH;
+	unsigned long ESW_ENGSAL;
+	unsigned long ESW_ENGSAH;
+	unsigned long ESW_ENGDAL;
+	unsigned long ESW_ENGDAH;
+	unsigned long ESW_MCVAL;
+} eswIoctlPortMirrorStatus;
+
+typedef struct _eswIOCTL_VLAN_OUTPUT_CONF {
+	int port;
+	int mode;
+} eswIoctlVlanOutputConfig;
+
+typedef struct _eswIOCTL_VLAN_INPUT_CONF {
+	int port;
+	int mode;
+	unsigned short port_vlanid;
+	int vlan_verify_en;
+	int vlan_domain_num;
+	int vlan_domain_port;
+} eswIoctlVlanInputConfig;
+
+typedef struct _eswIOCTL_VLAN_DOMAIN_VERIFY_CONF {
+	int port;
+	int vlan_domain_verify_en;
+	int vlan_discard_unknown_en;
+} eswIoctlVlanVerificationConfig;
+
+typedef struct _eswIOCTL_VLAN_RESOULATION_TABLE {
+	unsigned short port_vlanid;
+	int vlan_domain_num;
+	int vlan_domain_port;
+} eswIoctlVlanResoultionTable;
+
+
+typedef struct _eswIOCTL_VLAN_INPUT_STATUS {
+	unsigned long ESW_VLANV;
+	unsigned long ESW_PID[3];
+	unsigned long ESW_VIMSEL;
+	unsigned long ESW_VIMEN;
+	unsigned long ESW_VRES[32];
+} eswIoctlVlanInputStatus;
+
+typedef struct _eswIOCTL_Static_MACTable {
+	unsigned char *mac_addr;
+	int port;
+	int priority;
+} eswIoctlUpdateStaticMACtable;
+
+typedef struct _eswIOCTL_OUTPUT_QUEUE{
+	int fun_num;
+	esw_output_queue_status  sOutputQueue;
+} eswIoctlOutputQueue;
+
 /*=============================================================*/
 #define LEARNING_AGING_TIMER (10 * HZ)
 /*
@@ -552,6 +648,7 @@ struct switch_enet_private {
 	/**/
 	/* Timer for Aging */
 	struct timer_list       timer_aging;
+	int learning_irqhandle_enable;
 };
 
 struct switch_platform_private {
diff --git a/net/core/dev.c b/net/core/dev.c
index d30c0a2..9e773f3 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -3938,6 +3938,10 @@ static int dev_ifsioc(struct net *net, struct ifreq *ifr, unsigned int cmd)
 		default:
 			if ((cmd >= SIOCDEVPRIVATE &&
 			    cmd <= SIOCDEVPRIVATE + 15) ||
+#if defined(CONFIG_MODELO_SWITCH)
+			    (cmd >= 0x9101 &&
+			     cmd <= 0x92ff) ||
+#endif
 			    cmd == SIOCBONDENSLAVE ||
 			    cmd == SIOCBONDRELEASE ||
 			    cmd == SIOCBONDSETHWADDR ||
@@ -3991,7 +3995,6 @@ int dev_ioctl(struct net *net, unsigned int cmd, void __user *arg)
 	   and requires shared lock, because it sleeps writing
 	   to user space.
 	 */
-
 	if (cmd == SIOCGIFCONF) {
 		rtnl_lock();
 		ret = dev_ifconf(net, (char __user *) arg);
@@ -4128,6 +4131,10 @@ int dev_ioctl(struct net *net, unsigned int cmd, void __user *arg)
 		 */
 		default:
 			if (cmd == SIOCWANDEV ||
+#if defined(CONFIG_MODELO_SWITCH)
+				(cmd >= 0x9101 &&
+				cmd <= 0x92ff) ||
+#endif
 			    (cmd >= SIOCDEVPRIVATE &&
 			     cmd <= SIOCDEVPRIVATE + 15)) {
 				dev_load(net, ifr.ifr_name);
-- 
1.6.4

