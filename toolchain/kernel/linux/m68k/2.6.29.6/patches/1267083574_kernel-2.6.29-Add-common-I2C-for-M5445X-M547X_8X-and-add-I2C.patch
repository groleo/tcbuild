From ef84c037cd501405cc2683e70d9bc910597bfbfb Mon Sep 17 00:00:00 2001
From: Wang Huan <wanghuan@zch06.freescale.net>
Date: Thu, 25 Feb 2010 15:39:34 +0800
Subject: [PATCH 11/23] Add common I2C driver for M5445X/M547X_8X and add I2C slave mode support for M5445X

Abandon old i2c core interface (i2c_attach_client),update i2c core stack based on latest linux kernel version.
Rewrite i2c bus driver for mcfv4/mcfv4e platform: use linux driver model.

Configure I2C  adaptor as slave mode and Support I2C adaptor as a "eeprom-like" slave device.
Refer to drivers/i2c/busses/i2c-mcf-slave.c file.To test this driver, please follow RELEASE driver manual.

Signed-off-by: Lanttor Guo <lanttor.guo@freescale.com>
---
 arch/m68k/include/asm/mcfi2c.h     |   56 +++
 drivers/i2c/busses/Kconfig         |   24 ++
 drivers/i2c/busses/Makefile        |    2 +
 drivers/i2c/busses/i2c-algo-mcf.h  |   23 +
 drivers/i2c/busses/i2c-mcf-slave.c |  336 ++++++++++++++++
 drivers/i2c/busses/i2c-mcf.c       |  695 ++++++++++++++++++++++++++++++++
 drivers/i2c/i2c-boardinfo.c        |    7 +-
 drivers/i2c/i2c-core.c             |  775 ++++++++++++++++--------------------
 drivers/i2c/i2c-core.h             |    4 +-
 9 files changed, 1491 insertions(+), 431 deletions(-)
 create mode 100644 arch/m68k/include/asm/mcfi2c.h
 create mode 100644 drivers/i2c/busses/i2c-algo-mcf.h
 create mode 100644 drivers/i2c/busses/i2c-mcf-slave.c
 create mode 100644 drivers/i2c/busses/i2c-mcf.c

diff --git a/arch/m68k/include/asm/mcfi2c.h b/arch/m68k/include/asm/mcfi2c.h
new file mode 100644
index 0000000..d033e28
--- /dev/null
+++ b/arch/m68k/include/asm/mcfi2c.h
@@ -0,0 +1,56 @@
+/*
+ *	mcfi2c.h -- ColdFire mcfv4/mcfv4e i2c controller support.
+ *	Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#ifndef MCF_I2C_H
+#define MCF_I2C_H
+
+/* Register read/write macros */
+#if defined(CONFIG_M547X_8X)
+#define MCF_I2AR     MCF_REG08(0x008F00)	/* I2C Address 		 */
+#define MCF_I2FDR    MCF_REG08(0x008F04)	/* I2C Frequency Divider */
+#define MCF_I2CR     MCF_REG08(0x008F08)	/* I2C Control		 */
+#define MCF_I2SR     MCF_REG08(0x008F0C)	/* I2C Status		 */
+#define MCF_I2DR     MCF_REG08(0x008F10)	/* I2C Data I/O		 */
+#define MCF_I2ICR    MCF_REG08(0x008F20)	/* I2C Interrupt Control */
+#elif defined(CONFIG_M5445X)
+#define MCF_I2AR     *(volatile u8 *)(0xFC058000)	/* I2C Address 		 */
+#define MCF_I2FDR    *(volatile u8 *)(0xFC058004)	/* I2C Frequency Divider */
+#define MCF_I2CR     *(volatile u8 *)(0xFC058008)	/* I2C Control		 */
+#define MCF_I2SR     *(volatile u8 *)(0xFC05800C)	/* I2C Status		 */
+#define MCF_I2DR     *(volatile u8 *)(0xFC058010)	/* I2C Data I/O		 */
+#endif
+
+/* Bit definitions and macros for MCF_I2C_I2AR */
+#define MCF_I2AR_ADR(x)    (((x)&0x7F)<<1)
+
+/* Bit definitions and macros for MCF_I2C_I2FDR */
+#define MCF_I2FDR_IC(x)    (((x)&0x3F)<<0)
+
+/* Bit definitions and macros for MCF_I2C_I2CR */
+#define MCF_I2CR_RSTA      (0x04)
+#define MCF_I2CR_TXAK      (0x08)
+#define MCF_I2CR_MTX       (0x10)
+#define MCF_I2CR_MSTA      (0x20)
+#define MCF_I2CR_IIEN      (0x40)
+#define MCF_I2CR_IEN       (0x80)
+
+/* Bit definitions and macros for MCF_I2C_I2SR */
+#define MCF_I2SR_RXAK      (0x01)
+#define MCF_I2SR_IIF       (0x02)
+#define MCF_I2SR_SRW       (0x04)
+#define MCF_I2SR_IAL       (0x10)
+#define MCF_I2SR_IBB       (0x20)
+#define MCF_I2SR_IAAS      (0x40)
+#define MCF_I2SR_ICF       (0x80)
+
+/* Bit definitions and macros for MCF_I2C_I2ICR */
+#if defined(CONFIG_M547X_8X)
+#define MCF_I2ICR_IE       (0x01)
+#define MCF_I2ICR_RE       (0x02)
+#define MCF_I2ICR_TE       (0x04)
+#define MCF_I2ICR_BNBE     (0x08)
+#endif
+
+/********************************************************************/
+#endif
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 7f95905..c2102e6 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -379,6 +379,30 @@ config I2C_IXP2000
 	  This driver is deprecated and will be dropped soon. Use i2c-gpio
 	  instead.
 
+config I2C_MCF
+	tristate "MCF ColdFire I2C Interface"
+	depends on I2C && COLDFIRE
+	help
+	  If you say yes to this option, support will be included for the
+	  I2C on most ColdFire CPUs
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called i2c-mcf.
+
+config I2C_MCF_SLAVE
+	tristate "MCF ColdFire I2C Slave Interface"
+	depends on !(I2C_MCF)
+	default n
+	help
+	  mcf i2c adapter slave mode, only supported on mcf5445x platform.
+
+config I2C_SLAVE_TEST
+	bool "I2C Slave Mode Test Configuration"
+	depends on I2C_MCF_SLAVE
+	default y
+	help
+	   This configuration help to test I2C slave mode
+
 config I2C_MPC
 	tristate "MPC107/824x/85xx/52xx/86xx"
 	depends on PPC32
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 0c2c4b2..18b6914 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -67,6 +67,8 @@ obj-$(CONFIG_I2C_SIBYTE)	+= i2c-sibyte.o
 obj-$(CONFIG_I2C_STUB)		+= i2c-stub.o
 obj-$(CONFIG_SCx200_ACB)	+= scx200_acb.o
 obj-$(CONFIG_SCx200_I2C)	+= scx200_i2c.o
+obj-$(CONFIG_I2C_MCF)           += i2c-mcf.o
+obj-$(CONFIG_I2C_MCF_SLAVE)	+= i2c-mcf-slave.o
 
 ifeq ($(CONFIG_I2C_DEBUG_BUS),y)
 EXTRA_CFLAGS += -DDEBUG
diff --git a/drivers/i2c/busses/i2c-algo-mcf.h b/drivers/i2c/busses/i2c-algo-mcf.h
new file mode 100644
index 0000000..d7be080
--- /dev/null
+++ b/drivers/i2c/busses/i2c-algo-mcf.h
@@ -0,0 +1,23 @@
+#ifndef I2C_ALGO_MCF_H
+#define I2C_ALGO_MCF_H 1
+
+/* --- Defines for pcf-adapters ---------------------------------------	*/
+#include <linux/i2c.h>
+
+struct i2c_algo_mcf_data {
+	void *data;		/* private data for lolevel routines	*/
+	void (*setmcf) (void *data, int ctl, int val);
+	int (*getmcf) (void *data, int ctl);
+	int (*getown) (void *data);
+	int (*getclock) (void *data);
+	void (*waitforpin) (void);
+	/* local settings */
+	int udelay;
+	int mdelay;
+	int timeout;
+};
+
+int i2c_mcf_add_bus(struct i2c_adapter *);
+int i2c_mcf_del_bus(struct i2c_adapter *);
+
+#endif /* I2C_ALGO_MCF_H */
diff --git a/drivers/i2c/busses/i2c-mcf-slave.c b/drivers/i2c/busses/i2c-mcf-slave.c
new file mode 100644
index 0000000..26db8da
--- /dev/null
+++ b/drivers/i2c/busses/i2c-mcf-slave.c
@@ -0,0 +1,336 @@
+/*
+ * i2c-mcf-slave.c - support adpater slave mode, now only support mcf5445x platform
+ *
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Lanttor Guo <lanttor.guo@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+*/
+
+#ifdef CONFIG_I2C_SLAVE_TEST
+#define DEBUG
+#endif
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/types.h>
+#include <asm/coldfire.h>
+#include <asm/mcfsim.h>
+#include <asm/irq.h>
+#include <asm/mcfi2c.h>
+#if defined(CONFIG_M5445X)
+#include <asm/mcf5445x_intc.h>
+#endif
+
+#define IRQ (64+30)
+#define SLAVE_HANDLER_NAME "mcf-i2c slave handler"
+#define	I2C_BUFFER_SIZE	50
+
+/* Structure for storing I2C transfer data */
+struct i2c_buffer {
+    int tx_index;			/* TX index */
+    int rx_index;			/* RX index */
+    u16 length;			/* Length of the buffer in bytes */
+    u8 buf[I2C_BUFFER_SIZE];		/* Data buffer */
+};
+
+struct i2c_buffer i2c_tx_buffer;
+struct i2c_buffer i2c_rx_buffer;
+
+u8 *tx_string = "abcdefghijklmnopqrstuvwxyz0123456789)!@#$%^&*([].";
+
+/*
+ * I2C slave mode interrupt handler
+ *
+ */
+static irqreturn_t i2c_slave_handler(int this_irq, void *dev_id)
+{
+	u8 dummy_read;
+
+#ifdef DEBUG
+	printk("i2c adapter slave mode irq handler.\n");
+#endif
+
+	/* Clear I2C interupt flag */
+	MCF_I2SR = ~MCF_I2SR_IIF;
+
+	/* Check if this device is in Master or Slave Mode. */
+	if (MCF_I2CR & MCF_I2CR_MSTA) {
+		/* Master mode, do nothing here */
+		printk(KERN_INFO "i2c master mode at %s(), do nothing!\n", __func__);
+		return IRQ_NONE;
+	} else {
+		/* Slave Mode - Check if Arbitration Lost. */
+		if (MCF_I2SR & MCF_I2SR_IAL) {
+
+		#ifdef DEBUG
+			printk("Arbitration Lost.\n");
+		#endif
+
+			/* Clear IAL bit */
+			MCF_I2SR &= ~MCF_I2SR_IAL;
+
+			/* Arbitration Lost -
+			 * Check if this device is being addressed as slave.
+			 *(If not, nothing more needs to be done.)
+			 */
+			if (MCF_I2SR & MCF_I2SR_IAAS) {
+				/* Addressed as slave -
+				 * Check if master was reading from slave or
+				 * writing to slave.
+				 */
+				if (MCF_I2SR & MCF_I2SR_SRW) {
+					/* Set tx_index to 0 */
+					if (i2c_tx_buffer.length == 0) {
+						i2c_tx_buffer.length = I2C_BUFFER_SIZE;
+						i2c_tx_buffer.tx_index = 0;
+					}
+
+					/* Master was reading from slave -
+					 * Set Transmit Mode.
+					 */
+					MCF_I2CR |= MCF_I2CR_MTX;
+
+					/* Write data to MBDR. */
+					MCF_I2DR =
+					i2c_tx_buffer.buf[i2c_tx_buffer.tx_index++];
+					i2c_tx_buffer.length--;
+
+				#ifdef DEBUG
+					printk("Arbitration Lost: Addressed as slave - TX mode.\n");
+				#endif
+				} else {
+					/* Set rx_index to 0 */
+					i2c_rx_buffer.rx_index = 0;
+
+					/* Master was writing to slave - Set Receive Mode. */
+					MCF_I2CR &= ~MCF_I2CR_MTX;
+
+					/* Dummy read from MBDR, to clear the ICF bit. */
+					dummy_read = MCF_I2DR;
+
+				#ifdef DEBUG
+					printk("Arbitration Lost: Addressed as slave - RX mode.\n");
+				#endif
+				}
+			}
+
+		} else {
+			/* Arbitration Not Lost - Check if data byte is this devices's
+			 * Slave Address byte. */
+			if (MCF_I2SR & MCF_I2SR_IAAS) {
+				/* Data byte is Slave Address byte - Check Slave Read/Write bit. */
+				if (MCF_I2SR & MCF_I2SR_SRW) {
+					/* Set tx_index to 0 */
+					if (i2c_tx_buffer.length == 0) {
+						i2c_tx_buffer.length = I2C_BUFFER_SIZE;
+						i2c_tx_buffer.tx_index = 0;
+					}
+
+					/* Master was reading from slave - Set Transmit Mode. */
+					MCF_I2CR |= MCF_I2CR_MTX;
+
+					/* Write data to MBDR. */
+					MCF_I2DR =
+					i2c_tx_buffer.buf[i2c_tx_buffer.tx_index++];
+					i2c_tx_buffer.length--;
+
+				#ifdef DEBUG
+					printk("Slave TX: First byte - 0x%02X\n",
+						i2c_tx_buffer.buf[i2c_tx_buffer.tx_index-1]);
+				#endif
+				} else {
+					/* Master has specified Slave Receive Mode.
+					   Set Receive Mode.  (Writing to MBCR clears IAAS.) */
+
+					/* Set rx_index to 0 */
+					i2c_rx_buffer.rx_index = 0;
+
+					MCF_I2CR &= ~MCF_I2CR_MTX;
+
+					/* Dummy read from MBDR, to clear the ICF bit. */
+					dummy_read = MCF_I2DR;
+
+				#ifdef DEBUG
+					printk("Slave RX: Receive address.\n");
+				#endif
+				}
+			} else {
+				/* Data byte received is not Slave Address byte -
+				   Check if this device is in Transmit or Receive Mode. */
+				if (MCF_I2CR & MCF_I2CR_MTX) {
+					/* Last byte received? */
+					if (MCF_I2SR & MCF_I2SR_RXAK) {
+						MCF_I2CR &= ~MCF_I2CR_MTX;
+						dummy_read = MCF_I2DR;
+
+					#ifdef DEBUG
+						printk("Slave TX: Last byte has been sent.\n");
+					#endif
+					} else {
+						/* Write data to MBDR. */
+						MCF_I2DR =
+						i2c_tx_buffer.buf[i2c_tx_buffer.tx_index++];
+						i2c_tx_buffer.length--;
+
+					#ifdef DEBUG
+						printk("Slave TX: Send byte - 0x%02X\n",
+							i2c_tx_buffer.buf[i2c_tx_buffer.tx_index-1]);
+					#endif
+						if (i2c_tx_buffer.length == 0) {
+							i2c_tx_buffer.length = I2C_BUFFER_SIZE;
+							i2c_tx_buffer.tx_index = 0;
+						}
+
+					}
+				} else {
+					/* Receive Mode - Read data from MBDR and store it. */
+					i2c_rx_buffer.buf[i2c_rx_buffer.rx_index++] = MCF_I2DR;
+					i2c_rx_buffer.length++;
+
+				#ifdef DEBUG
+					printk("Slave RX: Receive byte - 0x%02X\n",
+						i2c_rx_buffer.buf[i2c_rx_buffer.rx_index-1]);
+				#endif
+				}
+			}
+		}
+		return IRQ_HANDLED;
+	}
+}
+
+#ifdef CONFIG_PROC_FS
+
+/*
+ *	Info exported via "/proc/driver/i2c".
+ */
+
+static int gen_i2c_proc_output(char *buf)
+{
+	char *p;
+
+	p = buf;
+	p += sprintf(p,
+		     "I2CR: 0x%x\n"
+		     "I2SR: 0x%x\n"
+		     "I2DR: 0x%x\n",
+		     MCF_I2CR, MCF_I2SR, MCF_I2DR);
+
+	return p - buf;
+}
+
+static int gen_i2c_read_proc(char *page, char **start, off_t off,
+			     int count, int *eof, void *data)
+{
+	int len = gen_i2c_proc_output (page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len > count) len = count;
+	if (len < 0) len = 0;
+	return len;
+}
+
+static int __init gen_i2c_proc_init(void)
+{
+	struct proc_dir_entry *r;
+
+	r = create_proc_read_entry("driver/i2c-adaptor-register", 0, NULL, gen_i2c_read_proc, NULL);
+	if (!r)
+		return -ENOMEM;
+	return 0;
+}
+#else
+static inline int gen_i2c_proc_init(void) { return 0; }
+#endif /* CONFIG_PROC_FS */
+
+/*
+ *  Initalize I2C module
+ */
+static int __init i2c_coldfire_init(void)
+{
+	int retval;
+	u8  dummy_read;
+
+#ifdef DEBUG
+	printk(KERN_INFO "init i2c adaptor slave mode!\n");
+#endif
+
+	/* Initialize the tx buffer */
+	strcpy((char *)&i2c_tx_buffer.buf, (const char *)tx_string);
+	i2c_tx_buffer.length = I2C_BUFFER_SIZE;
+
+#if defined(CONFIG_M5445X)
+	/*
+	 * Initialize the GPIOs for I2C
+	 */
+	MCF_GPIO_PAR_FECI2C |= (0
+			| MCF_GPIO_PAR_FECI2C_PAR_SDA(3)
+			| MCF_GPIO_PAR_FECI2C_PAR_SCL(3));
+#endif
+
+	/* Set transmission frequency 0x19 = ~100kHz */
+	MCF_I2FDR = 0x19;
+
+	/* set the I2C slave address */
+	MCF_I2AR = 0x6A;
+
+	/* Enable I2C module and if IBB is set, do the special initialzation */
+	/* procedures as are documented */
+
+	if ((MCF_I2SR & MCF_I2SR_IBB) == 1) {
+		printk(KERN_INFO "%s - do special I2C init procedures \n",
+			__func__);
+		MCF_I2CR = 0x00;
+		MCF_I2CR = 0xA0;
+		dummy_read = MCF_I2DR;
+		MCF_I2SR = 0x00;
+		MCF_I2CR = 0x00;
+	}
+
+	MCF_I2CR |= (MCF_I2CR_IEN  | MCF_I2CR_IIEN);
+
+	/* default I2C mode is - slave and receive */
+	MCF_I2CR &= ~(MCF_I2CR_MSTA | MCF_I2CR_MTX);
+
+	retval = request_irq(IRQ, i2c_slave_handler, IRQF_DISABLED,
+			     SLAVE_HANDLER_NAME, NULL);
+	if (retval < 0)
+		printk(KERN_INFO "request_irq for i2c slave mode failed!\n");
+
+	retval = gen_i2c_proc_init();
+
+	if (retval < 0)
+		printk(KERN_INFO "gen /proc/i2c-adaptor-register for i2c slave mode failed!\n");
+
+	return retval;
+};
+
+/*
+ *  I2C module exit function
+ */
+
+static void __exit i2c_coldfire_exit(void)
+{
+	/* disable I2C and Interrupt */
+	MCF_I2CR &= ~(MCF_I2CR_IEN | MCF_I2CR_IIEN);
+	free_irq(IRQ, NULL);
+
+};
+
+MODULE_DESCRIPTION("MCF5445x I2C adaptor slave mode support");
+MODULE_LICENSE("GPL");
+
+module_init(i2c_coldfire_init);
+module_exit(i2c_coldfire_exit);
diff --git a/drivers/i2c/busses/i2c-mcf.c b/drivers/i2c/busses/i2c-mcf.c
new file mode 100644
index 0000000..3ca1cd4
--- /dev/null
+++ b/drivers/i2c/busses/i2c-mcf.c
@@ -0,0 +1,695 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Lanttor.Guo@freescale.com
+ *
+ * I2C bus driver on mcfv4/mcfv4e platform
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#include <linux/i2c.h>
+#include "i2c-algo-mcf.h"
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/proc_fs.h>
+
+#include <asm/coldfire.h>
+#include <asm/mcfi2c.h>
+
+#if defined(CONFIG_M547X_8X)
+#include <asm/m5485sim.h>
+#elif defined(CONFIG_M5445X)
+#include <asm/mcfsim.h>
+#endif
+
+#define get_clock(adap) (clock)
+#define get_own(adap) 	(own)
+
+#if defined(CONFIG_M547X_8X)
+static int clock = 0x3b;
+#elif defined(CONFIG_M5445X)
+static int clock = 0x19;
+#endif
+module_param(clock, int, 0);
+MODULE_PARM_DESC(clock,
+	"Set I2C clock in kHz: 400=fast mode (default == 100khz)");
+
+static int own = 0x78;
+module_param(own, int, 0);
+MODULE_PARM_DESC(clock, "Set I2C Master controller address");
+
+static struct i2c_algo_mcf_data i2c_mcf_board_data = {
+	.timeout =	10000,
+};
+
+static struct i2c_adapter i2c_mcf_board_adapter = {
+	.owner = THIS_MODULE,
+	.name = "mcf i2c adapter",
+	.algo_data = &i2c_mcf_board_data,
+	.class = I2C_CLASS_HWMON,
+	.timeout = 100,
+	.retries = 2
+};
+/*
+ *  static void i2c_start()
+ *
+ *  Generates START signal
+ */
+static void
+i2c_start(
+	struct i2c_algo_mcf_data *adap
+) {
+	MCF_I2CR |= MCF_I2CR_MSTA;
+}
+
+
+/*
+ *  static void i2c_stop()
+ *
+ *  Generates STOP signal
+ */
+static void
+i2c_stop(
+	struct i2c_algo_mcf_data *adap
+) {
+	MCF_I2CR &= ~MCF_I2CR_MSTA;
+}
+
+static int
+i2c_getack(
+	struct i2c_algo_mcf_data *adap
+) {
+	return !(MCF_I2SR & MCF_I2SR_RXAK);
+}
+
+/*
+ *  static void i2c_repstart()
+ *
+ *  Generates repeated start signal (without STOP while mastering the bus)
+ */
+static void
+i2c_repstart(
+	struct i2c_algo_mcf_data *adap
+) {
+	MCF_I2CR |= MCF_I2CR_RSTA;
+	MCF_I2CR |= MCF_I2CR_MTX;
+}
+
+
+/*
+ *  static void wait_for_bb()
+ *
+ *  Wait for bus idle state
+ */
+static int
+wait_for_bb(
+	struct i2c_algo_mcf_data *adap
+) {
+	int i;
+	for (i = 0; i < adap->timeout; i++) {
+		if (!(MCF_I2SR & MCF_I2SR_IBB))
+			return 0;
+		udelay(100);
+	}
+	printk(KERN_ERR "%s: timeout", __func__);
+	return -ETIMEDOUT;
+}
+
+/*
+ *  static void wait_for_not_bb()
+ *
+ *  Wait for bus busy state
+ */
+static int
+wait_for_not_bb(
+	struct i2c_algo_mcf_data *adap
+) {
+	int i;
+	for (i = 0; i < adap->timeout; i++) {
+		if (MCF_I2SR & MCF_I2SR_IBB)
+			return 0;
+		udelay(100);
+	}
+	printk(KERN_ERR "%s: timeout", __func__);
+	return -ETIMEDOUT;
+}
+
+/*
+ *  static void wait_xfer_done()
+ *
+ *  Wait for transfer to complete
+ */
+static int
+wait_xfer_done(
+	struct i2c_algo_mcf_data *adap
+) {
+	int i;
+
+	for (i = 0; i < adap->timeout; i++) {
+		if (MCF_I2SR & MCF_I2SR_IIF) {
+			MCF_I2SR &= ~MCF_I2SR_IIF;
+			return 0;
+		}
+		udelay(10);
+	}
+	printk(KERN_ERR "%s: timeout", __func__);
+	return -ETIMEDOUT;
+}
+
+
+/*
+ *  static void i2c_set_addr()
+ *
+ *  Sets slave address to communicate
+ */
+static int
+i2c_set_addr(
+	struct i2c_algo_mcf_data *adap,
+	struct i2c_msg *msg,
+	int retries
+) {
+	unsigned short flags = msg->flags;
+	unsigned char addr;
+	MCF_I2CR |= MCF_I2CR_MTX;
+	if ((flags & I2C_M_TEN)) {
+		/* 10 bit address not supported yet */
+		return -EIO;
+	} else {
+		/* normal 7bit address */
+		addr = (msg->addr << 1);
+		if (flags & I2C_M_RD)
+			addr |= 1;
+		if (flags & I2C_M_REV_DIR_ADDR)
+			addr ^= 1;
+
+		MCF_I2DR = addr;
+	}
+	return 0;
+}
+
+
+/*
+ *  static void mcf_i2c_init()
+ *
+ *  Perform ColdFire i2c initialization
+ */
+static void
+mcf_i2c_init(struct i2c_algo_mcf_data *adap)
+{
+	u8 dummy;
+
+	/* Setup GPIO lines */
+#if defined(CONFIG_M547X_8X)
+	MCF_PAR_FECI2CIRQ |= MCF_PAR_SDA;
+	MCF_PAR_FECI2CIRQ |= MCF_PAR_SCL;
+#elif defined(CONFIG_M5445X)
+	MCF_GPIO_PAR_FECI2C |= (0
+		| MCF_GPIO_PAR_FECI2C_PAR_SDA(3)
+		| MCF_GPIO_PAR_FECI2C_PAR_SCL(3));
+#endif
+
+	/*  Ensure slaves are in idle state */
+	if (MCF_I2SR & MCF_I2SR_IBB) {
+#if defined(CONFIG_M547X_8X)
+		MCF_I2ICR = 0x00;
+		MCF_I2CR  = 0x00;
+		MCF_I2CR  = 0x0A;
+		dummy = MCF_I2DR;
+		MCF_I2SR  = 0x00;
+		MCF_I2CR  = 0x00;
+		MCF_I2ICR = 0x01;
+#elif defined(CONFIG_M5445X)
+		MCF_I2CR = 0x00;
+		MCF_I2CR = 0xA0;
+		dummy = MCF_I2DR;
+		MCF_I2SR = 0x00;
+		MCF_I2CR = 0x00;
+		MCF_I2CR = 0x80;
+#endif
+	}
+
+	/* setup SCL clock */
+	MCF_I2FDR = get_clock(adap);
+
+	/* set slave address */
+	MCF_I2AR = get_own(adap);
+
+	/* enable I2C module */
+	MCF_I2CR = MCF_I2CR_IEN;
+}
+
+static int i2c_outb(
+	struct i2c_adapter *i2c_adap,
+	char c
+) {
+
+	struct i2c_algo_mcf_data *adap = i2c_adap->algo_data;
+	int timeout;
+	/* Put data to be sent */
+	MCF_I2DR = c;
+	/* Wait for xfer completed*/
+	timeout = wait_xfer_done(adap);
+	if (timeout) {
+		i2c_stop(adap);
+		wait_for_bb(adap);
+		printk(KERN_ERR "i2c-algo-mcf: %s i2c_write: "
+			"error - timeout.\n", i2c_adap->name);
+		return -EREMOTEIO; /* got a better one ?? */
+	}
+
+	return 0;
+}
+
+
+/*
+ *  static void mcf_sendbytes()
+ *
+ *  Perform tx data transfer
+ */
+static int
+mcf_sendbytes(
+	struct i2c_adapter *i2c_adap,
+	const char *buf,
+	int count, int last
+) {
+	struct i2c_algo_mcf_data *adap = i2c_adap->algo_data;
+	int ret, i;
+
+	/* Set master TX mode */
+	MCF_I2CR |= MCF_I2CR_MTX;
+
+	for (i = 0; i < count; ++i) {
+		printk(KERN_DEBUG "i2c-algo-mcf: %s i2c_write: writing %2.2X\n",
+		      i2c_adap->name, buf[i]&0xff);
+		ret = i2c_outb(i2c_adap, buf[i]);
+		if (ret < 0)
+			return ret;
+	}
+	if (last) {
+		i2c_stop(adap);
+		wait_for_bb(adap);
+	} else {
+	/*	i2c_repstart(adap);*/
+	}
+
+	return i;
+}
+
+
+/*
+ *  static void mcf_readbytes()
+ *
+ *  Perform rx data transfer
+ */
+static int
+mcf_readbytes(
+	struct i2c_adapter *i2c_adap,
+	char *buf,
+	int count, int last
+) {
+	int i;
+	struct i2c_algo_mcf_data *adap = i2c_adap->algo_data;
+	u8 dummy;
+
+	/* Set master RX mode */
+	MCF_I2CR &= ~MCF_I2CR_MTX;
+	MCF_I2CR &= ~MCF_I2CR_TXAK;
+	dummy = MCF_I2DR;
+
+	for (i = 0; i < count-1; i++) {
+		if (wait_xfer_done(adap)) {
+			i2c_stop(adap);
+			wait_for_bb(adap);
+			printk(KERN_DEBUG
+			    "i2c-algo-mcf: mcf_readbytes timed out.\n");
+			return -1;
+		}
+
+		/* store next data byte */
+		buf[i] = MCF_I2DR;
+	}
+
+	if (wait_xfer_done(adap)) {
+		i2c_stop(adap);
+		wait_for_bb(adap);
+		printk(KERN_DEBUG "i2c-algo-mcf: mcf_readbytes timed out.\n");
+		return -1;
+	}
+
+	/* Disable acknowlege (set I2CR.TXAK) */
+	MCF_I2CR |= MCF_I2CR_TXAK;
+	buf[i] = MCF_I2DR;
+	if (wait_xfer_done(adap)) {
+		i2c_stop(adap);
+		wait_for_bb(adap);
+		printk(KERN_DEBUG "i2c-algo-mcf: mcf_readbytes timed out.\n");
+		return -1;
+	}
+
+	if (last) {
+		i2c_stop(adap);
+		wait_for_bb(adap);
+	} else {
+	/*	i2c_repstart(adap);*/
+	}
+
+	return i+1;
+}
+
+
+/*
+ *  static void mcf_xfer()
+ *
+ *  Perform master data I/O transfer
+ */
+static int
+mcf_xfer(
+	struct i2c_adapter *i2c_adap,
+	struct i2c_msg *msgs,
+	int num)
+{
+	struct i2c_algo_mcf_data *adap = i2c_adap->algo_data;
+	struct i2c_msg *pmsg;
+	int i;
+	int ret = 0, timeout;
+
+	/* Skip own address */
+	if (get_own(adap) == (msgs[0].addr << 1))
+		return -EIO;
+
+	/*  Ensure slaves are in idle state */
+	if (MCF_I2SR & MCF_I2SR_IBB) {
+#if defined(CONFIG_M547X_8X)
+		MCF_I2ICR = 0x00;
+		MCF_I2CR  = 0x00;
+		MCF_I2CR  = 0x0A;
+		timeout = MCF_I2DR;
+		MCF_I2SR  = 0x00;
+		MCF_I2CR  = 0x00;
+		MCF_I2ICR = 0x01;
+#elif defined(CONFIG_M5445X)
+		MCF_I2CR = 0x00;
+		MCF_I2CR = 0xA0;
+		timeout = MCF_I2DR;
+		MCF_I2SR = 0x00;
+		MCF_I2CR = 0x00;
+		MCF_I2CR = 0x80;
+#endif
+	}
+
+	/* setup SCL clock */
+	MCF_I2FDR = get_clock(adap);
+	/* set slave address */
+	MCF_I2AR = get_own(adap);
+	/* enable I2C module */
+	MCF_I2CR = MCF_I2CR_IEN;
+
+	MCF_I2CR |= MCF_I2CR_TXAK;
+
+	/* Check for bus busy */
+	wait_for_bb(adap);
+
+	for (i = 0; ret >= 0 && i < num; i++) {
+		if (MCF_I2SR & MCF_I2SR_IBB) {
+#if defined(CONFIG_M547X_8X)
+			MCF_I2ICR = 0x00;
+			MCF_I2CR  = 0x00;
+			MCF_I2CR  = 0x0A;
+			timeout = MCF_I2DR;
+			MCF_I2SR  = 0x00;
+			MCF_I2CR  = 0x00;
+			MCF_I2ICR = 0x01;
+#elif defined(CONFIG_M5445X)
+		MCF_I2CR = 0x00;
+		MCF_I2CR = 0xA0;
+		timeout = MCF_I2DR;
+		MCF_I2SR = 0x00;
+		MCF_I2CR = 0x00;
+		MCF_I2CR = 0x80;
+#endif
+		}
+		/* setup SCL clock */
+		MCF_I2FDR = get_clock(adap);
+		/* set slave address */
+		MCF_I2AR = get_own(adap);
+		/* enable I2C module */
+		MCF_I2CR = MCF_I2CR_IEN;
+
+		MCF_I2CR |= MCF_I2CR_TXAK;
+
+		/* Check for bus busy */
+		wait_for_bb(adap);
+
+		pmsg = &msgs[i];
+
+		printk(KERN_DEBUG "i2c-algo-mcf: Doing %s %d bytes "
+			"to 0x%02x - %d of %d messages\n",
+			pmsg->flags & I2C_M_RD ? "read" : "write",
+			pmsg->len, pmsg->addr, i + 1, num);
+
+		/* Send START */
+		/*if (i == 0)*/
+			i2c_start(adap);
+
+		/* Wait for Bus Busy */
+		wait_for_not_bb(adap);
+
+		MCF_I2CR |= MCF_I2CR_MTX;
+
+		ret = i2c_set_addr(adap, pmsg, i2c_adap->retries);
+		if (ret < 0)
+			return ret;
+
+		/* Wait for address transfer completion */
+		wait_xfer_done(adap);
+
+		/* Check for ACK */
+		if (!i2c_getack(adap)) {
+			i2c_stop(adap);
+			wait_for_bb(adap);
+			printk(KERN_DEBUG "i2c-algo-mcf: No ack after "
+				    "send address in mcf_xfer\n");
+			return -EREMOTEIO;
+		}
+
+		printk(KERN_DEBUG "i2c-algo-mcf: Msg %d, "
+				  "addr = 0x%x, flags = 0x%x, len = %d\n",
+				i, msgs[i].addr, msgs[i].flags, msgs[i].len);
+		/* Read */
+		if (pmsg->flags & I2C_M_RD) {
+			/* read bytes into buffer*/
+			ret = mcf_readbytes(i2c_adap, pmsg->buf, pmsg->len,
+						(i + 1 == num));
+
+			if (ret != pmsg->len) {
+				printk(KERN_DEBUG "i2c-algo-mcf: fail: "
+					    "only read %d bytes.\n", ret);
+			} else {
+				printk(KERN_DEBUG "i2c-algo-mcf: "
+						  "read %d bytes.\n", ret);
+			}
+		} else {
+			/* write bytes into buffer*/
+			ret = mcf_sendbytes(i2c_adap, pmsg->buf, pmsg->len,
+						(i + 1 == num));
+			if (ret != pmsg->len) {
+				printk(KERN_DEBUG "i2c-algo-mcf: fail: "
+					    "only wrote %d bytes.\n", ret);
+			} else {
+				printk(KERN_DEBUG "i2c-algo-mcf: wrote"
+					"%d bytes.\n", ret);
+			}
+		}
+	MCF_I2CR = 0;
+	}
+
+	/* Disable I2C module */
+	MCF_I2CR = 0;
+	return i;
+}
+
+
+/*
+ *  static void mcf_func()
+ *
+ *  Return algorithm funtionality
+ */
+static u32
+mcf_func(
+	struct i2c_adapter *i2c_adap
+) {
+	return I2C_FUNC_SMBUS_EMUL | I2C_FUNC_I2C;
+}
+
+/*
+ *  ColdFire bus algorithm callbacks
+ */
+static struct i2c_algorithm mcf_algo = {
+	.master_xfer    = mcf_xfer,
+	.functionality  = mcf_func,
+};
+
+/***********************************************************/
+struct coldfire_i2c {
+	void __iomem *base;
+	struct resource *irqarea;
+	struct resource *ioarea;
+	u32 irq;
+	struct i2c_adapter *adap;
+	u32 flags;
+};
+
+/*
+ *  registering functions to load algorithms at runtime
+ */
+int i2c_mcf_add_bus(struct i2c_adapter *adap)
+{
+	struct i2c_algo_mcf_data *mcf_adap = adap->algo_data;
+
+	/*adap->id |= mcf_algo.id;*/
+	adap->algo = &mcf_algo;
+	adap->timeout = 100;
+
+	mcf_i2c_init(mcf_adap);
+
+#ifdef MODULE
+	MOD_INC_USE_COUNT;
+#endif
+	i2c_add_numbered_adapter(adap);
+
+	return 0;
+}
+
+static int mcf_i2c_probe(struct platform_device *pdev)
+{
+	struct coldfire_i2c *i2c;
+	int rc = 0;
+
+	/************************************************************/
+	i2c = kzalloc(sizeof(*i2c), GFP_KERNEL);
+	if (!i2c) {
+		printk(KERN_ERR "%s kzalloc coldfire_i2c faile\n",
+				__func__);
+		return -ENOMEM;
+	}
+	/****************************************************************/
+	platform_set_drvdata(pdev, i2c);
+
+	i2c->adap = &i2c_mcf_board_adapter;
+	i2c->adap->dev.parent = &pdev->dev;
+	i2c->adap->nr = pdev->id;
+	rc = i2c_mcf_add_bus(i2c->adap);
+	if (rc < 0) {
+		printk(KERN_ERR "%s - failed to add adapter\n", __func__);
+		rc = -ENODEV;
+		goto fail_add;
+	}
+
+	printk(KERN_INFO "i2c-algo-mcf.o: I2C ColdFire algorithm"
+			" module is loaded.\n");
+	return rc;
+
+fail_add:
+	kfree(i2c);
+	return rc;
+};
+
+static int mcf_i2c_remove(struct platform_device *pdev)
+{
+	struct coldfire_i2c *i2c = platform_get_drvdata(pdev);
+
+	i2c_del_adapter(i2c->adap);
+	platform_set_drvdata(pdev, NULL);
+	iounmap(i2c->base);
+	kfree(i2c);
+	return 0;
+};
+
+/* Structure for a device driver */
+static struct platform_driver mcf_i2c_driver = {
+	.probe 	= mcf_i2c_probe,
+	.remove = mcf_i2c_remove,
+	.driver	= {
+		.owner = THIS_MODULE,
+		.name = "mcf-i2c",
+	},
+};
+
+#ifdef CONFIG_PROC_FS
+
+/*
+ *	Info exported via "/proc/driver/i2c".
+ */
+
+static int gen_i2c_proc_output(char *buf)
+{
+	char *p;
+
+	p = buf;
+	p += sprintf(p,
+		     "I2CR: 0x%x\n"
+		     "I2SR: 0x%x\n"
+		     "I2DR: 0x%x\n",
+		     MCF_I2CR, MCF_I2SR, MCF_I2DR);
+
+	return p - buf;
+}
+
+static int gen_i2c_read_proc(char *page, char **start, off_t off,
+			     int count, int *eof, void *data)
+{
+	int len = gen_i2c_proc_output(page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len > count) len = count;
+	if (len < 0) len = 0;
+	return len;
+}
+
+static int __init gen_i2c_proc_init(void)
+{
+	struct proc_dir_entry *r;
+
+	r = create_proc_read_entry("driver/i2c-adaptor-register", 0, NULL, gen_i2c_read_proc, NULL);
+	if (!r)
+		return -ENOMEM;
+	return 0;
+}
+#else
+static inline int gen_i2c_proc_init(void) { return 0; }
+#endif /* CONFIG_PROC_FS */
+
+static int __init coldfire_i2c_init(void)
+{
+	int retval;
+
+	retval = gen_i2c_proc_init();
+	if (retval < 0)
+		printk(KERN_INFO "generate /proc/i2c-adaptor-register "
+                                 "for i2c master mode failed!\n");
+
+	return platform_driver_register(&mcf_i2c_driver);
+}
+
+static void __exit coldfire_i2c_exit(void)
+{
+	platform_driver_unregister(&mcf_i2c_driver);
+}
+
+module_init(coldfire_i2c_init);
+module_exit(coldfire_i2c_exit);
+
+MODULE_AUTHOR("Adrian Cox <adrian@humboldt.co.uk>");
+MODULE_DESCRIPTION
+    ("I2C-Bus adapter for MCFV4/MCFV4E processors");
+MODULE_LICENSE("GPL");
diff --git a/drivers/i2c/i2c-boardinfo.c b/drivers/i2c/i2c-boardinfo.c
index ffb35f0..a26a34a 100644
--- a/drivers/i2c/i2c-boardinfo.c
+++ b/drivers/i2c/i2c-boardinfo.c
@@ -18,6 +18,7 @@
 
 #include <linux/kernel.h>
 #include <linux/i2c.h>
+#include <linux/rwsem.h>
 
 #include "i2c-core.h"
 
@@ -25,7 +26,7 @@
 /* These symbols are exported ONLY FOR the i2c core.
  * No other users will be supported.
  */
-DEFINE_MUTEX(__i2c_board_lock);
+DECLARE_RWSEM(__i2c_board_lock);
 EXPORT_SYMBOL_GPL(__i2c_board_lock);
 
 LIST_HEAD(__i2c_board_list);
@@ -63,7 +64,7 @@ i2c_register_board_info(int busnum,
 {
 	int status;
 
-	mutex_lock(&__i2c_board_lock);
+	down_write(&__i2c_board_lock);
 
 	/* dynamic bus numbers will be assigned after the last static one */
 	if (busnum >= __i2c_first_dynamic_bus_num)
@@ -84,7 +85,7 @@ i2c_register_board_info(int busnum,
 		list_add_tail(&devinfo->list, &__i2c_board_list);
 	}
 
-	mutex_unlock(&__i2c_board_lock);
+	up_write(&__i2c_board_lock);
 
 	return status;
 }
diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c
index e7d9848..a072ac8 100644
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@ -16,6 +16,7 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.		     */
 /* ------------------------------------------------------------------------- */
+/* Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved. */
 
 /* With some changes from Kyösti Mälkki <kmalkki@cc.hut.fi>.
    All SMBus-related things are written by Frodo Looijaard <frodol@dds.nl>
@@ -29,21 +30,25 @@
 #include <linux/i2c.h>
 #include <linux/init.h>
 #include <linux/idr.h>
-#include <linux/platform_device.h>
 #include <linux/mutex.h>
 #include <linux/completion.h>
 #include <linux/hardirq.h>
 #include <linux/irqflags.h>
+#include <linux/rwsem.h>
 #include <asm/uaccess.h>
 
 #include "i2c-core.h"
 
 
+/* core_lock protects i2c_adapter_idr, userspace_devices, and guarantees
+   that device detection, deletion of detected devices, and attach_adapter
+   and detach_adapter calls are serialized */
 static DEFINE_MUTEX(core_lock);
 static DEFINE_IDR(i2c_adapter_idr);
+static LIST_HEAD(userspace_devices);
 
-#define is_newstyle_driver(d) ((d)->probe || (d)->remove || (d)->detect)
-
+static struct device_type i2c_client_type;
+static int i2c_check_addr(struct i2c_adapter *adapter, int addr);
 static int i2c_detect(struct i2c_adapter *adapter, struct i2c_driver *driver);
 
 /* ------------------------------------------------------------------------- */
@@ -61,15 +66,13 @@ static const struct i2c_device_id *i2c_match_id(const struct i2c_device_id *id,
 
 static int i2c_device_match(struct device *dev, struct device_driver *drv)
 {
-	struct i2c_client	*client = to_i2c_client(dev);
-	struct i2c_driver	*driver = to_i2c_driver(drv);
+	struct i2c_client	*client = i2c_verify_client(dev);
+	struct i2c_driver	*driver;
 
-	/* make legacy i2c drivers bypass driver model probing entirely;
-	 * such drivers scan each i2c adapter/bus themselves.
-	 */
-	if (!is_newstyle_driver(driver))
+	if (!client)
 		return 0;
 
+	driver = to_i2c_driver(drv);
 	/* match on an id table if there is one */
 	if (driver->id_table)
 		return i2c_match_id(driver->id_table, client) != NULL;
@@ -84,10 +87,6 @@ static int i2c_device_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	struct i2c_client	*client = to_i2c_client(dev);
 
-	/* by definition, legacy drivers can't hotplug */
-	if (dev->driver)
-		return 0;
-
 	if (add_uevent_var(env, "MODALIAS=%s%s",
 			   I2C_MODULE_PREFIX, client->name))
 		return -ENOMEM;
@@ -101,10 +100,14 @@ static int i2c_device_uevent(struct device *dev, struct kobj_uevent_env *env)
 
 static int i2c_device_probe(struct device *dev)
 {
-	struct i2c_client	*client = to_i2c_client(dev);
-	struct i2c_driver	*driver = to_i2c_driver(dev->driver);
+	struct i2c_client	*client = i2c_verify_client(dev);
+	struct i2c_driver	*driver;
 	int status;
 
+	if (!client)
+		return 0;
+
+	driver = to_i2c_driver(dev->driver);
 	if (!driver->probe || !driver->id_table)
 		return -ENODEV;
 	client->driver = driver;
@@ -121,11 +124,11 @@ static int i2c_device_probe(struct device *dev)
 
 static int i2c_device_remove(struct device *dev)
 {
-	struct i2c_client	*client = to_i2c_client(dev);
+	struct i2c_client	*client = i2c_verify_client(dev);
 	struct i2c_driver	*driver;
 	int			status;
 
-	if (!dev->driver)
+	if (!client || !dev->driver)
 		return 0;
 
 	driver = to_i2c_driver(dev->driver);
@@ -143,43 +146,40 @@ static int i2c_device_remove(struct device *dev)
 
 static void i2c_device_shutdown(struct device *dev)
 {
+	struct i2c_client *client = i2c_verify_client(dev);
 	struct i2c_driver *driver;
 
-	if (!dev->driver)
+	if (!client || !dev->driver)
 		return;
 	driver = to_i2c_driver(dev->driver);
 	if (driver->shutdown)
-		driver->shutdown(to_i2c_client(dev));
+		driver->shutdown(client);
 }
 
-static int i2c_device_suspend(struct device * dev, pm_message_t mesg)
+static int i2c_device_suspend(struct device *dev, pm_message_t mesg)
 {
+	struct i2c_client *client = i2c_verify_client(dev);
 	struct i2c_driver *driver;
 
-	if (!dev->driver)
+	if (!client || !dev->driver)
 		return 0;
 	driver = to_i2c_driver(dev->driver);
 	if (!driver->suspend)
 		return 0;
-	return driver->suspend(to_i2c_client(dev), mesg);
+	return driver->suspend(client, mesg);
 }
 
-static int i2c_device_resume(struct device * dev)
+static int i2c_device_resume(struct device *dev)
 {
+	struct i2c_client *client = i2c_verify_client(dev);
 	struct i2c_driver *driver;
 
-	if (!dev->driver)
+	if (!client || !dev->driver)
 		return 0;
 	driver = to_i2c_driver(dev->driver);
 	if (!driver->resume)
 		return 0;
-	return driver->resume(to_i2c_client(dev));
-}
-
-static void i2c_client_release(struct device *dev)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-	complete(&client->released);
+	return driver->resume(client);
 }
 
 static void i2c_client_dev_release(struct device *dev)
@@ -187,30 +187,42 @@ static void i2c_client_dev_release(struct device *dev)
 	kfree(to_i2c_client(dev));
 }
 
-static ssize_t show_client_name(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t
+show_name(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct i2c_client *client = to_i2c_client(dev);
-	return sprintf(buf, "%s\n", client->name);
+	return sprintf(buf, "%s\n", dev->type == &i2c_client_type ?
+		       to_i2c_client(dev)->name : to_i2c_adapter(dev)->name);
 }
 
-static ssize_t show_modalias(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t
+show_modalias(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct i2c_client *client = to_i2c_client(dev);
 	return sprintf(buf, "%s%s\n", I2C_MODULE_PREFIX, client->name);
 }
 
-static struct device_attribute i2c_dev_attrs[] = {
-	__ATTR(name, S_IRUGO, show_client_name, NULL),
+static DEVICE_ATTR(name, S_IRUGO, show_name, NULL);
+static DEVICE_ATTR(modalias, S_IRUGO, show_modalias, NULL);
+
+static struct attribute *i2c_dev_attrs[] = {
+	&dev_attr_name.attr,
 	/* modalias helps coldplug:  modprobe $(cat .../modalias) */
-	__ATTR(modalias, S_IRUGO, show_modalias, NULL),
-	{ },
+	&dev_attr_modalias.attr,
+	NULL
+};
+
+static struct attribute_group i2c_dev_attr_group = {
+	.attrs		= i2c_dev_attrs,
+};
+
+static const struct attribute_group *i2c_dev_attr_groups[] = {
+	&i2c_dev_attr_group,
+	NULL
 };
 
 struct bus_type i2c_bus_type = {
 	.name		= "i2c",
-	.dev_attrs	= i2c_dev_attrs,
 	.match		= i2c_device_match,
-	.uevent		= i2c_device_uevent,
 	.probe		= i2c_device_probe,
 	.remove		= i2c_device_remove,
 	.shutdown	= i2c_device_shutdown,
@@ -219,6 +231,12 @@ struct bus_type i2c_bus_type = {
 };
 EXPORT_SYMBOL_GPL(i2c_bus_type);
 
+static struct device_type i2c_client_type = {
+	.groups		= i2c_dev_attr_groups,
+	.uevent		= i2c_device_uevent,
+	.release	= i2c_client_dev_release,
+};
+
 
 /**
  * i2c_verify_client - return parameter as i2c_client, or NULL
@@ -231,7 +249,7 @@ EXPORT_SYMBOL_GPL(i2c_bus_type);
  */
 struct i2c_client *i2c_verify_client(struct device *dev)
 {
-	return (dev->bus == &i2c_bus_type)
+	return (dev->type == &i2c_client_type)
 			? to_i2c_client(dev)
 			: NULL;
 }
@@ -239,15 +257,17 @@ EXPORT_SYMBOL(i2c_verify_client);
 
 
 /**
- * i2c_new_device - instantiate an i2c device for use with a new style driver
+ * i2c_new_device - instantiate an i2c device
  * @adap: the adapter managing the device
  * @info: describes one I2C device; bus_num is ignored
  * Context: can sleep
  *
- * Create a device to work with a new style i2c driver, where binding is
- * handled through driver model probe()/remove() methods.  This call is not
- * appropriate for use by mainboad initialization logic, which usually runs
- * during an arch_initcall() long before any i2c_adapter could exist.
+ * Create an i2c device. Binding is handled through driver model
+ * probe()/remove() methods.  A driver may be bound to this device when we
+ * return from this function, or any later moment (e.g. maybe hotplugging will
+ * load the driver module).  This call is not appropriate for use by mainboard
+ * initialization logic, which usually runs during an arch_initcall() long
+ * before any i2c_adapter could exist.
  *
  * This returns the new i2c client, which may be saved for later use with
  * i2c_unregister_device(); or NULL to indicate an error.
@@ -275,17 +295,31 @@ i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)
 
 	strlcpy(client->name, info->type, sizeof(client->name));
 
-	/* a new style driver may be bound to this device when we
-	 * return from this function, or any later moment (e.g. maybe
-	 * hotplugging will load the driver module).  and the device
-	 * refcount model is the standard driver model one.
-	 */
-	status = i2c_attach_client(client);
-	if (status < 0) {
-		kfree(client);
-		client = NULL;
-	}
+	/* Check for address business */
+	status = i2c_check_addr(adap, client->addr);
+	if (status)
+		goto out_err;
+
+	client->dev.parent = &client->adapter->dev;
+	client->dev.bus = &i2c_bus_type;
+	client->dev.type = &i2c_client_type;
+
+	dev_set_name(&client->dev, "%d-%04x", i2c_adapter_id(adap),
+		     client->addr);
+	status = device_register(&client->dev);
+	if (status)
+		goto out_err;
+
+	dev_dbg(&adap->dev, "client [%s] registered with bus id %s\n",
+		client->name, dev_name(&client->dev));
+
 	return client;
+
+out_err:
+	dev_err(&adap->dev, "Failed to register i2c client %s at 0x%02x "
+		"(%d)\n", client->name, client->addr, status);
+	kfree(client);
+	return NULL;
 }
 EXPORT_SYMBOL_GPL(i2c_new_device);
 
@@ -297,28 +331,6 @@ EXPORT_SYMBOL_GPL(i2c_new_device);
  */
 void i2c_unregister_device(struct i2c_client *client)
 {
-	struct i2c_adapter	*adapter = client->adapter;
-	struct i2c_driver	*driver = client->driver;
-
-	if (driver && !is_newstyle_driver(driver)) {
-		dev_err(&client->dev, "can't unregister devices "
-			"with legacy drivers\n");
-		WARN_ON(1);
-		return;
-	}
-
-	if (adapter->client_unregister) {
-		if (adapter->client_unregister(client)) {
-			dev_warn(&client->dev,
-				 "client_unregister [%s] failed\n",
-				 client->name);
-		}
-	}
-
-	mutex_lock(&adapter->clist_lock);
-	list_del(&client->list);
-	mutex_unlock(&adapter->clist_lock);
-
 	device_unregister(&client->dev);
 }
 EXPORT_SYMBOL_GPL(i2c_unregister_device);
@@ -365,8 +377,7 @@ static struct i2c_driver dummy_driver = {
  * This returns the new i2c client, which should be saved for later use with
  * i2c_unregister_device(); or NULL to indicate an error.
  */
-struct i2c_client *
-i2c_new_dummy(struct i2c_adapter *adapter, u16 address)
+struct i2c_client *i2c_new_dummy(struct i2c_adapter *adapter, u16 address)
 {
 	struct i2c_board_info info = {
 		I2C_BOARD_INFO("dummy", address),
@@ -386,38 +397,166 @@ static void i2c_adapter_dev_release(struct device *dev)
 	complete(&adap->dev_released);
 }
 
+/*
+ * Let users instantiate I2C devices through sysfs. This can be used when
+ * platform initialization code doesn't contain the proper data for
+ * whatever reason. Also useful for drivers that do device detection and
+ * detection fails, either because the device uses an unexpected address,
+ * or this is a compatible device with different ID register values.
+ *
+ * Parameter checking may look overzealous, but we really don't want
+ * the user to provide incorrect parameters.
+ */
 static ssize_t
-show_adapter_name(struct device *dev, struct device_attribute *attr, char *buf)
+i2c_sysfs_new_device(struct device *dev, struct device_attribute *attr,
+		     const char *buf, size_t count)
 {
 	struct i2c_adapter *adap = to_i2c_adapter(dev);
-	return sprintf(buf, "%s\n", adap->name);
+	struct i2c_board_info info;
+	struct i2c_client *client;
+	char *blank, end;
+	int res;
+
+	dev_warn(dev, "The new_device interface is still experimental "
+		 "and may change in a near future\n");
+	memset(&info, 0, sizeof(struct i2c_board_info));
+
+	blank = strchr(buf, ' ');
+	if (!blank) {
+		dev_err(dev, "%s: Missing parameters\n", "new_device");
+		return -EINVAL;
+	}
+	if (blank - buf > I2C_NAME_SIZE - 1) {
+		dev_err(dev, "%s: Invalid device name\n", "new_device");
+		return -EINVAL;
+	}
+	memcpy(info.type, buf, blank - buf);
+
+	/* Parse remaining parameters, reject extra parameters */
+	res = sscanf(++blank, "%hi%c", &info.addr, &end);
+	if (res < 1) {
+		dev_err(dev, "%s: Can't parse I2C address\n", "new_device");
+		return -EINVAL;
+	}
+	if (res > 1  && end != '\n') {
+		dev_err(dev, "%s: Extra parameters\n", "new_device");
+		return -EINVAL;
+	}
+
+	if (info.addr < 0x03 || info.addr > 0x77) {
+		dev_err(dev, "%s: Invalid I2C address 0x%hx\n", "new_device",
+			info.addr);
+		return -EINVAL;
+	}
+
+	client = i2c_new_device(adap, &info);
+	if (!client)
+		return -EEXIST;
+
+	/* Keep track of the added device */
+	mutex_lock(&core_lock);
+	list_add_tail(&client->detected, &userspace_devices);
+	mutex_unlock(&core_lock);
+	dev_info(dev, "%s: Instantiated device %s at 0x%02hx\n", "new_device",
+		 info.type, info.addr);
+
+	return count;
 }
 
-static struct device_attribute i2c_adapter_attrs[] = {
-	__ATTR(name, S_IRUGO, show_adapter_name, NULL),
-	{ },
+/*
+ * And of course let the users delete the devices they instantiated, if
+ * they got it wrong. This interface can only be used to delete devices
+ * instantiated by i2c_sysfs_new_device above. This guarantees that we
+ * don't delete devices to which some kernel code still has references.
+ *
+ * Parameter checking may look overzealous, but we really don't want
+ * the user to delete the wrong device.
+ */
+static ssize_t
+i2c_sysfs_delete_device(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct i2c_adapter *adap = to_i2c_adapter(dev);
+	struct i2c_client *client, *next;
+	unsigned short addr;
+	char end;
+	int res;
+
+	/* Parse parameters, reject extra parameters */
+	res = sscanf(buf, "%hi%c", &addr, &end);
+	if (res < 1) {
+		dev_err(dev, "%s: Can't parse I2C address\n", "delete_device");
+		return -EINVAL;
+	}
+	if (res > 1  && end != '\n') {
+		dev_err(dev, "%s: Extra parameters\n", "delete_device");
+		return -EINVAL;
+	}
+
+	/* Make sure the device was added through sysfs */
+	res = -ENOENT;
+	mutex_lock(&core_lock);
+	list_for_each_entry_safe(client, next, &userspace_devices, detected) {
+		if (client->addr == addr && client->adapter == adap) {
+			dev_info(dev, "%s: Deleting device %s at 0x%02hx\n",
+				 "delete_device", client->name, client->addr);
+
+			list_del(&client->detected);
+			i2c_unregister_device(client);
+			res = count;
+			break;
+		}
+	}
+	mutex_unlock(&core_lock);
+
+	if (res < 0)
+		dev_err(dev, "%s: Can't find device in list\n",
+			"delete_device");
+	return res;
+}
+
+static DEVICE_ATTR(new_device, S_IWUSR, NULL, i2c_sysfs_new_device);
+static DEVICE_ATTR(delete_device, S_IWUSR, NULL, i2c_sysfs_delete_device);
+
+static struct attribute *i2c_adapter_attrs[] = {
+	&dev_attr_name.attr,
+	&dev_attr_new_device.attr,
+	&dev_attr_delete_device.attr,
+	NULL
+};
+
+static struct attribute_group i2c_adapter_attr_group = {
+	.attrs		= i2c_adapter_attrs,
+};
+
+static const struct attribute_group *i2c_adapter_attr_groups[] = {
+	&i2c_adapter_attr_group,
+	NULL
 };
 
-static struct class i2c_adapter_class = {
-	.owner			= THIS_MODULE,
-	.name			= "i2c-adapter",
-	.dev_attrs		= i2c_adapter_attrs,
+static struct device_type i2c_adapter_type = {
+	.groups		= i2c_adapter_attr_groups,
+	.release	= i2c_adapter_dev_release,
 };
 
+#ifdef CONFIG_I2C_COMPAT
+static struct class_compat *i2c_adapter_compat_class;
+#endif
+
 static void i2c_scan_static_board_info(struct i2c_adapter *adapter)
 {
 	struct i2c_devinfo	*devinfo;
 
-	mutex_lock(&__i2c_board_lock);
+	down_read(&__i2c_board_lock);
 	list_for_each_entry(devinfo, &__i2c_board_list, list) {
 		if (devinfo->busnum == adapter->nr
 				&& !i2c_new_device(adapter,
 						&devinfo->board_info))
-			printk(KERN_ERR "i2c-core: can't create i2c%d-%04x\n",
-				i2c_adapter_id(adapter),
+			dev_err(&adapter->dev,
+				"Can't create device at 0x%02x\n",
 				devinfo->board_info.addr);
 	}
-	mutex_unlock(&__i2c_board_lock);
+	up_read(&__i2c_board_lock);
 }
 
 static int i2c_do_add_adapter(struct device_driver *d, void *data)
@@ -441,48 +580,51 @@ static int i2c_register_adapter(struct i2c_adapter *adap)
 	int res = 0, dummy;
 
 	/* Can't register until after driver model init */
-	if (unlikely(WARN_ON(!i2c_bus_type.p)))
-		return -EAGAIN;
+	if (unlikely(WARN_ON(!i2c_bus_type.p))) {
+		res = -EAGAIN;
+		goto out_list;
+	}
 
 	mutex_init(&adap->bus_lock);
-	mutex_init(&adap->clist_lock);
-	INIT_LIST_HEAD(&adap->clients);
 
-	mutex_lock(&core_lock);
+	/* Set default timeout to 1 second if not already set */
+	if (adap->timeout == 0)
+		adap->timeout = HZ;
 
-	/* Add the adapter to the driver core.
-	 * If the parent pointer is not set up,
-	 * we add this adapter to the host bus.
-	 */
-	if (adap->dev.parent == NULL) {
-		adap->dev.parent = &platform_bus;
-		pr_debug("I2C adapter driver [%s] forgot to specify "
-			 "physical device\n", adap->name);
-	}
 	dev_set_name(&adap->dev, "i2c-%d", adap->nr);
-	adap->dev.release = &i2c_adapter_dev_release;
-	adap->dev.class = &i2c_adapter_class;
+	adap->dev.bus = &i2c_bus_type;
+	adap->dev.type = &i2c_adapter_type;
 	res = device_register(&adap->dev);
 	if (res)
 		goto out_list;
 
 	dev_dbg(&adap->dev, "adapter [%s] registered\n", adap->name);
 
-	/* create pre-declared device nodes for new-style drivers */
+#ifdef CONFIG_I2C_COMPAT
+	res = class_compat_create_link(i2c_adapter_compat_class, &adap->dev,
+				       adap->dev.parent);
+	if (res)
+		dev_warn(&adap->dev,
+			 "Failed to create compatibility class link\n");
+#endif
+
+	/* create pre-declared device nodes */
 	if (adap->nr < __i2c_first_dynamic_bus_num)
 		i2c_scan_static_board_info(adap);
 
 	/* Notify drivers */
+	mutex_lock(&core_lock);
 	dummy = bus_for_each_drv(&i2c_bus_type, NULL, adap,
 				 i2c_do_add_adapter);
-
-out_unlock:
 	mutex_unlock(&core_lock);
-	return res;
+
+	return 0;
 
 out_list:
+	mutex_lock(&core_lock);
 	idr_remove(&i2c_adapter_idr, adap->nr);
-	goto out_unlock;
+	mutex_unlock(&core_lock);
+	return res;
 }
 
 /**
@@ -581,7 +723,8 @@ static int i2c_do_del_adapter(struct device_driver *d, void *data)
 	struct i2c_client *client, *_n;
 	int res;
 
-	/* Remove the devices we created ourselves */
+	/* Remove the devices we created ourselves as the result of hardware
+	 * probing (using a driver's detect method) */
 	list_for_each_entry_safe(client, _n, &driver->clients, detected) {
 		if (client->adapter == adapter) {
 			dev_dbg(&adapter->dev, "Removing %s at 0x%x\n",
@@ -600,6 +743,14 @@ static int i2c_do_del_adapter(struct device_driver *d, void *data)
 	return res;
 }
 
+static int __unregister_client(struct device *dev, void *dummy)
+{
+	struct i2c_client *client = i2c_verify_client(dev);
+	if (client)
+		i2c_unregister_device(client);
+	return 0;
+}
+
 /**
  * i2c_del_adapter - unregister I2C adapter
  * @adap: the adapter being unregistered
@@ -610,46 +761,35 @@ static int i2c_do_del_adapter(struct device_driver *d, void *data)
  */
 int i2c_del_adapter(struct i2c_adapter *adap)
 {
-	struct i2c_client *client, *_n;
 	int res = 0;
-
-	mutex_lock(&core_lock);
+	struct i2c_adapter *found;
 
 	/* First make sure that this adapter was ever added */
-	if (idr_find(&i2c_adapter_idr, adap->nr) != adap) {
+	mutex_lock(&core_lock);
+	found = idr_find(&i2c_adapter_idr, adap->nr);
+	mutex_unlock(&core_lock);
+	if (found != adap) {
 		pr_debug("i2c-core: attempting to delete unregistered "
 			 "adapter [%s]\n", adap->name);
-		res = -EINVAL;
-		goto out_unlock;
+		return -EINVAL;
 	}
 
 	/* Tell drivers about this removal */
+	mutex_lock(&core_lock);
 	res = bus_for_each_drv(&i2c_bus_type, NULL, adap,
 			       i2c_do_del_adapter);
+	mutex_unlock(&core_lock);
 	if (res)
-		goto out_unlock;
-
-	/* detach any active clients. This must be done first, because
-	 * it can fail; in which case we give up. */
-	list_for_each_entry_safe_reverse(client, _n, &adap->clients, list) {
-		struct i2c_driver	*driver;
-
-		driver = client->driver;
+		return res;
 
-		/* new style, follow standard driver model */
-		if (!driver || is_newstyle_driver(driver)) {
-			i2c_unregister_device(client);
-			continue;
-		}
+	/* Detach any active clients. This can't fail, thus we do not
+	   checking the returned value. */
+	res = device_for_each_child(&adap->dev, NULL, __unregister_client);
 
-		/* legacy drivers create and remove clients themselves */
-		if ((res = driver->detach_client(client))) {
-			dev_err(&adap->dev, "detach_client failed for client "
-				"[%s] at address 0x%02x\n", client->name,
-				client->addr);
-			goto out_unlock;
-		}
-	}
+#ifdef CONFIG_I2C_COMPAT
+	class_compat_remove_link(i2c_adapter_compat_class, &adap->dev,
+				 adap->dev.parent);
+#endif
 
 	/* clean up the sysfs representation */
 	init_completion(&adap->dev_released);
@@ -659,7 +799,9 @@ int i2c_del_adapter(struct i2c_adapter *adap)
 	wait_for_completion(&adap->dev_released);
 
 	/* free bus id */
+	mutex_lock(&core_lock);
 	idr_remove(&i2c_adapter_idr, adap->nr);
+	mutex_unlock(&core_lock);
 
 	dev_dbg(&adap->dev, "adapter [%s] unregistered\n", adap->name);
 
@@ -667,9 +809,7 @@ int i2c_del_adapter(struct i2c_adapter *adap)
 	   added again */
 	memset(&adap->dev, 0, sizeof(adap->dev));
 
- out_unlock:
-	mutex_unlock(&core_lock);
-	return res;
+	return 0;
 }
 EXPORT_SYMBOL(i2c_del_adapter);
 
@@ -678,9 +818,13 @@ EXPORT_SYMBOL(i2c_del_adapter);
 
 static int __attach_adapter(struct device *dev, void *data)
 {
-	struct i2c_adapter *adapter = to_i2c_adapter(dev);
+	struct i2c_adapter *adapter;
 	struct i2c_driver *driver = data;
 
+	if (dev->type != &i2c_adapter_type)
+		return 0;
+	adapter = to_i2c_adapter(dev);
+
 	i2c_detect(adapter, driver);
 
 	/* Legacy drivers scan i2c busses directly */
@@ -692,11 +836,7 @@ static int __attach_adapter(struct device *dev, void *data)
 
 /*
  * An i2c_driver is used with one or more i2c_client (device) nodes to access
- * i2c slave chips, on a bus instance associated with some i2c_adapter.  There
- * are two models for binding the driver to its device:  "new style" drivers
- * follow the standard Linux driver model and just respond to probe() calls
- * issued if the driver core sees they match(); "legacy" drivers create device
- * nodes themselves.
+ * i2c slave chips, on a bus instance associated with some i2c_adapter.
  */
 
 int i2c_register_driver(struct module *owner, struct i2c_driver *driver)
@@ -707,48 +847,41 @@ int i2c_register_driver(struct module *owner, struct i2c_driver *driver)
 	if (unlikely(WARN_ON(!i2c_bus_type.p)))
 		return -EAGAIN;
 
-	/* new style driver methods can't mix with legacy ones */
-	if (is_newstyle_driver(driver)) {
-		if (driver->attach_adapter || driver->detach_adapter
-				|| driver->detach_client) {
-			printk(KERN_WARNING
-					"i2c-core: driver [%s] is confused\n",
-					driver->driver.name);
-			return -EINVAL;
-		}
-	}
-
 	/* add the driver to the list of i2c drivers in the driver core */
 	driver->driver.owner = owner;
 	driver->driver.bus = &i2c_bus_type;
 
-	/* for new style drivers, when registration returns the driver core
+	/* When registration returns, the driver core
 	 * will have called probe() for all matching-but-unbound devices.
 	 */
 	res = driver_register(&driver->driver);
 	if (res)
 		return res;
 
-	mutex_lock(&core_lock);
-
 	pr_debug("i2c-core: driver [%s] registered\n", driver->driver.name);
 
 	INIT_LIST_HEAD(&driver->clients);
 	/* Walk the adapters that are already present */
-	class_for_each_device(&i2c_adapter_class, NULL, driver,
-			      __attach_adapter);
-
+	mutex_lock(&core_lock);
+	bus_for_each_dev(&i2c_bus_type, NULL, driver, __attach_adapter);
 	mutex_unlock(&core_lock);
+
 	return 0;
 }
 EXPORT_SYMBOL(i2c_register_driver);
 
 static int __detach_adapter(struct device *dev, void *data)
 {
-	struct i2c_adapter *adapter = to_i2c_adapter(dev);
+	struct i2c_adapter *adapter;
 	struct i2c_driver *driver = data;
 	struct i2c_client *client, *_n;
 
+	if (dev->type != &i2c_adapter_type)
+		return 0;
+	adapter = to_i2c_adapter(dev);
+
+	/* Remove the devices we created ourselves as the result of hardware
+	 * probing (using a driver's detect method) */
 	list_for_each_entry_safe(client, _n, &driver->clients, detected) {
 		dev_dbg(&adapter->dev, "Removing %s at 0x%x\n",
 			client->name, client->addr);
@@ -756,32 +889,11 @@ static int __detach_adapter(struct device *dev, void *data)
 		i2c_unregister_device(client);
 	}
 
-	if (is_newstyle_driver(driver))
-		return 0;
-
-	/* Have a look at each adapter, if clients of this driver are still
-	 * attached. If so, detach them to be able to kill the driver
-	 * afterwards.
-	 */
 	if (driver->detach_adapter) {
 		if (driver->detach_adapter(adapter))
 			dev_err(&adapter->dev,
 				"detach_adapter failed for driver [%s]\n",
 				driver->driver.name);
-	} else {
-		struct i2c_client *client, *_n;
-
-		list_for_each_entry_safe(client, _n, &adapter->clients, list) {
-			if (client->driver != driver)
-				continue;
-			dev_dbg(&adapter->dev,
-				"detaching client [%s] at 0x%02x\n",
-				client->name, client->addr);
-			if (driver->detach_client(client))
-				dev_err(&adapter->dev, "detach_client "
-					"failed for client [%s] at 0x%02x\n",
-					client->name, client->addr);
-		}
 	}
 
 	return 0;
@@ -795,14 +907,11 @@ static int __detach_adapter(struct device *dev, void *data)
 void i2c_del_driver(struct i2c_driver *driver)
 {
 	mutex_lock(&core_lock);
-
-	class_for_each_device(&i2c_adapter_class, NULL, driver,
-			      __detach_adapter);
+	bus_for_each_dev(&i2c_bus_type, NULL, driver, __detach_adapter);
+	mutex_unlock(&core_lock);
 
 	driver_unregister(&driver->driver);
 	pr_debug("i2c-core: driver [%s] unregistered\n", driver->driver.name);
-
-	mutex_unlock(&core_lock);
 }
 EXPORT_SYMBOL(i2c_del_driver);
 
@@ -823,86 +932,6 @@ static int i2c_check_addr(struct i2c_adapter *adapter, int addr)
 	return device_for_each_child(&adapter->dev, &addr, __i2c_check_addr);
 }
 
-int i2c_attach_client(struct i2c_client *client)
-{
-	struct i2c_adapter *adapter = client->adapter;
-	int res;
-
-	/* Check for address business */
-	res = i2c_check_addr(adapter, client->addr);
-	if (res)
-		return res;
-
-	client->dev.parent = &client->adapter->dev;
-	client->dev.bus = &i2c_bus_type;
-
-	if (client->driver)
-		client->dev.driver = &client->driver->driver;
-
-	if (client->driver && !is_newstyle_driver(client->driver)) {
-		client->dev.release = i2c_client_release;
-		client->dev.uevent_suppress = 1;
-	} else
-		client->dev.release = i2c_client_dev_release;
-
-	dev_set_name(&client->dev, "%d-%04x", i2c_adapter_id(adapter),
-		     client->addr);
-	res = device_register(&client->dev);
-	if (res)
-		goto out_err;
-
-	mutex_lock(&adapter->clist_lock);
-	list_add_tail(&client->list, &adapter->clients);
-	mutex_unlock(&adapter->clist_lock);
-
-	dev_dbg(&adapter->dev, "client [%s] registered with bus id %s\n",
-		client->name, dev_name(&client->dev));
-
-	if (adapter->client_register)  {
-		if (adapter->client_register(client)) {
-			dev_dbg(&adapter->dev, "client_register "
-				"failed for client [%s] at 0x%02x\n",
-				client->name, client->addr);
-		}
-	}
-
-	return 0;
-
-out_err:
-	dev_err(&adapter->dev, "Failed to attach i2c client %s at 0x%02x "
-		"(%d)\n", client->name, client->addr, res);
-	return res;
-}
-EXPORT_SYMBOL(i2c_attach_client);
-
-int i2c_detach_client(struct i2c_client *client)
-{
-	struct i2c_adapter *adapter = client->adapter;
-	int res = 0;
-
-	if (adapter->client_unregister)  {
-		res = adapter->client_unregister(client);
-		if (res) {
-			dev_err(&client->dev,
-				"client_unregister [%s] failed, "
-				"client not detached\n", client->name);
-			goto out;
-		}
-	}
-
-	mutex_lock(&adapter->clist_lock);
-	list_del(&client->list);
-	mutex_unlock(&adapter->clist_lock);
-
-	init_completion(&client->released);
-	device_unregister(&client->dev);
-	wait_for_completion(&client->released);
-
- out:
-	return res;
-}
-EXPORT_SYMBOL(i2c_detach_client);
-
 /**
  * i2c_use_client - increments the reference count of the i2c client structure
  * @client: the client being referenced
@@ -967,17 +996,23 @@ static int __init i2c_init(void)
 	retval = bus_register(&i2c_bus_type);
 	if (retval)
 		return retval;
-	retval = class_register(&i2c_adapter_class);
-	if (retval)
+#ifdef CONFIG_I2C_COMPAT
+	i2c_adapter_compat_class = class_compat_register("i2c-adapter");
+	if (!i2c_adapter_compat_class) {
+		retval = -ENOMEM;
 		goto bus_err;
+	}
+#endif
 	retval = i2c_add_driver(&dummy_driver);
 	if (retval)
 		goto class_err;
 	return 0;
 
 class_err:
-	class_unregister(&i2c_adapter_class);
+#ifdef CONFIG_I2C_COMPAT
+	class_compat_unregister(i2c_adapter_compat_class);
 bus_err:
+#endif
 	bus_unregister(&i2c_bus_type);
 	return retval;
 }
@@ -985,7 +1020,9 @@ bus_err:
 static void __exit i2c_exit(void)
 {
 	i2c_del_driver(&dummy_driver);
-	class_unregister(&i2c_adapter_class);
+#ifdef CONFIG_I2C_COMPAT
+	class_compat_unregister(i2c_adapter_compat_class);
+#endif
 	bus_unregister(&i2c_bus_type);
 }
 
@@ -1012,9 +1049,10 @@ module_exit(i2c_exit);
  * Note that there is no requirement that each message be sent to
  * the same slave address, although that is the most common model.
  */
-int i2c_transfer(struct i2c_adapter * adap, struct i2c_msg *msgs, int num)
+int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 {
-	int ret;
+	unsigned long orig_jiffies;
+	int ret, try;
 
 	/* REVISIT the fault reporting model here is weak:
 	 *
@@ -1052,7 +1090,15 @@ int i2c_transfer(struct i2c_adapter * adap, struct i2c_msg *msgs, int num)
 			mutex_lock_nested(&adap->bus_lock, adap->level);
 		}
 
-		ret = adap->algo->master_xfer(adap,msgs,num);
+		/* Retry automatically on arbitration loss */
+		orig_jiffies = jiffies;
+		for (ret = 0, try = 0; try <= adap->retries; try++) {
+			ret = adap->algo->master_xfer(adap, msgs, num);
+			if (ret != -EAGAIN)
+				break;
+			if (time_after(jiffies, orig_jiffies + adap->timeout))
+				break;
+		}
 		mutex_unlock(&adap->bus_lock);
 
 		return ret;
@@ -1123,144 +1169,7 @@ EXPORT_SYMBOL(i2c_master_recv);
  * Will not work for 10-bit addresses!
  * ----------------------------------------------------
  */
-static int i2c_probe_address(struct i2c_adapter *adapter, int addr, int kind,
-			     int (*found_proc) (struct i2c_adapter *, int, int))
-{
-	int err;
-
-	/* Make sure the address is valid */
-	if (addr < 0x03 || addr > 0x77) {
-		dev_warn(&adapter->dev, "Invalid probe address 0x%02x\n",
-			 addr);
-		return -EINVAL;
-	}
-
-	/* Skip if already in use */
-	if (i2c_check_addr(adapter, addr))
-		return 0;
-
-	/* Make sure there is something at this address, unless forced */
-	if (kind < 0) {
-		if (i2c_smbus_xfer(adapter, addr, 0, 0, 0,
-				   I2C_SMBUS_QUICK, NULL) < 0)
-			return 0;
-
-		/* prevent 24RF08 corruption */
-		if ((addr & ~0x0f) == 0x50)
-			i2c_smbus_xfer(adapter, addr, 0, 0, 0,
-				       I2C_SMBUS_QUICK, NULL);
-	}
-
-	/* Finally call the custom detection function */
-	err = found_proc(adapter, addr, kind);
-	/* -ENODEV can be returned if there is a chip at the given address
-	   but it isn't supported by this chip driver. We catch it here as
-	   this isn't an error. */
-	if (err == -ENODEV)
-		err = 0;
-
-	if (err)
-		dev_warn(&adapter->dev, "Client creation failed at 0x%x (%d)\n",
-			 addr, err);
-	return err;
-}
-
-int i2c_probe(struct i2c_adapter *adapter,
-	      const struct i2c_client_address_data *address_data,
-	      int (*found_proc) (struct i2c_adapter *, int, int))
-{
-	int i, err;
-	int adap_id = i2c_adapter_id(adapter);
-
-	/* Force entries are done first, and are not affected by ignore
-	   entries */
-	if (address_data->forces) {
-		const unsigned short * const *forces = address_data->forces;
-		int kind;
-
-		for (kind = 0; forces[kind]; kind++) {
-			for (i = 0; forces[kind][i] != I2C_CLIENT_END;
-			     i += 2) {
-				if (forces[kind][i] == adap_id
-				 || forces[kind][i] == ANY_I2C_BUS) {
-					dev_dbg(&adapter->dev, "found force "
-						"parameter for adapter %d, "
-						"addr 0x%02x, kind %d\n",
-						adap_id, forces[kind][i + 1],
-						kind);
-					err = i2c_probe_address(adapter,
-						forces[kind][i + 1],
-						kind, found_proc);
-					if (err)
-						return err;
-				}
-			}
-		}
-	}
-
-	/* Stop here if we can't use SMBUS_QUICK */
-	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_QUICK)) {
-		if (address_data->probe[0] == I2C_CLIENT_END
-		 && address_data->normal_i2c[0] == I2C_CLIENT_END)
-			return 0;
-
-		dev_dbg(&adapter->dev, "SMBus Quick command not supported, "
-			"can't probe for chips\n");
-		return -EOPNOTSUPP;
-	}
-
-	/* Probe entries are done second, and are not affected by ignore
-	   entries either */
-	for (i = 0; address_data->probe[i] != I2C_CLIENT_END; i += 2) {
-		if (address_data->probe[i] == adap_id
-		 || address_data->probe[i] == ANY_I2C_BUS) {
-			dev_dbg(&adapter->dev, "found probe parameter for "
-				"adapter %d, addr 0x%02x\n", adap_id,
-				address_data->probe[i + 1]);
-			err = i2c_probe_address(adapter,
-						address_data->probe[i + 1],
-						-1, found_proc);
-			if (err)
-				return err;
-		}
-	}
-
-	/* Normal entries are done last, unless shadowed by an ignore entry */
-	for (i = 0; address_data->normal_i2c[i] != I2C_CLIENT_END; i += 1) {
-		int j, ignore;
-
-		ignore = 0;
-		for (j = 0; address_data->ignore[j] != I2C_CLIENT_END;
-		     j += 2) {
-			if ((address_data->ignore[j] == adap_id ||
-			     address_data->ignore[j] == ANY_I2C_BUS)
-			 && address_data->ignore[j + 1]
-			    == address_data->normal_i2c[i]) {
-				dev_dbg(&adapter->dev, "found ignore "
-					"parameter for adapter %d, "
-					"addr 0x%02x\n", adap_id,
-					address_data->ignore[j + 1]);
-				ignore = 1;
-				break;
-			}
-		}
-		if (ignore)
-			continue;
-
-		dev_dbg(&adapter->dev, "found normal entry for adapter %d, "
-			"addr 0x%02x\n", adap_id,
-			address_data->normal_i2c[i]);
-		err = i2c_probe_address(adapter, address_data->normal_i2c[i],
-					-1, found_proc);
-		if (err)
-			return err;
-	}
 
-	return 0;
-}
-EXPORT_SYMBOL(i2c_probe);
-
-/* Separate detection function for new-style drivers */
 static int i2c_detect_address(struct i2c_client *temp_client, int kind,
 			      struct i2c_driver *driver)
 {
@@ -1501,7 +1410,7 @@ struct i2c_adapter* i2c_get_adapter(int id)
 	struct i2c_adapter *adapter;
 
 	mutex_lock(&core_lock);
-	adapter = (struct i2c_adapter *)idr_find(&i2c_adapter_idr, id);
+	adapter = idr_find(&i2c_adapter_idr, id);
 	if (adapter && !try_module_get(adapter->owner))
 		adapter = NULL;
 
@@ -1519,8 +1428,7 @@ EXPORT_SYMBOL(i2c_put_adapter);
 /* The SMBus parts */
 
 #define POLY    (0x1070U << 3)
-static u8
-crc8(u16 data)
+static u8 crc8(u16 data)
 {
 	int i;
 
@@ -1984,18 +1892,31 @@ static s32 i2c_smbus_xfer_emulated(struct i2c_adapter * adapter, u16 addr,
  * This executes an SMBus protocol operation, and returns a negative
  * errno code else zero on success.
  */
-s32 i2c_smbus_xfer(struct i2c_adapter * adapter, u16 addr, unsigned short flags,
+s32 i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr, unsigned short flags,
 		   char read_write, u8 command, int protocol,
-                   union i2c_smbus_data * data)
+		   union i2c_smbus_data *data)
 {
+	unsigned long orig_jiffies;
+	int try;
 	s32 res;
 
 	flags &= I2C_M_TEN | I2C_CLIENT_PEC;
 
 	if (adapter->algo->smbus_xfer) {
 		mutex_lock(&adapter->bus_lock);
-		res = adapter->algo->smbus_xfer(adapter,addr,flags,read_write,
-						command, protocol, data);
+
+		/* Retry automatically on arbitration loss */
+		orig_jiffies = jiffies;
+		for (res = 0, try = 0; try <= adapter->retries; try++) {
+			res = adapter->algo->smbus_xfer(adapter, addr, flags,
+							read_write, command,
+							protocol, data);
+			if (res != -EAGAIN)
+				break;
+			if (time_after(jiffies,
+				       orig_jiffies + adapter->timeout))
+				break;
+		}
 		mutex_unlock(&adapter->bus_lock);
 	} else
 		res = i2c_smbus_xfer_emulated(adapter,addr,flags,read_write,
diff --git a/drivers/i2c/i2c-core.h b/drivers/i2c/i2c-core.h
index cd5bff8..9f9c57f 100644
--- a/drivers/i2c/i2c-core.h
+++ b/drivers/i2c/i2c-core.h
@@ -16,6 +16,8 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#include <linux/rwsem.h>
+
 struct i2c_devinfo {
 	struct list_head	list;
 	int			busnum;
@@ -25,7 +27,7 @@ struct i2c_devinfo {
 /* board_lock protects board_list and first_dynamic_bus_num.
  * only i2c core components are allowed to use these symbols.
  */
-extern struct mutex	__i2c_board_lock;
+extern struct rw_semaphore	__i2c_board_lock;
 extern struct list_head	__i2c_board_list;
 extern int		__i2c_first_dynamic_bus_num;
 
-- 
1.6.4

